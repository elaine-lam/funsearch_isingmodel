#score: {'data3D.txt': -0.43024219999999996}
#standard deviation: 0.04690970580977886
#island_id: 2
#version_generated: 3
#generate time00:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum(1 for val in interacting_spins if val > 0)
        opposite_spin = len(interacting_spins) - same_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (opposite_spin - same_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (same_spin - opposite_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return priorities




#score: {'data3D.txt': -0.105325}
#standard deviation: 0.04837974467687898
#island_id: 2
#version_generated: 3
#generate time00:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_neighbors_same_spin = [J[2, i, (j - 1) % N, k], J[2, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.39937019999999995}
#standard deviation: 0.041901569803051535
#island_id: 2
#version_generated: 3
#generate time00:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_spin = [J[3, i, (j - 1) % N, k], J[3, (i - 1) % N, j, k], J[3, i, j, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]) + len([val for val in site_opposite_spin if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_opposite_spin if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time00:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        site_opposite_spin = [(i - 1) % N, (j - 1) % N, (k - 1) % N]
        
        for d in range(3):
          if interacting_spins[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val == site_opposite_spin[d]])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val != site_opposite_spin[d]])
          elif interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val == site_opposite_spin[d]])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val != site_opposite_spin[d]])
  
  return(priorities)




#score: {'data3D.txt': -0.2708766}
#standard deviation: 0.043354597592873585
#island_id: 0
#version_generated: 3
#generate time00:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.5398381999999999}
#standard deviation: 0.03929742613403581
#island_id: 0
#version_generated: 3
#generate time00:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.471613}
#standard deviation: 0.04741212788939134
#island_id: 1
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.44543499999999997}
#standard deviation: 0.043343069745923626
#island_id: 0
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1770978}
#standard deviation: 0.044909269367915575
#island_id: 3
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum([val for val in site_neighbors])
        
        site_neighbors_sum_positive = sum([1 if val > 0 else 0 for val in site_neighbors])
        site_neighbors_sum_negative = sum([1 if val < 0 else 0 for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum_positive - site_neighbors_sum_negative)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - (site_neighbors_sum if site_neighbors_sum > 0 else -1)
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': 0.023718600000000003}
#standard deviation: 0.047217709961835296
#island_id: 3
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Add the interaction between spins
        for d in range(6):
          spin = 2 * J[d, i, j, k]
          priorities[i * N * N + j * N + k][0] += -spin
          priorities[i * N * N + j * N + k][1] -= 2 * spin
        
  return(priorities)




#score: {'data3D.txt': -0.0034338000000000007}
#standard deviation: 0.046912026790152654
#island_id: 3
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total interaction
        total_interaction = sum(interacting_spins)
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_interaction)) * total_interaction
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_interaction
        
        # Add the interaction between spins
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k]
        
        # Add the interaction with nearest neighbor sites
        for d in range(3):
          site_neighbors_sum = sum([val if val > 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_sum)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - site_neighbors_sum
        
        # Add the interaction with magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * h[i, j, k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.0356362}
#standard deviation: 0.04713770051201055
#island_id: 3
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        site_neighbors_count = len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum if site_neighbors_sum > 0 else -1) + total_spin
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - (site_neighbors_count if site_neighbors_count > 0 else -1)
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.471613}
#standard deviation: 0.04741212788939134
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.48173140000000003}
#standard deviation: 0.04628841036415055
#island_id: 1
#version_generated: 3
#generate time00:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif J[2, i, j, k - 1] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0160086}
#standard deviation: 0.04567439595703484
#island_id: 3
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total interaction
        total_interaction = sum(interacting_spins)
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_interaction)) * total_interaction - 2 * (1 - np.tanh(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) * h[i][j][k] + sum([val for val in site_neighbors if val > 0]) - 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_interaction)) * total_interaction - 2 * (1 + np.tanh(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) * h[i][j][k] + sum([val for val in site_neighbors if val < 0]) - 2
        
        # Add the interaction with nearest neighbor sites
        for d in range(3):
          site_neighbors_sum = sum([val if val > 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_sum)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - site_neighbors_sum
        
        # Add the interaction with magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * h[i, j, k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.0034338000000000007}
#standard deviation: 0.046912026790152654
#island_id: 3
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total interaction
        total_interaction = sum(interacting_spins)
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_interaction)) * total_interaction
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_interaction
        
        # Add the interaction between spins
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k]
        
        # Add the interaction with nearest neighbor sites
        for d in range(3):
          site_neighbors_sum = sum([val if val > 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_sum)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - site_neighbors_sum
        
        # Add the interaction with magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * h[i, j, k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_interaction = sum(interacting_spins)
        site_neighbors_sum = sum([val if val > 0 else -1 for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_interaction)) * total_interaction
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_interaction

        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i, j, k]

        for d in range(3):
          if h[i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * h[i, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * h[i, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]

  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0024202000000000004}
#standard deviation: 0.04689787065486022
#island_id: 0
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in [0, 1, 2]]
  total_spin = sum([np.sum(J[d, :, :, :]) for d in [0, 1]])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0].flatten() if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0].flatten() if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.46151460000000005}
#standard deviation: 0.041210521312402736
#island_id: 0
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.07398940000000005}
#standard deviation: 0.04639182177539486
#island_id: 0
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + sum([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.07398940000000005}
#standard deviation: 0.04639182177539486
#island_id: 0
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + sum([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.07398940000000005}
#standard deviation: 0.04639182177539486
#island_id: 0
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + sum([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.2437566000000002}
#standard deviation: 0.0477298220868253
#island_id: 0
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.24610180000000004}
#standard deviation: 0.0409782127082185
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1, 2]:
          site_neighbors = J[d, i, (j + 1) % N, k]
          if site_neighbors < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0276634}
#standard deviation: 0.04799217207462067
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[2, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[0, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0237026}
#standard deviation: 0.04724218616067635
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 2
#generate time00:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0021142}
#standard deviation: 0.046933541506687944
#island_id: 2
#version_generated: 2
#generate time00:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = total_spin - sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] = -total_spin - sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 2
#generate time00:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1232194}
#standard deviation: 0.047947158243633166
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(val for val in site_neighbors if val)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.08134620000000001}
#standard deviation: 0.0461673896333765
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [val for val in site_neighbors if val < 0] or [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0023390000000000004}
#standard deviation: 0.04706161322139309
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [val for val in site_neighbors if val < 0] or [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.49074900000000005}
#standard deviation: 0.041539738070912297
#island_id: 0
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.28365980000000024}
#standard deviation: 0.046294008942410654
#island_id: 0
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin

          for d in range(6):
            interacting_spins = [J[d, i, j, k]]
            if d < 3:
              interacting_spins.append(J[(d+1)%3, (i + ((j - 1) % 2 - 1)) % N, (k - 1) % N, (k - 1) % N])
            else:
              interacting_spins.extend([J[d-3, i, j, k], J[(d+1)%3, (i + ((j - 1) % 2 - 1)) % N, (k - 1) % N, (k - 1) % N]])

            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])

        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin

          for d in range(6):
            interacting_spins = [J[d, i, j, k]]
            if d < 3:
              interacting_spins.append(J[(d+1)%3, (i + ((j - 1) % 2 - 1)) % N, (k - 1) % N, (k - 1) % N])
            else:
              interacting_spins.extend([J[d-3, i, j, k], J[(d+1)%3, (i + ((j - 1) % 2 - 1)) % N, (k - 1) % N, (k - 1) % N]])

            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.15501540000000033}
#standard deviation: 0.04816650415838792
#island_id: 0
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Additional term to encourage the same spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27563940000000003}
#standard deviation: 0.04383869532319592
#island_id: 0
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.2829386}
#standard deviation: 0.04314716526076771
#island_id: 3
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_spins = sum(J[d, i, (j + 1) % N, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors if val < 0]) - interacting_spins
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors if val > 0]) - interacting_spins
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        
  return(priorities)




#score: {'data3D.txt': -0.3065702}
#standard deviation: 0.05232419662030178
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1995053999999999}
#standard deviation: 0.04584528210012455
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(val for val in site_neighbors if val)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0012874000000000006}
#standard deviation: 0.048936242614651154
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(-val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(interacting_spin_sum) - 2
          priorities[i * N * N + j * N + k][1] -= interacting_spin_sum - len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-interacting_spin_sum) - 2
          priorities[i * N * N + j * N + k][1] -= interacting_spin_sum - len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.021501399999999997}
#standard deviation: 0.04726007192165497
#island_id: 3
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + site_neighbors
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction between spins
        for d in range(6):
          spin = 2 * J[d, i, j, k]
          priorities[i * N * N + j * N + k][0] += -spin
          priorities[i * N * N + j * N + k][1] -= 2 * spin
  
  return(priorities)




#score: {'data3D.txt': -0.4387726000000001}
#standard deviation: 0.04405479326066575
#island_id: 3
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Add the interaction between spins
        for d in range(6):
          spin = 2 * J[d, i, j, k]
          priorities[i * N * N + j * N + k][0] += -spin
          priorities[i * N * N + j * N + k][1] -= 2 * spin
        
        # Add the interaction with site_nbr
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if interacting_spins[1] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 if interacting_spins[1] > 0 else -1)
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': 0.023718600000000003}
#standard deviation: 0.047217709961835296
#island_id: 3
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])

        # Add the interaction between spins
        for d in range(6):
          spin = 2 * J[d, i, j, k]
          priorities[i * N * N + j * N + k][0] += -spin
          priorities[i * N * N + j * N + k][1] -= 2 * spin

  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 2
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3700094000000001}
#standard deviation: 0.04755622726457599
#island_id: 1
#version_generated: 2
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
        neighbor_spins = []
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          neighbor_spins.append(neighbor_spin)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in neighbor_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 1
#version_generated: 2
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val < 0]) + sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.3430038}
#standard deviation: 0.043893518719282466
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.38670220000000005}
#standard deviation: 0.043888422108341964
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.3430038}
#standard deviation: 0.043893518719282466
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.3430038}
#standard deviation: 0.043893518719282466
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.216857}
#standard deviation: 0.0439262025561054
#island_id: 0
#version_generated: 3
#generate time00:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  # Normalize the priorities to ensure they are comparable
  for i in range(N):
    for j in range(N):
      for k in range(N):
        max_val = np.max([priorities[i * N * N + j * N + k][0], priorities[i * N * N + j * N + k][1]])
        min_val = np.min([priorities[i * N * N + j * N + k][0], priorities[i * N * N + j * N + k][1]])
        if max_val > 0:
          priorities[i * N * N + j * N + k] /= max_val
        elif min_val < 0:
          priorities[i * N * N + j * N + k] /= abs(min_val)

  return priorities




#score: {'data3D.txt': -0.0514246}
#standard deviation: 0.0459474386102207
#island_id: 0
#version_generated: 3
#generate time00:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.248037}
#standard deviation: 0.04584261108401222
#island_id: 0
#version_generated: 3
#generate time00:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the site neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val == neighbor_spin])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': 0.027367}
#standard deviation: 0.04559824460437046
#island_id: 0
#version_generated: 3
#generate time00:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        if np.all([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif np.all([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.38924460000000033}
#standard deviation: 0.04693020062646228
#island_id: 0
#version_generated: 3
#generate time00:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in range(6)])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(J[d, i, j, k])) for d in range(6)])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0514246}
#standard deviation: 0.0459474386102207
#island_id: 0
#version_generated: 3
#generate time00:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.1373718}
#standard deviation: 0.04632046680205199
#island_id: 0
#version_generated: 3
#generate time00:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and number of nearest neighbors with the same spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.22887380000000002}
#standard deviation: 0.04833672013655871
#island_id: 0
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[2, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[0, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the energy difference with the neighbor
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - h[(i + d) % N, j, k])
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - h[(i - d) % N, j, k])
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0276634}
#standard deviation: 0.04799217207462067
#island_id: 0
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[2, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[0, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0276634}
#standard deviation: 0.04799217207462067
#island_id: 0
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[2, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[0, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.39959579999999995}
#standard deviation: 0.042402667160922794
#island_id: 1
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_priority = 0
          if spin == 1:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] += site_priority
          priorities[i * N * N + j * N + k][1] += site_neighbor_priority
  
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.005718599999999998}
#standard deviation: 0.04719329416389578
#island_id: 3
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
        for d in range(6):
          spin = J[d,i,j,k]
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if total_spin < 0 else -1)
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 if total_spin > 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 * (spin < 0) - 2 * (spin > 0)
        
  return priorities




#score: {'data3D.txt': -0.423499}
#standard deviation: 0.04015362896426673
#island_id: 3
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.38670220000000005}
#standard deviation: 0.043888422108341964
#island_id: 1
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4909374}
#standard deviation: 0.04102995346378058
#island_id: 0
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3700094000000001}
#standard deviation: 0.04755622726457599
#island_id: 1
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
        neighbor_spins = []
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          neighbor_spins.append(neighbor_spin)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in neighbor_spins if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.47207380000000004}
#standard deviation: 0.04482305247927678
#island_id: 1
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.3700094000000001}
#standard deviation: 0.04755622726457599
#island_id: 1
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
        neighbor_spins = []
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          neighbor_spins.append(neighbor_spin)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in neighbor_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.013313400000000001}
#standard deviation: 0.04665003215904572
#island_id: 2
#version_generated: 3
#generate time00:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, (j+1)%N, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[d, i, (j+1)%N, k] for d in range(6)] + [J[d, (i+1)%N, j, k] for d in range(6)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time00:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time00:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time00:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2

        # Add a new term based on the number of nearest neighbors with different spins
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val != h[i][j][k]])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time00:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        local_energy = h[i][j][k] + sum(interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (local_energy > 0) * 2
        priorities[i * N * N + j * N + k][1] -= (local_energy < 0) * 2

  return(priorities)




#score: {'data3D.txt': -0.48525779999999996}
#standard deviation: 0.04221151287457014
#island_id: 0
#version_generated: 3
#generate time00:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.sum(np.heaviside(site_neighbors, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - np.sum(np.heaviside(site_neighbors, 0))
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.418495}
#standard deviation: 0.0430643339086999
#island_id: 3
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [(d1 + d2 + d3) % 6 for d1, d2, d3 in itertools.product([0, 1], repeat=3)]]
        total_spin = sum(J[(d1 + d2 + d3) % 6, i, j, k] for d1, d2, d3 in itertools.product([0, 1], repeat=3))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.41558100000000003}
#standard deviation: 0.04381798990140922
#island_id: 3
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33236380000000004}
#standard deviation: 0.04095423310916712
#island_id: 3
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else 0 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else 0 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.062129399999999994}
#standard deviation: 0.0465614863985247
#island_id: 2
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [3, 4, 5]] + [J[d, i, (j+1)%N, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.35907939999999994}
#standard deviation: 0.042989881316886656
#island_id: 2
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1]] + [J[d, i, (j+1)%N, k] for d in [3, 4]] + [J[d, i, j, (k+1)%N] for d in [5, 2]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[3, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] = total_spin - sum(val for val in interacting_spins if val < 0) + len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] = -total_spin - sum(1 for val in site_neighbors if val < 0) + sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.12020060000000009}
#standard deviation: 0.048504395261048265
#island_id: 2
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, (j+1)%N, k] for d in [3, 4, 5]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39119740000000003}
#standard deviation: 0.04179067208409073
#island_id: 0
#version_generated: 3
#generate time00:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time00:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time00:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2534082}
#standard deviation: 0.06027066262088049
#island_id: 2
#version_generated: 3
#generate time00:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [3, 4, 5]] + [J[d, i, (j+1)%N, k] for d in range(6)] + [J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0704454}
#standard deviation: 0.04782170029223135
#island_id: 2
#version_generated: 3
#generate time00:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.062129399999999994}
#standard deviation: 0.0465614863985247
#island_id: 2
#version_generated: 3
#generate time00:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]] + [J[d,(i+1)%N,j,k] for d in [3,4,5]] + [J[d,i,(j+1)%N,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # add more improvements here...
  
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1675562}
#standard deviation: 0.04819409550515499
#island_id: 3
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins_sum = sum(interacting_spins)
        site_neighbors_sum = sum([val for val in site_neighbors])
        
        total_spin = interacting_spins_sum + site_neighbors_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins_sum if interacting_spins_sum > 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41558100000000003}
#standard deviation: 0.04381798990140922
#island_id: 3
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins_sum = sum(interacting_spins)
        site_neighbors_sum = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins_sum)) * len([val for val in interacting_spins if val < 0]) - abs(interacting_spins_sum) + site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins_sum)) * len([val for val in interacting_spins if val > 0]) - abs(interacting_spins_sum) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * interacting_spins_sum
        
  return(priorities)




#score: {'data3D.txt': -0.47198419999999996}
#standard deviation: 0.03935093836695639
#island_id: 3
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        interacting_spins_sum = sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins_sum)) * len([val for val in interacting_spins if val > 0]) - abs(interacting_spins_sum) + site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.4956406}
#standard deviation: 0.044242535999194255
#island_id: 0
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.39959579999999995}
#standard deviation: 0.042402667160922794
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_priority = 0
          if spin == 1:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] += site_priority
          priorities[i * N * N + j * N + k][1] += site_neighbor_priority
  
  return priorities




#score: {'data3D.txt': 0.38873260000000004}
#standard deviation: 0.042067025295829986
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = 0
          if h[i][j][k] > 0:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          site_priority += site_neighbor_priority
          priorities[i * N * N + j * N + k][0] = site_priority
          priorities[i * N * N + j * N + k][1] = -site_priority
  
  return(priorities)




#score: {'data3D.txt': -0.09003780000000004}
#standard deviation: 0.05417538602686649
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = 0
          if h[i][j][k] > 0:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority
          priorities[i * N * N + j * N + k][1] = -2
          
  return priorities




#score: {'data3D.txt': -0.39959579999999995}
#standard deviation: 0.042402667160922794
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_priority = 0
          if spin == 1:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] += site_priority
          priorities[i * N * N + j * N + k][1] += site_neighbor_priority
  
  return(priorities)




#score: {'data3D.txt': -0.002243400000000001}
#standard deviation: 0.047075932666703485
#island_id: 0
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(total_spin)) * (val < 0) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(total_spin)) * (val > 0) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': 0.2351766}
#standard deviation: 0.04585001343991079
#island_id: 0
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.17722699999999994}
#standard deviation: 0.045614904921527574
#island_id: 0
#version_generated: 3
#generate time01:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + np.sum(np.heaviside(site_neighbors, 0))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin - np.sum(np.heaviside(site_neighbors, 0))
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.48525779999999996}
#standard deviation: 0.04221151287457014
#island_id: 0
#version_generated: 3
#generate time01:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.sum(np.heaviside(site_neighbors, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - np.sum(np.heaviside(site_neighbors, 0))
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.48525779999999996}
#standard deviation: 0.04221151287457014
#island_id: 0
#version_generated: 3
#generate time01:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.sum(np.heaviside(site_neighbors, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - np.sum(np.heaviside(site_neighbors, 0))
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3924838}
#standard deviation: 0.04365847978984152
#island_id: 0
#version_generated: 3
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin) + np.sum(np.heaviside(site_neighbors, 0))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin) - np.sum(np.heaviside(site_neighbors, 0))
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.10882580000000015}
#standard deviation: 0.052981949514528066
#island_id: 3
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [val for val in site_neighbors if val < 0] or [val for val in site_neighbors if val > 0]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in range(6):
          spin = J[d, i, j, k]
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if total_spin < 0 else -1)
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 if total_spin > 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 * (spin < 0) - 2 * (spin > 0)
  
  return priorities




#score: {'data3D.txt': -0.0025402000000000003}
#standard deviation: 0.046926473380811386
#island_id: 3
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend([val for val in site_neighbors if val < 0] or [val for val in site_neighbors if val > 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': 0.015678200000000003}
#standard deviation: 0.048393772375792315
#island_id: 3
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
        for d in range(6):
          spin = J[d,i,j,k]
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if total_spin < 0 else -1)
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 if total_spin > 0 else 1)
          priorities[i * N * N + j * N + k][1] += 2 * (spin < 0) - 2 * (spin > 0)
        
  return priorities




#score: {'data3D.txt': -0.0029194000000000004}
#standard deviation: 0.04700216956311698
#island_id: 3
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        interacting_spins.extend([val for val in site_neighbors if val < 0] or [val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.47207380000000004}
#standard deviation: 0.04482305247927678
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.47207380000000004}
#standard deviation: 0.04482305247927678
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.36778459999999996}
#standard deviation: 0.04921890980954373
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.289499}
#standard deviation: 0.04256802178866197
#island_id: 2
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # add a term based on the product of the spins with their neighbors
        spin_product = np.prod(np.array(interacting_spins)) * np.prod(np.array(site_neighbors))
        priorities[i * N * N + j * N + k][0] += -spin_product
        priorities[i * N * N + j * N + k][1] += 2 * spin_product
        
  return(priorities)




#score: {'data3D.txt': -0.5205874000000001}
#standard deviation: 0.04235868413017572
#island_id: 2
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,-1,0,0), (1,0,-1,0), (2,0,0,-1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 2
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.08841939999999995}
#standard deviation: 0.04734393882684457
#island_id: 3
#version_generated: 2
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 2
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2779674}
#standard deviation: 0.043058057750437376
#island_id: 3
#version_generated: 2
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin < 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * abs(total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 2
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.08814780000000004}
#standard deviation: 0.044669089482101604
#island_id: 1
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin

          site_neighbor_priority = -2
          if np.any([val > 0 for val in site_neighbors]):
            site_neighbor_priority -= len([val for val in site_neighbors if val > 0])
          if np.any([val < 0 for val in site_neighbors]):
            site_neighbor_priority += len([val for val in site_neighbors if val < 0])

          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority
          priorities[i * N * N + j * N + k][1] = -2

  return priorities




#score: {'data3D.txt': -0.09003780000000004}
#standard deviation: 0.05417538602686649
#island_id: 1
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = 0
          if h[i][j][k] > 0:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority
          priorities[i * N * N + j * N + k][1] = -2
          
  return priorities




#score: {'data3D.txt': -0.09003780000000004}
#standard deviation: 0.05417538602686649
#island_id: 1
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        for spin in [-1, 1]:
          site_priority = 0
          if h[i][j][k] > 0:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority
          priorities[i * N * N + j * N + k][1] = -2
          
  return priorities




#score: {'data3D.txt': -0.09003780000000004}
#standard deviation: 0.05417538602686649
#island_id: 1
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = 0
          if h[i][j][k] > 0:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority
          priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.22475300000000004}
#standard deviation: 0.05870962162201355
#island_id: 2
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, (j+1)%N, k] for d in [3, 4, 5]] + [J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1852114}
#standard deviation: 0.04474805906450022
#island_id: 2
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = total_spin - sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] = -total_spin - sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add more priority to the site that has more nearest neighbors with different spin than its current spin
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val != h[i][j][k]])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val != h[i][j][k]])
        
  return(priorities)




#score: {'data3D.txt': -0.0033894}
#standard deviation: 0.04694445321483679
#island_id: 2
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        spin_sum = total_spin - sum(val for val in interacting_spins)
        neighbor_sum = -sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = neighbor_sum - sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4732766}
#standard deviation: 0.04057077189849855
#island_id: 0
#version_generated: 2
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 1)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5622493999999999}
#standard deviation: 0.04261849738834066
#island_id: 3
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0031742}
#standard deviation: 0.04687452799079688
#island_id: 0
#version_generated: 3
#generate time01:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        priorities[i*N*N+k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+1, i, j, k] if val < 0]) + total_spin
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3671298}
#standard deviation: 0.04884673000273406
#island_id: 0
#version_generated: 3
#generate time01:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0006526000000000003}
#standard deviation: 0.046377813588395905
#island_id: 0
#version_generated: 3
#generate time01:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:d] + interacting_spins[d+1:] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:d] + interacting_spins[d+1:] if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_neighbors[1], site_neighbors[2]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [site_neighbors[0], site_neighbors[1], site_neighbors[2]] if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_neighbors[1], site_neighbors[2]] if val < 0]) + sum(val for val in [site_neighbors[0], site_neighbors[1], site_neighbors[2]])
            priorities[i * N * N + j * N + k][1] = -3 + 3 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3179178}
#standard deviation: 0.046002571266832465
#island_id: 0
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.14617419999999998}
#standard deviation: 0.05521178582838994
#island_id: 1
#version_generated: 3
#generate time01:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43617740000000005}
#standard deviation: 0.048115411348548194
#island_id: 1
#version_generated: 3
#generate time01:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + site_neighbors
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.34960860000000005}
#standard deviation: 0.04012122887001344
#island_id: 1
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0]) + sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.36778459999999996}
#standard deviation: 0.04921890980954373
#island_id: 1
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0033302000000000006}
#standard deviation: 0.047009011561188994
#island_id: 2
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_sum = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        return(priorities)




#score: {'data3D.txt': -0.0033894}
#standard deviation: 0.04694445321483679
#island_id: 2
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        spin_sum = total_spin - sum(val for val in interacting_spins)
        neighbor_sum = -sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0033894}
#standard deviation: 0.04694445321483679
#island_id: 2
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        spin_sum = total_spin - sum(val for val in interacting_spins)
        neighbor_sum = -sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = neighbor_sum - sum(val for val in site_neighbors if val < 0) + sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0032066}
#standard deviation: 0.047003117305557514
#island_id: 2
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbor_sum = -sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0032438000000000007}
#standard deviation: 0.04696729544651257
#island_id: 3
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.509623}
#standard deviation: 0.042876935419873474
#island_id: 2
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i, j, k] < 0) - sum(1 for d in [4, 5] if J[d, i, j, k] > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i, j, k] > 0) - sum(1 for d in [4, 5] if J[d, i, j, k] < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.2548098}
#standard deviation: 0.046930203749397895
#island_id: 3
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin - 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.0031422000000000004}
#standard deviation: 0.04683341690673445
#island_id: 3
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          neighbor_spin = J[d, i + d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1

        return(priorities)




#score: {'data3D.txt': -0.22905500000000031}
#standard deviation: 0.049740306945172744
#island_id: 3
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 1)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin + 1)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1130370000000001}
#standard deviation: 0.046724502683281724
#island_id: 1
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1, 2]:
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.45025139999999997}
#standard deviation: 0.044050792025115734
#island_id: 1
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          site_neighbor_priority = -2
          if np.any([val > 0 for val in site_neighbors]):
            site_neighbor_priority -= len([val for val in site_neighbors if val > 0])
          if np.any([val < 0 for val in site_neighbors]):
            site_neighbor_priority += len([val for val in site_neighbors if val < 0])
          
          interacting_spin_priority = -2
          if np.sum([spin * val for val in interacting_spins]) > 0:
            interacting_spin_priority += len([val for val in interacting_spins if val > 0])
          else:
            interacting_spin_priority -= len([val for val in interacting_spins if val < 0])
          
          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority + interacting_spin_priority
          priorities[i * N * N + j * N + k][1] = -2
          
  return priorities




#score: {'data3D.txt': -0.058510999999999994}
#standard deviation: 0.04691540939819241
#island_id: 1
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          neighbor_priority = -2
          if site_neighbors_sum > 0:
            neighbor_priority -= len([val for val in site_neighbors if val > 0])
          elif site_neighbors_sum < 0:
            neighbor_priority += len([val for val in site_neighbors if val < 0])
          total_priority = site_priority + neighbor_priority - abs(total_spin) * spin
          priorities[i * N * N + j * N + k][0] = total_priority
          priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.0033302000000000006}
#standard deviation: 0.047009011561188994
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0034609999999999997}
#standard deviation: 0.04694649038000604
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.36654100000000006}
#standard deviation: 0.05220814724734063
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 3
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (total_spin < 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-total_spin < 0)
          priorities[i * N * N + j * N + k][1] += (-total_spin < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2166374000000003}
#standard deviation: 0.04512155761096906
#island_id: 3
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[0, i-1 if i>0 else N-1, j, k], J[0, i+1 if i<N-1 else 0, j, k]]) - 
                                            np.sum([J[1, i, j-1 if j>0 else N-1, k], J[1, i, j+1 if j<N-1 else 0, k]])) * 2
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[0, i-1 if i>0 else N-1, j, k], J[0, i+1 if i<N-1 else 0, j, k]]) - 
                                            np.sum([J[1, i, j-1 if j>0 else N-1, k], J[1, i, j+1 if j<N-1 else 0, k]])) * 2
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0025481999999999996}
#standard deviation: 0.04675063290223995
#island_id: 2
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + 2
          priorities[i * N * N + j * N + k][1] = 2 + total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + 2
          priorities[i * N * N + j * N + k][1] = 2 + total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0032778}
#standard deviation: 0.047007218032553255
#island_id: 2
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_neighbor_sum = -sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.4153822000000001}
#standard deviation: 0.04778092551594203
#island_id: 2
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_neighbor_sum = -sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0032938}
#standard deviation: 0.046939625494458306
#island_id: 2
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(3):
          site_neighbors[d] += J[d, i, j, k]
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(neighbor_spin_sum)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]) + neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * neighbor_spin_sum
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin_sum)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]) + neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * neighbor_spin_sum
        
        return(priorities)




#score: {'data3D.txt': -0.15368859999999998}
#standard deviation: 0.04786053018970851
#island_id: 1
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_priority = np.sum([spin * val for spin, val in zip([-1, 1], interacting_spins)])
        
        if total_spin > 0:
          site_priority = h[i][j][k] - len([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        elif total_spin < 0:
          site_priority = h[i][j][k] - len([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          site_priority = h[i][j][k]
          priorities[i * N * N + j * N + k][1] = 0
        
        priorities[i * N * N + j * N + k][0] = site_priority + interacting_spin_priority
        
  return priorities




#score: {'data3D.txt': -0.3027958000000001}
#standard deviation: 0.047908119795708956
#island_id: 1
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
        interacting_spin_priority = 0
        for spin in [-1, 1]:
          if np.sum([spin * val for val in interacting_spins]) > 0:
            interacting_spin_priority += len([val for val in interacting_spins if val > 0])
          else:
            interacting_spin_priority -= len([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += interacting_spin_priority
        
  return priorities




#score: {'data3D.txt': -0.45609540000000004}
#standard deviation: 0.04012754837814042
#island_id: 0
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            site_neighbors[d-3] += -J[d-3, i, j, k]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.zeros((N, N, N)) for _ in range(6)]

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i*N*N + j*N + k][0] += -J[d, i, j, k]*interacting_spins[d][i,j,k]
          priorities[i*N*N + j*N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.3337798}
#standard deviation: 0.04980247174548669
#island_id: 0
#version_generated: 3
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0032438000000000007}
#standard deviation: 0.04696729544651257
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * interacting_spins[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= J[d, i, j, k] * interacting_spins[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.08106100000000009}
#standard deviation: 0.04734129190252417
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] > 0)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0032481999999999997}
#standard deviation: 0.049058235157412665
#island_id: 1
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        priorities[i * N * N + j * N + k][0] = total_spin - interacting_spin_sum
        priorities[i * N * N + j * N + k][1] = -2

  return priorities




#score: {'data3D.txt': -0.2524586}
#standard deviation: 0.04757893027422959
#island_id: 1
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          neighbor_priority = -2
          if site_neighbors_sum > 0:
            neighbor_priority -= len([val for val in site_neighbors if val > 0])
          elif site_neighbors_sum < 0:
            neighbor_priority += len([val for val in site_neighbors if val < 0])
          
          interacting_spin_sum = sum(J[d, i, j, k] * spin for d in [0, 1, 2])
          total_priority = site_priority + neighbor_priority - abs(total_spin) * spin + interacting_spin_sum
          priorities[i * N * N + j * N + k][0] = total_priority
          priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.05601979999999999}
#standard deviation: 0.049411029213729196
#island_id: 1
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        interacting_spin_counts = [sum(1 for d in [0, 1, 2] if J[d, i, j, k] * spin < 0) 
                      for spin in [-1, 1]]
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          neighbor_priority = -2
          if site_neighbors_sum > 0:
            neighbor_priority -= len([val for val in site_neighbors if val > 0])
          elif site_neighbors_sum < 0:
            neighbor_priority += len([val for val in site_neighbors if val < 0])
          
          total_priority = site_priority + neighbor_priority - abs(total_spin) * spin - sum(val * (J[2, i, j, k] == J[d, i, j, k]) 
                                            for d, val in zip([0, 1], interacting_spin_counts))
          priorities[i * N * N + j * N + k][0] = total_priority
          priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.3837118}
#standard deviation: 0.03870460774584856
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val < 0]) - len([val for val in J[:1, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val > 0]) - len([val for val in J[:1, i, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[5, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0166386}
#standard deviation: 0.04643052605818719
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, (j+1)%N, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[d, i, (j+1)%N, k] for d in range(6)] + [J[d, (i+1)%N, j, k] for d in range(6)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Additional term to favor spins that are aligned with the local magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.29509780000000013}
#standard deviation: 0.04323384501938267
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins_y = [J[d, i, (j+1)%N, k] for d in [3]]
        interacting_spins_z = [J[d, i, j, (k+1)%N] for d in [4, 5]]
        
        total_spin_x = sum(J[0, i, j, k] for i in range(6))
        total_spin_y = sum(J[d, i, j, k] for d in [3])
        total_spin_z = sum(J[d, i, j, k] for d in range(4, 6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.0149026}
#standard deviation: 0.04627997226922246
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[d, i, (j+d)%N, k] for d in range(6)] + [J[d, (i+d)%N, j, k] for d in range(6)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4880642}
#standard deviation: 0.041741323390137024
#island_id: 0
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1639114}
#standard deviation: 0.05466561432966797
#island_id: 0
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        spin_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        spin_down = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += spin_up
        priorities[i * N * N + j * N + k][1] -= spin_down
        
  return(priorities)




#score: {'data3D.txt': 0.0821906}
#standard deviation: 0.046194352378185796
#island_id: 0
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d // 3, j, k]
          else:
            neighbor_spin = J[2, i - d // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2913758}
#standard deviation: 0.05251801304657289
#island_id: 3
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_x = (i + 1) % N if h[i][j][k] > 0 else (i - 1) % N
        site_nbr_y = (j + 1) % N if h[i][j][k] > 0 else (j - 1) % N
        site_nbr_z = (k + 1) % N if h[i][j][k] > 0 else (k - 1) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 * total_spin - 2
        
  return priorities




#score: {'data3D.txt': 0.2548098}
#standard deviation: 0.046930203749397895
#island_id: 3
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin - 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.08149900000000003}
#standard deviation: 0.04577983834615409
#island_id: 3
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[0, i-1 if i>0 else N-1, j, k], J[0, i+1 if i<N-1 else 0, j, k]]) - 
                                           np.sum([J[1, i, j-1 if j>0 else N-1, k], J[1, i, j+1 if j<N-1 else 0, k]])) * 2
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[0, i-1 if i>0 else N-1, j, k], J[0, i+1 if i<N-1 else 0, j, k]]) - 
                                           np.sum([J[1, i, j-1 if j>0 else N-1, k], J[1, i, j+1 if j<N-1 else 0, k]])) * 2
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.332615}
#standard deviation: 0.05495744367235434
#island_id: 2
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_sum = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0033654}
#standard deviation: 0.0469734269863292
#island_id: 2
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        return(priorities)




#score: {'data3D.txt': -0.3779906}
#standard deviation: 0.05004035523095335
#island_id: 2
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) - (neighbor_spin_sum < 0) + total_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3773926}
#standard deviation: 0.05279917409619207
#island_id: 2
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.320589}
#standard deviation: 0.04750290516378972
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin

          if np.any([val > 0 for val in interacting_spins]):
            site_priority += len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          else:
            site_priority -= len([val for val in interacting_spins if val < 0])

          site_neighbor_priority = 0
          if np.any([val > 0 for val in site_neighbors]):
            site_neighbor_priority -= len([val for val in site_neighbors if val > 0])
          if np.any([val < 0 for val in site_neighbors]):
            site_neighbor_priority += len([val for val in site_neighbors if val < 0])

          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority
          priorities[i * N * N + j * N + k][1] = -2

  return priorities




#score: {'data3D.txt': 0.22314140000000002}
#standard deviation: 0.04308309420225061
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          site_neighbors.sort()
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= (total_spin - abs(total_spin) + sum(val for val in site_neighbors))
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] += (total_spin - abs(total_spin) + sum(val for val in site_neighbors))

  return(priorities)




#score: {'data3D.txt': 0.0348566}
#standard deviation: 0.04461907704603492
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d // 3, j, k]
          else:
            neighbor_spin = J[2, i - d // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if J[3, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 6
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 6
          priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': 0.2449214}
#standard deviation: 0.04350250684776683
#island_id: 0
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1

        for d in [3, 4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d // 3, j, k]
          else:
            neighbor_spin = J[2, i - d // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] -= 3 * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += 3 * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': 0.002255}
#standard deviation: 0.04615312313375987
#island_id: 0
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if i > 0:
          site_neighbors.append(J[0, i-1, j, k])
        if i < N-1:
          site_neighbors.append(J[0, i+1, j, k])
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if j < N-1:
          site_neighbors.append(J[1, i, j+1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        if k < N-1:
          site_neighbors.append(J[2, i, j, k+1])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1875742}
#standard deviation: 0.058679275509842484
#island_id: 2
#version_generated: 3
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4158646}
#standard deviation: 0.047742201319587264
#island_id: 2
#version_generated: 3
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) - (neighbor_spin_sum < 0) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33757460000000006}
#standard deviation: 0.05450462104115577
#island_id: 2
#version_generated: 3
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1875742}
#standard deviation: 0.058679275509842484
#island_id: 2
#version_generated: 3
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0677945999999999}
#standard deviation: 0.047370063234494435
#island_id: 0
#version_generated: 2
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.49135700000000004}
#standard deviation: 0.044193986366925536
#island_id: 0
#version_generated: 2
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin as the current site
        same_spin_neighbors = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in same_spin_neighbors if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3308981999999998}
#standard deviation: 0.044657726730768545
#island_id: 0
#version_generated: 2
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] += neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] += neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4550638}
#standard deviation: 0.04766419336944664
#island_id: 2
#version_generated: 3
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val > 0]) - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 2
#version_generated: 3
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3773926}
#standard deviation: 0.05279917409619207
#island_id: 2
#version_generated: 3
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09737740000000028}
#standard deviation: 0.04720054585743687
#island_id: 3
#version_generated: 2
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23333179999999998}
#standard deviation: 0.05144462215586776
#island_id: 3
#version_generated: 2
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 3
#version_generated: 2
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.007080199999999925}
#standard deviation: 0.049105124864518984
#island_id: 2
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * np.exp(-abs(total_spin))
        
        for d in [3, 4]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3929618}
#standard deviation: 0.044056507586961544
#island_id: 2
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.38341420000000004}
#standard deviation: 0.042804405361598005
#island_id: 2
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.092317}
#standard deviation: 0.05563871413862833
#island_id: 1
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + site_neighbors
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) / abs(total_spin) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * ((len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0,1,2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        
        site_priority = h[i][j][k]
        
        total_spin = sum(val for val in interacting_spins)
        spin_diff = np.sum([val if val > 0 else -val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] = site_priority + spin_diff
        priorities[i * N * N + j * N + k][1] = -2 - total_spin
        
  return priorities




#score: {'data3D.txt': -0.45025139999999997}
#standard deviation: 0.044050792025115734
#island_id: 1
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          site_neighbor_priority = -2
          if np.any([val > 0 for val in site_neighbors]):
            site_neighbor_priority -= len([val for val in site_neighbors if val > 0])
          if np.any([val < 0 for val in site_neighbors]):
            site_neighbor_priority += len([val for val in site_neighbors if val < 0])
          
          interacting_spin_priority = -2
          if np.sum([spin * val for val in interacting_spins]) > 0:
            interacting_spin_priority += len([val for val in interacting_spins if val > 0])
          else:
            interacting_spin_priority -= len([val for val in interacting_spins if val < 0])
          
          priorities[i * N * N + j * N + k][0] = site_priority + site_neighbor_priority + interacting_spin_priority
          priorities[i * N * N + j * N + k][1] = -2
          
  return priorities




#score: {'data3D.txt': -0.3837118}
#standard deviation: 0.03870460774584856
#island_id: 2
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val < 0]) - len([val for val in J[:1, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val > 0]) - len([val for val in J[:1, i, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[5, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3468586}
#standard deviation: 0.03954853683816887
#island_id: 2
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[1:, i, j, k] if val < 0]) - len([val for val in J[:1, i, j, k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[1:, i, j, k] if val > 0]) - len([val for val in J[:1, i, j, k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[5, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3837118}
#standard deviation: 0.03870460774584856
#island_id: 2
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val < 0]) - len([val for val in J[:1, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val > 0]) - len([val for val in J[:1, i, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[5, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3837118}
#standard deviation: 0.03870460774584856
#island_id: 2
#version_generated: 3
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val < 0]) - len([val for val in J[:1, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[1:, i, j, k] if val > 0]) - len([val for val in J[:1, i, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[5, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.24577100000000035}
#standard deviation: 0.04602350876454338
#island_id: 0
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40851539999999986}
#standard deviation: 0.045573477405613884
#island_id: 1
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        
        # Calculate the priority for each spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - interacting_spin_sum
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - interacting_spin_sum
          priorities[i * N * N + j * N + k][1] = 2

  return priorities




#score: {'data3D.txt': -0.17676499999999998}
#standard deviation: 0.04834084003200606
#island_id: 1
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        spin_energy = total_spin + interacting_spin_sum
        priorities[i * N * N + j * N + k][0] = spin_energy if h[i][j][k] > 0 else -spin_energy
        priorities[i * N * N + j * N + k][1] = np.exp(-abs(spin_energy))

  return priorities




#score: {'data3D.txt': -0.45489260000000004}
#standard deviation: 0.0429618754855977
#island_id: 1
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.368529}
#standard deviation: 0.04489721192902738
#island_id: 1
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin - sum([J[d, i, j, k]*spin for d, spin in enumerate(interacting_spins)])
          priorities[i*N**2 + j*N + k][1] = -2
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin - sum([J[d, i, j, k]*spin for d, spin in enumerate(interacting_spins)])
          priorities[i*N**2 + j*N + k][1] = 2

  return priorities




#score: {'data3D.txt': -0.19849140000000007}
#standard deviation: 0.04776422349457802
#island_id: 1
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[i][j][k] if d < 3 else h[(i+1)%N][(j+1)%N][k])
                   for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = 4
  
  return priorities




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.4948726}
#standard deviation: 0.04429678960421398
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4948726}
#standard deviation: 0.04429678960421398
#island_id: 3
#version_generated: 3
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 3
#version_generated: 3
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 3
#version_generated: 3
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40139700000000006}
#standard deviation: 0.04688171702273713
#island_id: 3
#version_generated: 3
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
      else:
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.39362300000000006}
#standard deviation: 0.04579959727988883
#island_id: 3
#version_generated: 3
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  for d in [0, 1]:
    for i in range(N):
      for j in range(N):
        if (i + (d - 1) % 2 == 0):
          site_neighbors = [J[d, i, j, k], J[3 - d, (i + 1) % N, j, k]]
        else:
          site_neighbors = [J[3 - d, i - 1, j, k], J[d, (i + 1) % N, j, k]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_priority = np.sum([spin * val for spin, val in zip([-1, 1], interacting_spins)])
        
        site_priority = h[i][j][k] + total_spin - len([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -2
        
        if site_priority > 0:
          priorities[i * N * N + j * N + k][0] = site_priority
        else:
          priorities[i * N * N + j * N + k][0] = -site_priority
        
  return priorities




#score: {'data3D.txt': -0.1930382}
#standard deviation: 0.044729038674668604
#island_id: 1
#version_generated: 3
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_priority = np.sum([spin * val for spin, val in zip([-1, 1], interacting_spins)])
        
        if total_spin > 0:
          site_priority = h[i][j][k] - len([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        elif total_spin < 0:
          site_priority = h[i][j][k] - len([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          site_priority = h[i][j][k]
          priorities[i * N * N + j * N + k][1] = 0
        
        if total_spin > 0:
          spin_direction = 1
        elif total_spin < 0:
          spin_direction = -1
        else:
          spin_direction = 0
        
        site_priority += np.sum([spin * val for spin, val in zip([-1, 1], site_neighbors)]) + interacting_spin_priority * spin_direction
        
        priorities[i * N * N + j * N + k][0] = site_priority
        
  return priorities




#score: {'data3D.txt': -0.2524586}
#standard deviation: 0.04757893027422959
#island_id: 1
#version_generated: 3
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          neighbor_priority = -2
          if site_neighbors_sum > 0:
            neighbor_priority -= len([val for val in site_neighbors if val > 0])
          elif site_neighbors_sum < 0:
            neighbor_priority += len([val for val in site_neighbors if val < 0])
          
          interacting_spin_sum = sum(J[d, i, j, k] * spin for d in [0, 1, 2])
          total_priority = site_priority + neighbor_priority - abs(total_spin) * spin + interacting_spin_sum
          priorities[i * N * N + j * N + k][0] = total_priority
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.13130660000000002}
#standard deviation: 0.04761322795652486
#island_id: 1
#version_generated: 3
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]-h[i][j][k]) for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        for spin in [-1, 1]:
          site_priority = h[i][j][k] * spin
          neighbor_priority = -2
          if site_neighbors_sum > 0:
            neighbor_priority -= len([val for val in site_neighbors if val > 0])
          elif site_neighbors_sum < 0:
            neighbor_priority += len([val for val in site_neighbors if val < 0])
          
          interacting_spin_sum = sum(J[d, i, j, k] * spin for d in [0, 1, 2])
          total_priority = site_priority + neighbor_priority - abs(total_spin) * spin + interacting_spin_sum
          priorities[i * N * N + j * N + k][0] = total_priority
          priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.111407}
#standard deviation: 0.05200265676866905
#island_id: 1
#version_generated: 3
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]) for d in [0, 1, 2]]
        
        site_priority = h[i][j][k]
        if any(val > 0 for val in interacting_spins):
          site_priority -= len([val for val in interacting_spins if val > 0])
        elif any(val < 0 for val in interacting_spins):
          site_priority += len([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] = site_priority
        priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.45489260000000004}
#standard deviation: 0.0429618754855977
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45489260000000004}
#standard deviation: 0.0429618754855977
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.380007}
#standard deviation: 0.04534563872082959
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
              priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
              priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
              priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.011547799999999999}
#standard deviation: 0.04914129622995308
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
            if J[d, i, (j + 1) % N, k] < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, (j + 1) % N, k])) 
                priorities[i * N * N + j * N + k][1] -= -2 + 2 * J[d, i, (j + 1) % N, k]
            elif J[d, i, (j + 1) % N, k] > 0:
                priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, (j + 1) % N, k]))
                priorities[i * N * N + j * N + k][1] = -2 + 2 * J[d, i, (j + 1) % N, k]
        
  return priorities




#score: {'data3D.txt': -0.164903}
#standard deviation: 0.0460546483104583
#island_id: 2
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[d, (i+1)%N, j, k] for d in [0, 1]]
        interacting_spins_y = [J[d, i, (j+1)%N, k] for d in [3, 4]]
        interacting_spins_z = [J[d, i, j, (k+1)%N] for d in [5]]
        
        total_spin_x = sum(J[d, (i+1)%N, j, k] for d in [0, 1])
        total_spin_y = sum(J[d, i, (j+1)%N, k] for d in [3, 4])
        total_spin_z = sum(J[d, i, j, (k+1)%N] for d in [5])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_y + total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_y + total_spin_z)

  return(priorities)




#score: {'data3D.txt': -0.24775819999999998}
#standard deviation: 0.05181640717726385
#island_id: 2
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, (i+1)%N, j, k], J[3, i, (j+1)%N, k], J[5, i, j, (k+1)%N]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in [J[0, (i+1)%N, j, k], J[3, i, (j+1)%N, k], J[5, i, j, (k+1)%N]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2423382}
#standard deviation: 0.056001084103434996
#island_id: 2
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j+1)%N, k] for d in [0, 4]] + [J[d, (i+1)%N, j, k] for d in [1, 3]] + [J[d, i, j, (k+1)%N] for d in [2, 5]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2393594}
#standard deviation: 0.054819743812243416
#island_id: 2
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1]] + \
                   [J[d, i, (j+1)%N, k] for d in [2, 3]] + \
                   [J[d, i, j, (k+1)%N] for d in range(4,6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3810862}
#standard deviation: 0.04370855808145586
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in interacting_spins])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.0264918}
#standard deviation: 0.04807360869292007
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
        for d in [0, 1, 2]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37262300000000015}
#standard deviation: 0.04910942059320187
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          site_neighbors.reverse()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.23333179999999998}
#standard deviation: 0.05144462215586776
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        site_neighbors[site_neighbors.index(min(site_neighbors))], site_neighbors[site_neighbors.index(max(site_neighbors))]
        site_neighbors.sort(reverse=True)
        site_neighbors[0], site_neighbors[-1]
        site_neighbors.sort()
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4015125999999999}
#standard deviation: 0.045647843336131456
#island_id: 2
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,-1,0,0), (1,0,-1,0), (2,0,0,-1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 2
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_magnetism = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_magnetism - abs(site_magnetism)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_magnetism - abs(site_magnetism)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.055810200000000004}
#standard deviation: 0.04719108322511786
#island_id: 2
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on site interaction and magnetism
        site_energy = h[i][j][k]
        spin_energy = sum(val for val in interacting_spins) / len(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy)) * (1 - abs(spin_energy))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_energy
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_energy)) * (1 - abs(spin_energy))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_energy
        
  return priorities




#score: {'data3D.txt': -0.08859979999999999}
#standard deviation: 0.049692660624683804
#island_id: 1
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]) for d in [0, 1, 2]]
        
        site_priority = h[i][j][k]
        if any(val > 0 for val in interacting_spins):
          site_priority -= len([val for val in interacting_spins if val > 0])
        elif any(val < 0 for val in interacting_spins):
          site_priority += len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = site_priority - site_neighbor_sum
        priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.0029025999999999995}
#standard deviation: 0.04555542726437762
#island_id: 1
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]) for d in [0, 1, 2]]
        
        site_priority = h[i][j][k]
        if any(val > 0 for val in interacting_spins):
          site_priority -= len([val for val in interacting_spins if val > 0])
        elif any(val < 0 for val in interacting_spins):
          site_priority += len([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][1] = -2
        
        # Update priorities based on the sign of the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += site_priority
        else:
          priorities[i * N * N + j * N + k][0] -= site_priority
        
  return priorities




#score: {'data3D.txt': -0.2276502000000001}
#standard deviation: 0.05137983417606559
#island_id: 1
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]) for d in [0, 1, 2]]
        
        site_priority = h[i][j][k]
        if any(val > 0 for val in interacting_spins):
          site_priority -= len([val for val in interacting_spins if val > 0])
        elif any(val < 0 for val in interacting_spins):
          site_priority += len([val for val in interacting_spins if val < 0])
        
        # Add the effect of magnetism
        site_priority += h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = site_priority
        priorities[i * N * N + j * N + k][1] = -2
 
  return priorities




#score: {'data3D.txt': -0.22326020000000008}
#standard deviation: 0.05595929820825133
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]) for d in [0, 1, 2]]
        
        site_priority = h[i][j][k]
        if any(val > 0 for val in interacting_spins):
          site_priority -= len([val for val in interacting_spins if val > 0])
        elif any(val < 0 for val in interacting_spins):
          site_priority += len([val for val in interacting_spins if val < 0])
        
        # Add the effect of magnetism
        site_priority += h[i][j][k]
        
        site_priority -= np.sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] = site_priority
        priorities[i * N * N + j * N + k][1] = -2
 
  return priorities




#score: {'data3D.txt': -0.0016646000000000002}
#standard deviation: 0.0499730850242408
#island_id: 1
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * (h[(i+1)%N][j][k]+h[i][(j+1)%N][k]+h[i][j][(k+1)%N]) for d in range(6))
        priorities[i * N * N + j * N + k][0] = total_spin - interacting_spin_sum
        priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.12030259999999998}
#standard deviation: 0.04320748168130145
#island_id: 2
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins_y = [J[d, i, (j+1)%N, k] for d in [3]]
        interacting_spins_z = [J[d, i, j, (k+1)%N] for d in [4, 5]]
        
        total_spin_x = sum(J[0, i, j, k] for i in range(6))
        total_spin_y = sum(J[d, i, j, k] for d in [3])
        total_spin_z = sum(J[d, i, j, k] for d in range(4, 6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_neighbors if val < 0]) + total_spin_y
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) + total_spin_z
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.47207380000000004}
#standard deviation: 0.04482305247927678
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35510379999999997}
#standard deviation: 0.040161202989452395
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0]) + sum([2 - 2 * val for val in site_neighbors if val > 0])
        
        neighbor_spins = []
        for d in [0, 1]:
          if (i + (d-1) % 2 == j):
            neighbor_spins.append(J[d, i, j, k])
          elif ((i + (k - 1) % 2 - 1) % N == j and d == 0) or ((i + (k - 1) % 2 - 1) % N == j and d == 1):
            neighbor_spins.append(J[d, i, j, k])
          elif (i == (j + 1) % N and d == 0) or (i == (j + 1) % N and d == 1):
            neighbor_spins.append(J[d, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val < 0]) - sum([val for val in neighbor_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in neighbor_spins if val < 0]) + sum([2 - 2 * val for val in neighbor_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34960860000000005}
#standard deviation: 0.04012122887001344
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0]) + sum([2 - 2 * val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.1794094}
#standard deviation: 0.05282425003386229
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          site_priority = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val != spin]) + total_spin
          neighbor_priority = -sum([2 - 2 * val for val in site_neighbors if val != spin])
          
          priorities[i * N * N + j * N + k][0] += site_priority
          priorities[i * N * N + j * N + k][1] += neighbor_priority
          
  return(priorities)




#score: {'data3D.txt': 0.033453000000000004}
#standard deviation: 0.058416780731224825
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          site_priority += -J[d,i,j,k] * interacting_spins[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_priority = 0
          if spin == 1:
            site_priority += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          else:
            site_priority -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          
          site_neighbor_priority = 0
          for neighbor_spin in [-1, 1]:
            if spin == neighbor_spin:
              site_neighbor_priority += -2
            else:
              site_neighbor_priority -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          
          priorities[i * N * N + j * N + k][0] += site_priority
          priorities[i * N * N + j * N + k][1] += site_neighbor_priority
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if spin == h[i][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          
  return priorities




#score: {'data3D.txt': -0.4099538}
#standard deviation: 0.04512679454115925
#island_id: 3
#version_generated: 3
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 3
#version_generated: 3
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23333179999999998}
#standard deviation: 0.05144462215586776
#island_id: 3
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.04888579999999999}
#standard deviation: 0.04740234718196979
#island_id: 3
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) > 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.0134466}
#standard deviation: 0.06308773532502177
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          site_priority += -2 * J[d,i,j,k] * interacting_spins[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': -0.3023989999999997}
#standard deviation: 0.04556839737142397
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = h[i][j][k]
        for d in range(6):
          site_priority += -J[d,i,j,k] * interacting_spins[d,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = site_priority
          priorities[i*N*N + j*N + k][1] = -2 + 2 * site_priority
        else:
          priorities[i*N*N + j*N + k][0] = -site_priority
          priorities[i*N*N + j*N + k][1] = 2 - 2 * site_priority

  return(priorities)




#score: {'data3D.txt': 0.005070600000000001}
#standard deviation: 0.06442579123022084
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-2*np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-2*np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          site_priority += -2*J[d,i,j,k] * interacting_spins[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': 0.033453000000000004}
#standard deviation: 0.058416780731224825
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          site_priority += -J[d,i,j,k] * interacting_spins[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': -0.2534082}
#standard deviation: 0.06027066262088049
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [3, 4, 5]] + [J[d, i, (j+1)%N, k] for d in range(6)] + [J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31101419999999974}
#standard deviation: 0.04539924931493911
#island_id: 1
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = h[i][j][k]
        for d in range(6):
          site_priority += -J[d,i,j,k] * interacting_spins[d,i-1 if i == 0 else i, j-1 if j == 0 else j, k-1 if k == 0 else k]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = site_priority
          priorities[i*N*N + j*N + k][1] = -2 + 2 * site_priority
        else:
          priorities[i*N*N + j*N + k][0] = -site_priority
          priorities[i*N*N + j*N + k][1] = 2 - 2 * site_priority

  return(priorities)




#score: {'data3D.txt': -0.12714420000000032}
#standard deviation: 0.045747163041657574
#island_id: 1
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = h[i][j][k]
        for d in range(6):
          site_priority += -J[d,i,j,k] * interacting_spins[d,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = site_priority
          priorities[i*N*N + j*N + k][1] = -2 + 4 * site_priority
        else:
          priorities[i*N*N + j*N + k][0] = -site_priority
          priorities[i*N*N + j*N + k][1] = 2 - 4 * site_priority

  return(priorities)




#score: {'data3D.txt': -0.368529}
#standard deviation: 0.04489721192902738
#island_id: 1
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin - sum([J[d, i, j, k]*spin for d, spin in enumerate(interacting_spins)])
          priorities[i*N**2 + j*N + k][1] = -2
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin - sum([J[d, i, j, k]*spin for d, spin in enumerate(interacting_spins)])
          priorities[i*N**2 + j*N + k][1] = 2

  return priorities




#score: {'data3D.txt': -0.3337665999999997}
#standard deviation: 0.045140311523515206
#island_id: 1
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = h[i][j][k]
        for d in range(6):
          if J[d,i,j,k] > 0:
            site_priority += -J[d,i,j,k] * interacting_spins[d,i,j,k]
          else:
            site_priority += J[d,i,j,k] * interacting_spins[d,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = site_priority
          priorities[i*N*N + j*N + k][1] = -2 + 2 * site_priority
        else:
          priorities[i*N*N + j*N + k][0] = -site_priority
          priorities[i*N*N + j*N + k][1] = 2 - 2 * site_priority

  return(priorities)




#score: {'data3D.txt': -0.37887260000000017}
#standard deviation: 0.04891552033087249
#island_id: 3
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3427622000000002}
#standard deviation: 0.05135456952560308
#island_id: 3
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          site_neighbors.sort()
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          site_neighbors.sort()
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.47950020000000004}
#standard deviation: 0.04163139872692245
#island_id: 3
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])
          
          priorities[i * N * N + j * N + k][0] += weighted_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * weighted_sum
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])
          
          priorities[i * N * N + j * N + k][0] -= weighted_sum
          priorities[i * N * N + j * N + k][1] += -2 + 2 * weighted_sum
  
  return(priorities)




#score: {'data3D.txt': 0.013571000000000001}
#standard deviation: 0.0450292784641282
#island_id: 2
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[3, i, (j+1)%N, k]]
        interacting_spins_z = [J[4, i, j, (k+1)%N], J[5, i, j, (k+1)%N]]
        
        total_spin_x = sum(J[d, i, j, k] for d in range(6))
        total_spin_y = sum(J[d, i, j, k] for d in [3])
        total_spin_z = sum(J[d, i, j, k] for d in [4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.1108038}
#standard deviation: 0.04788549452141014
#island_id: 2
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins_y = [J[d, i, (j+1)%N, k] for d in [3]]
        interacting_spins_z = [J[d, i, j, (k+1)%N] for d in [4, 5]]
        
        total_spin_x = sum(J[0, i, j, k] for i in range(6))
        total_spin_y = sum(J[d, i, j, k] for d in [3])
        total_spin_z = sum(J[d, i, j, k] for d in range(4, 6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.25380780000000003}
#standard deviation: 0.05331867495690417
#island_id: 2
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0]] + [J[d, i, (j+1)%N, k] for d in [3]] + [J[d, i, j, (k+1)%N] for d in range(4, 6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18397940000000002}
#standard deviation: 0.043806795998337984
#island_id: 2
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+1)%N, j, k], J[4, i, j, (k+1)%N]]
        interacting_spins_y = [J[3, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        interacting_spins_z = [J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 4])
        total_spin_y = sum(J[d, i, j, k] for d in [3, 5])
        total_spin_z = sum(J[d, i, j, k] for d in [1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.1490466000000002}
#standard deviation: 0.04492602039397659
#island_id: 3
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        priorities[i * N * N + j * N + k][0] += site_neighbors[0]
        priorities[i * N * N + j * N + k][1] -= site_neighbors[0]
        
  return(priorities)




#score: {'data3D.txt': -0.3176118}
#standard deviation: 0.04825058072976946
#island_id: 3
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3462214}
#standard deviation: 0.04455409545754464
#island_id: 3
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.18992340000000024}
#standard deviation: 0.04590692858861285
#island_id: 3
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.027531399999999998}
#standard deviation: 0.0556284852754414
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        spin_energy = total_spin + interacting_spin_sum
        priorities[i * N * N + j * N + k][0] = spin_energy if h[i][j][k] > 0 else -spin_energy
        priorities[i * N * N + j * N + k][1] = np.exp(-abs(spin_energy)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]))

  return priorities




#score: {'data3D.txt': -0.2460522}
#standard deviation: 0.04656380520490137
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        spin_energy = total_spin + interacting_spin_sum
        priorities[i * N * N + j * N + k][0] = 2 * h[i][j][k] * np.tanh(spin_energy) if h[i][j][k] > 0 else -2 * h[i][j][k] * np.tanh(-spin_energy)
        priorities[i * N * N + j * N + k][1] = np.exp(-abs(spin_energy))

  return priorities




#score: {'data3D.txt': 0.15246700000000013}
#standard deviation: 0.048201662533568286
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        spin_energy = total_spin + interacting_spin_sum
        priorities[i * N * N + j * N + k][0] = spin_energy if h[i][j][k] > 0 else -spin_energy
        priorities[i * N * N + j * N + k][1] = np.exp(-abs(spin_energy)) * (2 * h[i][j][k] if h[i][j][k] != 0 else 1)
  
  return priorities




#score: {'data3D.txt': -0.33888460000000004}
#standard deviation: 0.05207069351218591
#island_id: 3
#version_generated: 3
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.15966059999999999}
#standard deviation: 0.04785313665414212
#island_id: 3
#version_generated: 3
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.33888460000000004}
#standard deviation: 0.05207069351218591
#island_id: 3
#version_generated: 3
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.27446540000000036}
#standard deviation: 0.04494188072210597
#island_id: 3
#version_generated: 3
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,(i+k-1)%N,(j+i-1)%N,(k+j-1)%N] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          else:
            priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          else:
            priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0])
  return(priorities)




#score: {'data3D.txt': -0.3462214}
#standard deviation: 0.04455409545754464
#island_id: 3
#version_generated: 3
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3462214}
#standard deviation: 0.04455409545754464
#island_id: 3
#version_generated: 3
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3462214}
#standard deviation: 0.04455409545754464
#island_id: 3
#version_generated: 3
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0478126}
#standard deviation: 0.046365974175466215
#island_id: 3
#version_generated: 3
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) + total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0134466}
#standard deviation: 0.06308773532502177
#island_id: 1
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          site_priority += -2 * J[d,i,j,k] * interacting_spins[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': 0.17735140000000002}
#standard deviation: 0.05533102491405703
#island_id: 1
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          if interacting_spins[d,i,j,k] > 0:
            site_priority += -2 * J[d,i,j,k]
          elif interacting_spins[d,i,j,k] < 0:
            site_priority -= 2 * J[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': 0.0134466}
#standard deviation: 0.06308773532502177
#island_id: 1
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_priority = 0
        if h[i][j][k] > 0:
          site_priority += -np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] < 0), axis=0)
        else:
          site_priority -= np.sum(np.exp(-np.abs(J[:,i,j,k])) * (J[:,i,j,k] > 0), axis=0)

        for d in range(6):
          if J[d,i,j,k] < 0:
            site_priority += -2 * J[d,i,j,k] * interacting_spins[d,i,j,k]
          else:
            site_priority -= 2 * J[d,i,j,k] * interacting_spins[d,i,j,k]

        priorities[i*N*N + j*N + k][0] = site_priority
        priorities[i*N*N + j*N + k][1] = -site_priority

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.30745379999999994}
#standard deviation: 0.04506064031458052
#island_id: 0
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 0
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3417977999999997}
#standard deviation: 0.044419639295698914
#island_id: 0
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 1
          for d in [0, 1]:
            neighbor_spin = J[d, i, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins[0])) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins[0])) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          if J[2, i, j, k - 1] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins[0])) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins[0])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][1] += 1
          for d in [0, 1]:
            neighbor_spin = J[d, i, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(interacting_spins[0])) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(interacting_spins[0])) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          if J[2, i, j, k - 1] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(interacting_spins[0])) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(interacting_spins[0])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.43768420000000013}
#standard deviation: 0.043027047195456025
#island_id: 0
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.18170020000000014}
#standard deviation: 0.045575214316117045
#island_id: 0
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * sum([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(sum(interacting_spins))) * sum([val for val in interacting_spins if val > 0]) - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * sum([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.1949354}
#standard deviation: 0.04638428038506149
#island_id: 2
#version_generated: 3
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] = -total_spin - sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add more priority to the site that has more nearest neighbors with different spin than its current spin
        site_neighbors = [J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val != h[i][j][k]])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val != h[i][j][k]])
        
        # Add more priority to the site that has a higher magnetism than its current spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * abs(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.1555318}
#standard deviation: 0.043096575603637007
#island_id: 2
#version_generated: 3
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add more priority to the site that has more nearest neighbors with different spin than its current spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != h[i][j][k]])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val != h[i][j][k]])
        
  return(priorities)




#score: {'data3D.txt': -0.07805380000000002}
#standard deviation: 0.04862001836239885
#island_id: 2
#version_generated: 3
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4505318}
#standard deviation: 0.03965915416092482
#island_id: 2
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.2865706}
#standard deviation: 0.0466399688640548
#island_id: 2
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_sum = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])) + neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * neighbor_spin_sum

  return priorities




#score: {'data3D.txt': -0.2629182}
#standard deviation: 0.054358165428572
#island_id: 2
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [1, 2, 4]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_sum = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [0, 3, 4, 5] if J[val, i, j, k] < 0]) - len([val for val in [0, 3, 4, 5] if J[val, i, j, k] > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [0, 3, 4, 5] if J[val, i, j, k] > 0]) - len([val for val in [0, 3, 4, 5] if J[val, i, j, k] < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.40629220000000005}
#standard deviation: 0.03860954310996182
#island_id: 2
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_sum = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) + 2 * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.0399762}
#standard deviation: 0.04753837727100074
#island_id: 3
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k-1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k-1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.31664060000000016}
#standard deviation: 0.04677710371153819
#island_id: 3
#version_generated: 3
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])
          
          priorities[i * N * N + j * N + k][0] += weighted_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * weighted_sum
          
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])
          
          priorities[i * N * N + j * N + k][0] -= weighted_sum
          priorities[i * N * N + j * N + k][1] += -2 + 2 * weighted_sum
        
  return(priorities)




#score: {'data3D.txt': -0.4088254}
#standard deviation: 0.04269868516523665
#island_id: 3
#version_generated: 3
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
        site_neighbors.sort()
        neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
        weighted_sum = sum([weight * (neighbor < 0) for neighbor, weight in zip(site_neighbors, neighbor_weights)])
        priorities[i * N * N + j * N + k][0] += weighted_sum
        
  return(priorities)




#score: {'data3D.txt': 0.1140382000000001}
#standard deviation: 0.045304271992385015
#island_id: 3
#version_generated: 3
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + len([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0021674}
#standard deviation: 0.05539655961555735
#island_id: 1
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin - sum([J[d, i, j, k]*spin for d, spin in enumerate(interacting_spins)])
          priorities[i*N**2 + j*N + k][1] = -sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin - sum([J[d, i, j, k]*spin for d, spin in enumerate(interacting_spins)])
          priorities[i*N**2 + j*N + k][1] = -sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
  
  return priorities




#score: {'data3D.txt': -0.3773926}
#standard deviation: 0.05279917409619207
#island_id: 2
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbor_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3807122}
#standard deviation: 0.0523546346674294
#island_id: 2
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3807122}
#standard deviation: 0.0523546346674294
#island_id: 2
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3807122}
#standard deviation: 0.0523546346674294
#island_id: 2
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.32327579999999984}
#standard deviation: 0.04425343528315061
#island_id: 0
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.24577100000000035}
#standard deviation: 0.04602350876454338
#island_id: 0
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.24577100000000035}
#standard deviation: 0.04602350876454338
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.23522860000000037}
#standard deviation: 0.046231707972342974
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
  
  return(priorities)




#score: {'data3D.txt': -0.4549878000000001}
#standard deviation: 0.04311560704849232
#island_id: 3
#version_generated: 3
#generate time03:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.3136446000000002}
#standard deviation: 0.045532773810081
#island_id: 3
#version_generated: 3
#generate time03:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.370193}
#standard deviation: 0.04378533990960902
#island_id: 3
#version_generated: 3
#generate time03:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0, i, j, k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0, i, j, k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0, i, j, k:] if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0, i, j, k:] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time03:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 2
#generate time03:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 2
#generate time03:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23522860000000037}
#standard deviation: 0.046231707972342974
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (local_energy + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (local_energy - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
  
  return(priorities)




#score: {'data3D.txt': -0.2550366000000005}
#standard deviation: 0.0462673463734414
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        
        # Add a new term based on the difference between site energy and neighbor spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] + 1)
        
  return priorities




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1560170000000001}
#standard deviation: 0.04785639341822575
#island_id: 0
#version_generated: 3
#generate time03:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.37983180000000005}
#standard deviation: 0.04540113113965334
#island_id: 0
#version_generated: 3
#generate time03:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0489638}
#standard deviation: 0.04492285308793287
#island_id: 0
#version_generated: 3
#generate time03:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + np.sum(site_neighbors) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) - np.sum(site_neighbors) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.21876180000000034}
#standard deviation: 0.04607274010475175
#island_id: 0
#version_generated: 3
#generate time03:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[d, i, (j+1)%N, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, j, (k+1)%N] for d in [0, 1, 2]]
        site_neighbors = np.array(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) + np.sum(np.where(site_neighbors < 0, 1, -1))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - np.sum(np.where(site_neighbors > 0, 1, -1))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.11656860000000009}
#standard deviation: 0.04568552521357285
#island_id: 3
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        site_neighbors_sum = sum(site_neighbors)
        priorities[i * N * N + j * N + k][0] += site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.12750420000000012}
#standard deviation: 0.045792649872659706
#island_id: 3
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        site_nbr_spin = site_neighbors[1] + site_neighbors[2]
        priorities[i * N * N + j * N + k][0] += site_nbr_spin
        priorities[i * N * N + j * N + k][1] -= site_nbr_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3196190000000001}
#standard deviation: 0.047655036239625304
#island_id: 3
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), np.roll(h, 1, axis=0), np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += site_neighbors[0]
        priorities[i * N * N + j * N + k][1] -= site_neighbors[0]
        
  return(priorities)




#score: {'data3D.txt': -0.17317500000000002}
#standard deviation: 0.051400581854683325
#island_id: 3
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        for d in [0, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][d] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors[d]
          else:
            priorities[i * N * N + j * N + k][d] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors[d]
        
        priorities[i * N * N + j * N + k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43255740000000015}
#standard deviation: 0.042686803408547705
#island_id: 0
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43387660000000006}
#standard deviation: 0.04371842920828698
#island_id: 3
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': 0.0535002}
#standard deviation: 0.04809836005478774
#island_id: 3
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin - 2)
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin - 2)
        
  return(priorities)




#score: {'data3D.txt': -0.43387660000000006}
#standard deviation: 0.04371842920828698
#island_id: 3
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time03:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3200246000000001}
#standard deviation: 0.05270815340001963
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.33678260000000027}
#standard deviation: 0.04631936071709108
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - sum([np.exp(-abs(neighbor)) for neighbor in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 - sum([1 if neighbor < 0 else -1 for neighbor in site_neighbors])
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + sum([np.exp(abs(neighbor)) for neighbor in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 + sum([1 if neighbor > 0 else -1 for neighbor in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': -0.28910260000000004}
#standard deviation: 0.04196539042163197
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.1490466000000002}
#standard deviation: 0.04492602039397659
#island_id: 3
#version_generated: 3
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        priorities[i * N * N + j * N + k][0] += site_neighbors[0]
        priorities[i * N * N + j * N + k][1] -= site_neighbors[0]
        
  return(priorities)




#score: {'data3D.txt': 0.15303140000000012}
#standard deviation: 0.04625618244126941
#island_id: 3
#version_generated: 3
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        priorities[i * N * N + j * N + k][0] += site_neighbors[0]
        priorities[i * N * N + j * N + k][1] -= site_neighbors[0]
        
  return(priorities)




#score: {'data3D.txt': -0.1490466000000002}
#standard deviation: 0.04492602039397659
#island_id: 3
#version_generated: 3
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        priorities[i * N * N + j * N + k][0] += site_neighbors[0]
        priorities[i * N * N + j * N + k][1] -= site_neighbors[0]
        
  return(priorities)




#score: {'data3D.txt': -0.3795186}
#standard deviation: 0.04558714439444524
#island_id: 3
#version_generated: 3
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0 or site_neighbors[d] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - sum([1 if val > 0 else 0 for val in [interacting_spins[d], site_neighbors[d]]]))
        else:
          for d in [0, 1, 2]:
            if interacting_spins[d] > 0 or site_neighbors[d] > 0:
              priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (1 - sum([1 if val < 0 else 0 for val in [interacting_spins[d], site_neighbors[d]]]))
        
  return(priorities)




#score: {'data3D.txt': -0.053122199999999994}
#standard deviation: 0.04769207887228235
#island_id: 3
#version_generated: 3
#generate time03:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(h, 1, axis=0), 
             np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0024198000000000006}
#standard deviation: 0.04710348488126967
#island_id: 3
#version_generated: 3
#generate time03:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), np.roll(h, 1, axis=0), np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k-1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
        
  return priorities




#score: {'data3D.txt': 0.09121300000000004}
#standard deviation: 0.046592000504378436
#island_id: 3
#version_generated: 3
#generate time03:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), np.roll(h, 1, axis=0), np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] > 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.012303799999999998}
#standard deviation: 0.04847246956324796
#island_id: 3
#version_generated: 3
#generate time03:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(3):
    interacting_spins = np.roll(h, -1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k-1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins.flatten() if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins.flatten() if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins.flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins.flatten() if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins.flatten() if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.25633420000000023}
#standard deviation: 0.04708857473273105
#island_id: 0
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * neighbor_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] - neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + 2 * neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.34164459999999963}
#standard deviation: 0.04473249435075132
#island_id: 0
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] += neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (neighbor_spin)
            priorities[i * N * N + j * N + k][1] += neighbor_spin
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 2
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 2
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38808700000000007}
#standard deviation: 0.0489260804786159
#island_id: 2
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the sum of all neighboring spins
        for d in range(6):
          if (i + (d-1)%3 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[5-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.35759420000000014}
#standard deviation: 0.0456869916536425
#island_id: 0
#version_generated: 3
#generate time03:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]) + len([val for val in x_neighbors if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]) + len([val for val in x_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': 0.22448740000000036}
#standard deviation: 0.046685144545561816
#island_id: 0
#version_generated: 3
#generate time03:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0) + sum(1 for val in x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3237977999999999}
#standard deviation: 0.04556031118374851
#island_id: 0
#version_generated: 3
#generate time03:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': 0.07335980000000011}
#standard deviation: 0.04658378627763098
#island_id: 0
#version_generated: 3
#generate time03:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - np.sum(np.abs(x_neighbors))
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]) + len([val for val in x_neighbors if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + np.sum(np.abs(x_neighbors))
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]) + len([val for val in x_neighbors if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.2117470000000005}
#standard deviation: 0.04512557180801147
#island_id: 0
#version_generated: 3
#generate time03:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.32327579999999984}
#standard deviation: 0.04425343528315061
#island_id: 0
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3267549999999999}
#standard deviation: 0.046216392059527954
#island_id: 0
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.35501020000000005}
#standard deviation: 0.045376153384349374
#island_id: 0
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        if total_spin > 0 and h[i][j][k] <= 0 or total_spin < 0 and h[i][j][k] >= 0:
          priorities[i * N * N + j * N + k][1] = 3
        elif total_spin == 0:
          priorities[i * N * N + j * N + k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3930262}
#standard deviation: 0.04490696687107692
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # additional term to consider the interactions
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35121420000000003}
#standard deviation: 0.04896013642097007
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a bonus term to encourage the same spin as the neighbors
        if np.sum(h[i-1:i+2, j-1:j+2, k-1:k+2]) > 0:
          priorities[i * N * N + j * N + k][0] += 2
        else:
          priorities[i * N * N + j * N + k][0] -= 2
        
  return(priorities)




#score: {'data3D.txt': 0.1877622000000003}
#standard deviation: 0.04876331624448855
#island_id: 0
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': 0.22448740000000036}
#standard deviation: 0.046685144545561816
#island_id: 0
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0) + sum(1 for val in x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.22448740000000036}
#standard deviation: 0.046685144545561816
#island_id: 0
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0) + sum(1 for val in x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3976166}
#standard deviation: 0.04886215881886514
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.31117259999999997}
#standard deviation: 0.04522227779800572
#island_id: 2
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.38808700000000007}
#standard deviation: 0.0489260804786159
#island_id: 2
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the sum of all neighboring spins
        for d in range(6):
          if (i + (d-1)%3 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[5-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3807122}
#standard deviation: 0.0523546346674294
#island_id: 2
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2547902}
#standard deviation: 0.05725205763952943
#island_id: 2
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([1 if val > 0 else -1 for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2547902}
#standard deviation: 0.05725205763952943
#island_id: 2
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([1 if val > 0 else -1 for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.06948420000000002}
#standard deviation: 0.04501310554005356
#island_id: 2
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([1 if val > 0 else -1 for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.0972286}
#standard deviation: 0.05723401175909304
#island_id: 2
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([1 if val > 0 else -1 for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0186066}
#standard deviation: 0.04804526029110468
#island_id: 2
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([1 if val > 0 else -1 for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5470997999999999}
#standard deviation: 0.0405288499708541
#island_id: 1
#version_generated: 3
#generate time04:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time04:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1490466000000002}
#standard deviation: 0.04492602039397659
#island_id: 3
#version_generated: 3
#generate time04:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the neighbor spin to both options
        priorities[i * N * N + j * N + k][0] += site_neighbors[0]
        priorities[i * N * N + j * N + k][1] -= site_neighbors[0]
        
  return(priorities)




#score: {'data3D.txt': -0.2282966}
#standard deviation: 0.04882040217409111
#island_id: 1
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # additional term to consider the interactions
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) * sum([val for val in site_neighbors if val > 0])
        
        # new terms to consider the interactions with other sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.506799}
#standard deviation: 0.04124140394070017
#island_id: 1
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # additional term to consider the interactions
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) * sum([val for val in site_neighbors if val > 0])
        
        # consider the interactions between the sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) * abs(neighbor_spin)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) * abs(neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4515322}
#standard deviation: 0.04490451562103749
#island_id: 1
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          if interacting_spins[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] -= abs(interacting_spins[d])
          elif interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] += abs(interacting_spins[d])
        
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbors[d])
            priorities[i * N * N + j * N + k][1] -= abs(site_neighbors[d])
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbors[d])
            priorities[i * N * N + j * N + k][1] += abs(site_neighbors[d])
        
  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5420098}
#standard deviation: 0.04514725798938403
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum([val for val in interacting_spins if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.012303799999999998}
#standard deviation: 0.04847246956324796
#island_id: 3
#version_generated: 3
#generate time04:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(3):
    interacting_spins = np.roll(h, -1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k-1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins.flatten() if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins.flatten() if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins.flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins.flatten() if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins.flatten() if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.32327579999999984}
#standard deviation: 0.04425343528315061
#island_id: 0
#version_generated: 3
#generate time04:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32327579999999984}
#standard deviation: 0.04425343528315061
#island_id: 0
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0.5:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < -0.5:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
    
  return(priorities)




#score: {'data3D.txt': 0.31762899999999983}
#standard deviation: 0.04607943314538492
#island_id: 0
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.sum(np.abs(interacting_spins_sum))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.sum(np.abs(interacting_spins_sum))
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 2
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.17365260000000007}
#standard deviation: 0.05256258054205483
#island_id: 0
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
        # Add a new term based on the number of neighboring spins that align with this spin
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.27453580000000016}
#standard deviation: 0.044887534999819255
#island_id: 0
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy and interactions
        for d in range(3):
          priorities[i * N * N + j * N + k][1] -= J[d, i, j, k] * interacting_spins[0]
        
  return(priorities)




#score: {'data3D.txt': -0.08587220000000008}
#standard deviation: 0.047296494026090354
#island_id: 0
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.12817979999999998}
#standard deviation: 0.04522191451011335
#island_id: 0
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

        # Add a new term based on the site interactions
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d, i, j, k])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * np.abs(J[d, i, j, k])

  return(priorities)




#score: {'data3D.txt': -0.2653794000000004}
#standard deviation: 0.04521112889145769
#island_id: 0
#version_generated: 3
#generate time04:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.2884306000000003}
#standard deviation: 0.046322431538510574
#island_id: 0
#version_generated: 3
#generate time04:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(site_neighbors) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(site_neighbors) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.3201394}
#standard deviation: 0.045169932119054575
#island_id: 0
#version_generated: 3
#generate time04:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.3442761999999997}
#standard deviation: 0.04517523562262846
#island_id: 0
#version_generated: 3
#generate time04:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.09741380000000001}
#standard deviation: 0.055116107351299765
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.053122199999999994}
#standard deviation: 0.04769207887228235
#island_id: 3
#version_generated: 3
#generate time04:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(h, 1, axis=0), 
             np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0003633999999999994}
#standard deviation: 0.04765251620260991
#island_id: 3
#version_generated: 3
#generate time04:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xx = np.roll(interacting_spins_x, -1, axis=0)
  interacting_spins_yy = np.roll(interacting_spins_y, -1, axis=1)
  interacting_spins_zz = np.roll(interacting_spins_z, -1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j+1)%N, k], 
          J[1, (i+1)%N, j, k],
          J[2, i, j, (k+1)%N]
        ]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_x[i, j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_x[i, j].flatten() if val > 0])
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_y[j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_y[j].flatten() if val > 0])
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_z[k].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_z[k].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins_x[i, j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_x[i, j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_x[i, j].flatten() if val > 0])
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_y[j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_y[j].flatten() if val > 0])
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_z[k].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_z[k].flatten() if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.053122199999999994}
#standard deviation: 0.04769207887228235
#island_id: 3
#version_generated: 3
#generate time04:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(h, 1, axis=0), 
             np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3483353999999996}
#standard deviation: 0.044737167845539785
#island_id: 0
#version_generated: 3
#generate time04:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin

        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3316961999999998}
#standard deviation: 0.045092730961431016
#island_id: 0
#version_generated: 3
#generate time04:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin

        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.3477725999999996}
#standard deviation: 0.044817961681004624
#island_id: 0
#version_generated: 3
#generate time04:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3483353999999996}
#standard deviation: 0.044737167845539785
#island_id: 0
#version_generated: 3
#generate time04:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.33589259999999954}
#standard deviation: 0.04464128431441011
#island_id: 0
#version_generated: 3
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        else:
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
        
  return priorities




#score: {'data3D.txt': 0.33589259999999954}
#standard deviation: 0.04464128431441011
#island_id: 0
#version_generated: 3
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time04:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time04:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time04:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time04:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3947066000000003}
#standard deviation: 0.04852607913730513
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return(priorities)




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
        site_neighbors.sort()
        
  return(priorities)




#score: {'data3D.txt': -0.3352354000000001}
#standard deviation: 0.046499033826951724
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
  return(priorities)




#score: {'data3D.txt': -0.5420358}
#standard deviation: 0.04009336451783512
#island_id: 2
#version_generated: 2
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4510402}
#standard deviation: 0.04250871374153775
#island_id: 2
#version_generated: 2
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0020478000000000002}
#standard deviation: 0.046946906981823626
#island_id: 2
#version_generated: 2
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -abs(total_spin) - len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = 2 - total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -abs(total_spin) - len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + total_spin + 2 * total_neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.08052300000000003}
#standard deviation: 0.046836828575385
#island_id: 0
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          if sum(J[d, i, j, k] for d in [3, 4, 5]) > 0:
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          if sum(J[d, i, j, k] for d in [3, 4, 5]) > 0:
            priorities[i * N * N + j * N + k][1] = -2
          else:
            priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': 0.3366393999999996}
#standard deviation: 0.044585874978966135
#island_id: 0
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -3
        else:
          if sum(J[d, i, j, k] for d in [0, 1, 2]) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] = -3
  
  return(priorities)




#score: {'data3D.txt': -0.21338980000000032}
#standard deviation: 0.045653057903715495
#island_id: 0
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors) - total_spin
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + sum(x_neighbors) + total_spin
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors) - total_spin
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors) + total_spin
            priorities[i * N * N + j * N + k][1] = -2
  
  return(priorities)




#score: {'data3D.txt': 0.0189146}
#standard deviation: 0.046157467292302766
#island_id: 0
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4510402}
#standard deviation: 0.04250871374153775
#island_id: 2
#version_generated: 3
#generate time04:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]])
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = np.array([J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]])
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4510402}
#standard deviation: 0.04250871374153775
#island_id: 2
#version_generated: 3
#generate time04:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4510402}
#standard deviation: 0.04250871374153775
#island_id: 2
#version_generated: 3
#generate time04:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4510402}
#standard deviation: 0.04250871374153775
#island_id: 2
#version_generated: 3
#generate time04:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.43809699999999996}
#standard deviation: 0.043949498188261486
#island_id: 2
#version_generated: 3
#generate time04:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, i, (j + 1) % N, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4298158}
#standard deviation: 0.04261470110607371
#island_id: 2
#version_generated: 3
#generate time04:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, j, (k + 1) % N], J[1, i, j, (k - 1) % N], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4510402}
#standard deviation: 0.04250871374153775
#island_id: 2
#version_generated: 3
#generate time04:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3193513999999998}
#standard deviation: 0.04658760777331241
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in range(6)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0].flatten() if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])
          
          priorities[i * N * N + j * N + k][0] += weighted_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * weighted_sum
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0].flatten() if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])
          
          priorities[i * N * N + j * N + k][0] -= weighted_sum
          priorities[i * N * N + j * N + k][1] += -2 + 2 * weighted_sum
  
  return(priorities)




#score: {'data3D.txt': -0.47950020000000004}
#standard deviation: 0.04163139872692245
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors.sort()
          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])

          priorities[i * N * N + j * N + k][0] += weighted_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * weighted_sum

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_neighbors.sort()

          neighbor_weights = [np.exp(-abs(val)) if val < 0 else np.exp(abs(val)) for val in site_neighbors]
          weighted_sum = sum([weight * (neighbor < 0) for weight, neighbor in zip(neighbor_weights, site_neighbors)])

          priorities[i * N * N + j * N + k][0] -= weighted_sum
          priorities[i * N * N + j * N + k][1] += -2 + 2 * weighted_sum

  return(priorities)




#score: {'data3D.txt': -0.2774561999999999}
#standard deviation: 0.046887261399659486
#island_id: 3
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.082703}
#standard deviation: 0.04492769291873332
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in interacting_spins])
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N], J[5, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.0664398}
#standard deviation: 0.05106780253701935
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for spin -1
        priority_minus = np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + total_spin
        
        # Calculate the priority for spin 1
        priority_plus = np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in site_neighbors]) - total_spin
        
        priorities[i * N * N + j * N + k] = [priority_minus, priority_plus]
  
  return(priorities)




#score: {'data3D.txt': -0.036840200000000003}
#standard deviation: 0.04705283608838048
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val > 0 else -1 for val in interacting_spins])
        
        for d in [0, 1, 2]:
          site_neighbors[d % 3]
          
          if J[d % 3, i, (j + 1) % N, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d % 3, i, (j + 1) % N, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.22448740000000036}
#standard deviation: 0.046685144545561816
#island_id: 0
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0) + sum(1 for val in x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0393206}
#standard deviation: 0.046437693048212464
#island_id: 0
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0) + sum(1 for val in x_neighbors if val > 0)
        
        spin_priority = -total_spin if h[i][j][k] > 0 else total_spin
        neighbor_priority = -(neighbor_spin if h[i][j][k] > 0 else neighbor_spin)
        
        priorities[i * N * N + j * N + k][0] = spin_priority
        priorities[i * N * N + j * N + k][1] = neighbor_priority
        
  return(priorities)




#score: {'data3D.txt': 0.22448740000000036}
#standard deviation: 0.046685144545561816
#island_id: 0
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0) + sum(1 for val in x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.08931820000000039}
#standard deviation: 0.04832839402214809
#island_id: 0
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in interacting_spins if val > 0) + sum(1 for val in interacting_spins if val < 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0478126}
#standard deviation: 0.046365974175466215
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17317500000000002}
#standard deviation: 0.051400581854683325
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        for d in [0, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][d] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors[d]
          else:
            priorities[i * N * N + j * N + k][d] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors[d]
        
        priorities[i * N * N + j * N + k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.315893}
#standard deviation: 0.05018046822220773
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) - 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -sum(site_neighbors) + 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0478126}
#standard deviation: 0.046365974175466215
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors.append(J[3, i, (j+1)%N, k])
        site_neighbors.append(J[4, (i+1)%N, j, k])
        site_neighbors.append(J[5, i, j, (k+1)%N])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) + total_spin

  return(priorities)




#score: {'data3D.txt': -0.3999426}
#standard deviation: 0.04859252314132289
#island_id: 2
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_x = [(i+1)%N, (i-1)%N]
        site_neighbors_y = [(j+1)%N, (j-1)%N]
        site_neighbors_z = [(k+1)%N, (k-1)%N]
        
        for d in range(3):
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if J[1, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[1, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[2, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4298158}
#standard deviation: 0.04261470110607371
#island_id: 2
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, (i - 1) % N, j, k], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, j, (k + 1) % N], J[1, i, j, (k - 1) % N], J[2, i, j, k]]
        site_neighbors.sort()
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))*1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2511402}
#standard deviation: 0.043057777740612674
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Calculate the energy of the neighboring sites
        neighbors_energy = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (neighbors_energy - total_spin) / 2
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (neighbors_energy - total_spin) / 2
  
  return(priorities)




#score: {'data3D.txt': -0.2867206}
#standard deviation: 0.04584132519506826
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()

        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in [neighbor] if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 1
          
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in [neighbor] if val > 0]))
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3112193999999999}
#standard deviation: 0.0424468277217509
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors.sort()
        
        if site_neighbors[2] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[2] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.28910260000000004}
#standard deviation: 0.04196539042163197
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add more improvements here...
  
  return(priorities)




#score: {'data3D.txt': -0.3352354000000001}
#standard deviation: 0.046499033826951724
#island_id: 1
#version_generated: 3
#generate time04:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
  return(priorities)




#score: {'data3D.txt': -0.09419020000000014}
#standard deviation: 0.04599830370741948
#island_id: 0
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        for d in range(6):
          interacting_spins.append(J[d, i, (j+1)%N, k])
          site_neighbors.append(J[d, (i+1)%N, j, k])
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -2 * np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 4
          else:
            priorities[i * N * N + j * N + k][0] -= 2 * np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.34218539999999964}
#standard deviation: 0.04484007478628909
#island_id: 0
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[0].flatten(), J[1].flatten(), J[2].flatten()]
  site_neighbors = [J[3].flatten(), J[4].flatten(), J[5].flatten()]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.34906739999999964}
#standard deviation: 0.045100866258199514
#island_id: 0
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(np.sum(interacting_spins))) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.34906739999999964}
#standard deviation: 0.045100866258199514
#island_id: 0
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(np.sum(interacting_spins))) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0025109999999999998}
#standard deviation: 0.047493010422587446
#island_id: 1
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[d - 3, (i + 1) % N, j, k])
            
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.356191}
#standard deviation: 0.04195033776979632
#island_id: 3
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1

        site_neighbors.sort()
        if site_neighbors[-1] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_neighbors[-1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3112193999999999}
#standard deviation: 0.0424468277217509
#island_id: 3
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors.sort()
        
        if site_neighbors[2] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[2] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3112193999999999}
#standard deviation: 0.0424468277217509
#island_id: 3
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors.sort()
        
        if site_neighbors[2] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
        elif site_neighbors[2] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3112193999999999}
#standard deviation: 0.0424468277217509
#island_id: 3
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors.sort()
        
        if site_neighbors[2] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        elif site_neighbors[2] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4653842000000002}
#standard deviation: 0.04668675819073328
#island_id: 1
#version_generated: 3
#generate time05:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Improved part: calculate priority based on the number of neighbors with the same spin
        neighbor_spin_count = len([val for val in interacting_spins if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count

  return(priorities)




#score: {'data3D.txt': -0.4358282000000002}
#standard deviation: 0.04679019432274246
#island_id: 1
#version_generated: 3
#generate time05:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2027666000000002}
#standard deviation: 0.043996303076963186
#island_id: 1
#version_generated: 3
#generate time05:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.014034600000000086}
#standard deviation: 0.05121078521991242
#island_id: 3
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - total_spin - len([val for val in interacting_spins if val > 0]) - neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - total_spin - len([val for val in interacting_spins if val < 0]) - neighbor_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -neighbor_spin
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2663774}
#standard deviation: 0.04616792749561108
#island_id: 3
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin - np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.1601314}
#standard deviation: 0.051606590025305876
#island_id: 3
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        
        site_neighbors.sort(reverse=True)
        if site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.10022140000000021}
#standard deviation: 0.04770297665806612
#island_id: 3
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, (j+i-1)%N, (k+j-1)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          site_neighbors.sort()
          for d in [0, 1, 2]:
            if site_neighbors[0] < 0:
              priorities[i * N * N + j * N + k][0] += -len([val for val in interacting_spins if val < 0])
            else:
              priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
        else:
          site_neighbors.sort()
          for d in [0, 1, 2]:
            if site_neighbors[0] < 0:
              priorities[i * N * N + j * N + k][0] -= -len([val for val in interacting_spins if val > 0])
            else:
              priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.011615799999999999}
#standard deviation: 0.05321112994816028
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, 1, axis=0).copy()
  interacting_spins_y = np.roll(h, 1, axis=1).copy()
  interacting_spins_z = np.roll(h, 1, axis=2).copy()
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = sum(J[0, i, j, k] for _ in range(N))
        total_spin_y = sum(J[1, i, j, k] for _ in range(N))
        total_spin_z = sum(J[2, i, j, k] for _ in range(N))
        
        site_neighbors_x = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N]]
        site_neighbors_y = [J[1, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[1, i, j, (k+1)%N]]
        site_neighbors_z = [J[2, i, (j+1)%N, k], J[2, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        neighbor_spin_x = sum(val for val in site_neighbors_x)
        neighbor_spin_y = sum(val for val in site_neighbors_y)
        neighbor_spin_z = sum(val for val in site_neighbors_z)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
          
          if neighbor_spin_x < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_x.flatten() if val < 0])
          elif neighbor_spin_x > 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_x.flatten() if val > 0])
          
          if neighbor_spin_y < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_y.flatten() if val < 0])
          elif neighbor_spin_y > 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_y.flatten() if val > 0])
          
          if neighbor_spin_z < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_z.flatten() if val < 0])
          elif neighbor_spin_z > 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_z.flatten() if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x + total_spin_y + total_spin_z)) * (len([val for val in interacting_spins_x.flatten() if val < 0]) - len([val for val in interacting_spins_x.flatten() if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y + total_spin_z)
          
          if neighbor_spin_x < 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_x.flatten() if val > 0])
          elif neighbor_spin_x > 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_x.flatten() if val < 0])
          
          if neighbor_spin_y < 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_y.flatten() if val > 0])
          elif neighbor_spin_y > 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_y.flatten() if val < 0])
          
          if neighbor_spin_z < 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins_z.flatten() if val > 0])
          elif neighbor_spin_z > 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins_z.flatten() if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.09121300000000004}
#standard deviation: 0.046592000504378436
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(h, 1, axis=0), 
             np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] > 0:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.022684199999999995}
#standard deviation: 0.05036705580396774
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(h, 1, axis=0), 
             np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        if site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.1723698}
#standard deviation: 0.04097747878969618
#island_id: 2
#version_generated: 2
#generate time05:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time05:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.464169}
#standard deviation: 0.040848203375424
#island_id: 2
#version_generated: 2
#generate time05:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
  return(priorities)




#score: {'data3D.txt': -0.23877300000000032}
#standard deviation: 0.04484144189251723
#island_id: 1
#version_generated: 3
#generate time05:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.23877300000000032}
#standard deviation: 0.04484144189251723
#island_id: 1
#version_generated: 3
#generate time05:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.23877300000000032}
#standard deviation: 0.04484144189251723
#island_id: 1
#version_generated: 3
#generate time05:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])

        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if site_spin > 0 else -1) * abs(site_spin)
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if site_spin > 0 else -1)

  return(priorities)




#score: {'data3D.txt': -0.23877300000000032}
#standard deviation: 0.04484144189251723
#island_id: 1
#version_generated: 3
#generate time05:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.12248300000000029}
#standard deviation: 0.04634872804079958
#island_id: 0
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
        # Add a new term based on the site magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += np.abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] += np.abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= np.abs(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.2332018000000004}
#standard deviation: 0.04480543668752711
#island_id: 0
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs([J[d, i, j, k] for d in [0, 1, 2]])) - np.sum(np.abs(site_neighbors)) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs([J[d, i, j, k] for d in [0, 1, 2]])) + np.sum(np.abs(site_neighbors)) - total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1894074000000005}
#standard deviation: 0.045239976848358364
#island_id: 0
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
        # Add a new term based on the spin of the site itself
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07998220000000011}
#standard deviation: 0.04652844423747694
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin - np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2883330000000002}
#standard deviation: 0.044192248539760906
#island_id: 2
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, (i+1)%N, (j+1)%N, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[1, (i+1)%N, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, (i+1)%N, (j+1)%N, k]]

        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)
        total_spin_z = sum(val for val in interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6,N,N,N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if h[i][j][k] * J[d, i, j, k] > 0:
            total_spin += J[d, i, j, k]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          if d < 3:
            interacting_spins[d][i, (j + 1) % N, k] += -J[d, i, (j + 1) % N, k]
          else:
            interacting_spins[d-3][(i + 1) % N, j, k] += -J[d - 3, (i + 1) % N, j, k]
        
        for d in range(6):
          if h[i][j][k] * J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += -total_spin
            priorities[i * N * N + j * N + k][1] -= total_spin
        
        for d in range(6):
          if h[i][j][k] * J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += -interacting_spins[d][i, j, k]
            priorities[i * N * N + j * N + k][1] -= interacting_spins[d][i, j, k]

  return(priorities)




#score: {'data3D.txt': 0.009786599999999918}
#standard deviation: 0.04390039111944221
#island_id: 1
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.5109714000000001}
#standard deviation: 0.04240147759265
#island_id: 1
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(J[d, i, (j + 1) % N, k] for d in [0, 1, 2]) if site_neighbors else 0
        neighbor_spin_count = len([val for val in interacting_spins if val == h[i][j][k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Improved part: calculate priority based on the number of neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_count - len([val for val in site_neighbors if val == h[i][j][k]]))
        
  return(priorities)




#score: {'data3D.txt': -0.418765}
#standard deviation: 0.039902359015476764
#island_id: 1
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Improved part: calculate priority based on the number of neighbors with the same spin
        neighbor_spin_count = len([val for val in interacting_spins if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count
        
        # Improved part: calculate priority based on the number of neighbors with different spin
        opposite_spin_count = len([val for val in interacting_spins if val != h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * opposite_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.48827980000000004}
#standard deviation: 0.041150100752732066
#island_id: 2
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
        # Add another new term based on the difference between the number of neighbors with the same spin and those with the opposite spin in the z direction
        z_neighbor = J[2, i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (z_neighbor - (-z_neighbor))
        priorities[i * N * N + j * N + k][1] -= z_neighbor - (-z_neighbor)
        
  return(priorities)




#score: {'data3D.txt': -0.4527518}
#standard deviation: 0.0406959776484114
#island_id: 2
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
  return(priorities)




#score: {'data3D.txt': -0.0004706000000000005}
#standard deviation: 0.045289275724391974
#island_id: 2
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4262234}
#standard deviation: 0.04160587617680945
#island_id: 2
#version_generated: 3
#generate time05:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin in all directions
        for d in [0, 1, 2]:
          for x in [(i-1)%N, i, (i+1)%N]:
            for y in [(j-1)%N, j, (j+1)%N]:
              for z in [(k-1)%N, k, (k+1)%N]:
                if J[d, x, y, z] > 0:
                  priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, x, y, z]] if val < 0])
                  priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, x, y, z]] if val > 0]) - len([val for val in [J[d, x, y, z]] if val < 0])
                else:
                  priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, x, y, z]] if val > 0])
                  priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0041326}
#standard deviation: 0.0492423051576589
#island_id: 2
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0006657999999999994}
#standard deviation: 0.04591090186829268
#island_id: 2
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1198438}
#standard deviation: 0.04518689236448995
#island_id: 2
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * h[i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
  
  return(priorities)




#score: {'data3D.txt': -0.23148580000000032}
#standard deviation: 0.04449091455971657
#island_id: 1
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, i%N, j%N, k])
          interacting_spins.append(J[(d+3)%3, (i+j+k)%3, j%N, k])
          
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[(d-3)%3, i%N, (j+1)%N, (k+1)%N])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_nbr_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i%N, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        site_nbr_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return priorities




#score: {'data3D.txt': -0.23877300000000032}
#standard deviation: 0.04484144189251723
#island_id: 1
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.2781402000000003}
#standard deviation: 0.04396950925311764
#island_id: 1
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
        # Add the site's own spin to the priority, considering the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return priorities




#score: {'data3D.txt': -0.23877300000000032}
#standard deviation: 0.04484144189251723
#island_id: 1
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j%N, k] for d in [0,1,2]]
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[d-3, (i+1)%N, j, (k+1)%N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.1023022}
#standard deviation: 0.044979529512434877
#island_id: 0
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = np.sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.13597499999999998}
#standard deviation: 0.047105686864751264
#island_id: 0
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        same_spin_neighbors = [J[d, i, (j+d)%N, k] for d in [-1, 0, 1]]
        priorities[i * N * N + j * N + k][0] += np.sum(same_spin_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in same_spin_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0007165999999999993}
#standard deviation: 0.045203570262093234
#island_id: 0
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors) - len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0009465999999999998}
#standard deviation: 0.04803959105196463
#island_id: 0
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) + 2
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])

        site_neighbors_sum = np.sum(site_neighbors)
        site_neighbors_pos = [val for val in site_neighbors if val > 0]
        site_neighbors_neg = [val for val in site_neighbors if val < 0]

        priorities[i * N * N + j * N + k][0] += site_neighbors_sum - len(site_neighbors_pos) + len(site_neighbors_neg)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_pos)

  return(priorities)




#score: {'data3D.txt': -0.14832660000000011}
#standard deviation: 0.04796924194147746
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        total_spin = sum(J[d, (i+j+k)%3, j%N, k] for d in [0, 1, 2])
        
        site_neighbors.sort()
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
  
  return priorities




#score: {'data3D.txt': -0.1511354000000002}
#standard deviation: 0.04512359678527411
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return priorities




#score: {'data3D.txt': -0.09128020000000017}
#standard deviation: 0.04527852214858608
#island_id: 1
#version_generated: 3
#generate time05:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i%N, j%N, k] for d in [0,1,2]]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+j+k)%3, (j+1)%N, k])
          else:
            interacting_spins.append(J[(d-3)%3, i%N, (j+1)%N, (k+1)%N])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
        
  return priorities




#score: {'data3D.txt': -0.1516854000000002}
#standard deviation: 0.04508515350800083
#island_id: 1
#version_generated: 3
#generate time05:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return priorities




#score: {'data3D.txt': -0.1511354000000002}
#standard deviation: 0.04512359678527411
#island_id: 1
#version_generated: 3
#generate time05:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return priorities




#score: {'data3D.txt': -0.1511354000000002}
#standard deviation: 0.04512359678527411
#island_id: 1
#version_generated: 3
#generate time05:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return priorities




#score: {'data3D.txt': 0.1198438}
#standard deviation: 0.04518689236448995
#island_id: 2
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * h[i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
  return(priorities)




#score: {'data3D.txt': 0.1379062}
#standard deviation: 0.044926656247265946
#island_id: 2
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * h[i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1379062}
#standard deviation: 0.044926656247265946
#island_id: 2
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] * h[i][j][k] for d in range(6)] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] * h[i][j][k] for d in range(6)] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1523566}
#standard deviation: 0.044411708326070956
#island_id: 2
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * h[i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = []
        for x in [(i-1)%N, i, (i+1)%N]:
          for y in [(j-1)%N, j, (j+1)%N]:
            for z in [(k-1)%N, k, (k+1)%N]:
              site_neighbors.append(J[0, x, y, z] * h[x][y][z])
        site_neighbors = np.array(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_avg = np.mean(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time05:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time05:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time05:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15436140000000023}
#standard deviation: 0.04504592756332142
#island_id: 1
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) - (h[i][j][k])**2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + (h[i][j][k])**2
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) - (h[i][j][k])**2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors) + (h[i][j][k])**2
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
  
  return priorities




#score: {'data3D.txt': -0.15111500000000025}
#standard deviation: 0.04533140120269834
#island_id: 1
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2-1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
  
  return priorities




#score: {'data3D.txt': -0.15436140000000023}
#standard deviation: 0.04504592756332142
#island_id: 1
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + (h[i][j][k])**2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + (h[i][j][k])**2

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) + (h[i][j][k])**2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors) + (h[i][j][k])**2

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return priorities




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -abs(sum(interacting_spins)) - sum([abs(val) for val in interacting_spins]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = -abs(sum(interacting_spins)) - sum([abs(val) for val in interacting_spins]) + abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = 2
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -abs(sum(site_neighbors)) - sum([abs(val) for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= abs(sum(site_neighbors)) - sum([abs(val) for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': 0.3371057999999996}
#standard deviation: 0.04486136741518251
#island_id: 0
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.2654734000000004}
#standard deviation: 0.04630066362850537
#island_id: 0
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.0427358}
#standard deviation: 0.045498560838338614
#island_id: 0
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - sum([np.abs(val) for val in site_neighbors + x_neighbors])
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + sum([np.abs(val) for val in site_neighbors + x_neighbors])
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.3732822000000001}
#standard deviation: 0.051176185898912
#island_id: 1
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1965994000000001}
#standard deviation: 0.04579731389110065
#island_id: 1
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + d % N) % N, (k + d % N) % N])
          else:
            interacting_spins.append(J[d - 3, ((i + d % N) % N), j, k])
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3352354000000001}
#standard deviation: 0.046499033826951724
#island_id: 1
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])
        
  return(priorities)




#score: {'data3D.txt': 0.29920380000000013}
#standard deviation: 0.045962927077809114
#island_id: 1
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([abs(val) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time05:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0063086}
#standard deviation: 0.047067256623262
#island_id: 0
#version_generated: 3
#generate time05:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
      return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.43197259999999993}
#standard deviation: 0.041765729602629954
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.12355260000000015}
#standard deviation: 0.04770622384175885
#island_id: 0
#version_generated: 3
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.30350380000000016}
#standard deviation: 0.04576717410502857
#island_id: 0
#version_generated: 3
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.2952310000000001}
#standard deviation: 0.04761083531088274
#island_id: 0
#version_generated: 3
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        if i < N//2:
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3267549999999999}
#standard deviation: 0.046216392059527954
#island_id: 0
#version_generated: 3
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.00043780000000000007}
#standard deviation: 0.05002873065709343
#island_id: 2
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.sum([J[d, i, j, k] * interacting_spins[d][i][j] for d in range(6)])
  
  return(priorities)




#score: {'data3D.txt': 0.0141142}
#standard deviation: 0.04704588269296262
#island_id: 2
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        site_neighbors_total_spin = np.sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite) + 4 * site_neighbors_total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0004706000000000005}
#standard deviation: 0.045289275724391974
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    priorities[ijk][0] += -np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)]) + 2 * len([val for val in site_nbrs_same if val[0] == i and val[1] == j and val[2] == k]) - 2 * len([val for val in site_nbrs_opposite if val[0] == i and val[1] == j and val[2] == k])
    priorities[ijk][1] -= 2 - 2 * np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.21523980000000004}
#standard deviation: 0.04348318267974413
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.17687819999999999}
#standard deviation: 0.041012266515763306
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins) + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + h[i][j][k]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0572506}
#standard deviation: 0.04432141287955518
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins) - 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + 3
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) - 3
        
  return(priorities)




#score: {'data3D.txt': -0.21523980000000004}
#standard deviation: 0.04348318267974413
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d) % N, j, k] for d in [-1, 0, 1]]
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.05560299999999999}
#standard deviation: 0.04650117709262853
#island_id: 0
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] += np.sum([J[l, i, j, k] for l in range(6)])
  
  return(priorities)




#score: {'data3D.txt': -0.0079434}
#standard deviation: 0.048014059153960315
#island_id: 2
#version_generated: 3
#generate time06:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4714334000000001}
#standard deviation: 0.04390498701104466
#island_id: 1
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin_count = len([val for val in site_neighbors + interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          neighbor_spin_count = len([val for val in site_neighbors + interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * neighbor_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.21013260000000036}
#standard deviation: 0.0478974836211674
#island_id: 1
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 4 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]))

  return(priorities)




#score: {'data3D.txt': -0.4360822000000002}
#standard deviation: 0.045273853858049246
#island_id: 1
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_count = len([val for val in interacting_spins if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count
        site_neighbors_count = len([val for val in site_neighbors if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) * site_neighbors_count
        
  return(priorities)




#score: {'data3D.txt': -0.2162866}
#standard deviation: 0.048739013330595854
#island_id: 1
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          else:
            interacting_spins.append(J[d - 3, (i + 1) % N, j, k])

        neighbor_spin_count = len([val for val in interacting_spins if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.404231}
#standard deviation: 0.044398389599173534
#island_id: 1
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin_count = len([val for val in site_neighbors + interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          neighbor_spin_count = len([val for val in site_neighbors + interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * neighbor_spin_count
        
        for d in [3, 4, 5]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.24164660000000024}
#standard deviation: 0.049850878712817105
#island_id: 1
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in range(6)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(np.sum(J[d, i, j, :])))*len([val for val in interacting_spins[d][i, j, :] if val < 0]) + np.sum(J[d, i, j, :]) for d in range(6)])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(np.sum(J[d, i, j, :])))*len([val for val in interacting_spins[d][i, j, :] if val > 0]) + np.sum(J[d, i, j, :]) for d in range(6)])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in range(6)])
  
  return(priorities)




#score: {'data3D.txt': -0.4714334000000001}
#standard deviation: 0.04390498701104466
#island_id: 1
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin_count = len([val for val in site_neighbors + interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          neighbor_spin_count = len([val for val in site_neighbors + interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * neighbor_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6,N,N,N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+j+k)%N, j%N, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        for d in range(6):
          if h[i][j][k] * J[d, i, j, k] > 0:
            priorities[i*N*N + j*N + k][0] += -total_spin
            priorities[i*N*N + j*N + k][1] -= total_spin
            
          else:
            priorities[i*N*N + j*N + k][0] += -interacting_spins[d%(3+3)][i, (j+d%3)%N, (k+d%3)%N]
            priorities[i*N*N + j*N + k][1] -= interacting_spins[d%(3+3)][i, (j+d%3)%N, (k+d%3)%N]

  return(priorities)




#score: {'data3D.txt': -0.09008780000000004}
#standard deviation: 0.04715764806645897
#island_id: 1
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+j+k)%N, j%N, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        interacting_spins_neighbors = sum(J[d, (i+j+k-1)%3, j%N, k] for d in [0, 1, 2]) + sum(J[d, i, (j+1)%N, k] for d in range(3)) + sum(J[d, (i+1)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - interacting_spins_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors) - interacting_spins_neighbors
          priorities[i * N * N + j * N + k][1] = 2 - np.exp(-abs(total_spin))
  
  return priorities




#score: {'data3D.txt': -0.3076105999999999}
#standard deviation: 0.04670921116482271
#island_id: 0
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.30648179999999997}
#standard deviation: 0.04643664747545841
#island_id: 0
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.0004706000000000005}
#standard deviation: 0.045289275724391974
#island_id: 2
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
    
    spin_1_same_nbrs = sum(1 for val in site_nbrs_same if val[0] == i and val[1] == j and val[2] == k)
    spin_opposite_nbrs = sum(1 for val in site_nbrs_opposite if val[0] == i and val[1] == j and val[2] == k)
    
    priorities[ijk][0] += -total_spin + 2 * spin_1_same_nbrs - 2 * spin_opposite_nbrs
    priorities[ijk][1] -= 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0004706000000000005}
#standard deviation: 0.045289275724391974
#island_id: 2
#version_generated: 3
#generate time06:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    neighbors_same = sum([1 if val[0] == i and val[1] == j and val[2] == k else 0 for val in site_nbrs_same])
    neighbors_opposite = sum([1 if val[0] == i and val[1] == j and val[2] == k else 0 for val in site_nbrs_opposite])

    priorities[ijk][0] += -np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)]) + 2 * neighbors_same - 2 * neighbors_opposite
    priorities[ijk][1] -= 2 - 2 * np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.0022957999999999998}
#standard deviation: 0.04753655585294332
#island_id: 2
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    priorities[ijk][0] += -total_spin + 2 * len([val for val in site_nbrs_same if val[0] == i and val[1] == j and val[2] == k]) - 2 * len([val for val in site_nbrs_opposite if val[0] == i and val[1] == j and val[2] == k])
    priorities[ijk][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0004706000000000005}
#standard deviation: 0.045289275724391974
#island_id: 2
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    priorities[ijk][0] += -np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)]) + 2 * len([val for val in site_nbrs_same if val[0] == i and val[1] == j and val[2] == k]) - 2 * len([val for val in site_nbrs_opposite if val[0] == i and val[1] == j and val[2] == k])
    priorities[ijk][1] -= 2 - 2 * np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': 0.022684199999999995}
#standard deviation: 0.05036705580396774
#island_id: 3
#version_generated: 3
#generate time06:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  interacting_spins = [np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(h, 1, axis=0), 
             np.roll(h, 1, axis=1)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        if site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins[0][i,j].flatten() if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins[0][i,j].flatten() if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0022957999999999998}
#standard deviation: 0.04753655585294332
#island_id: 2
#version_generated: 3
#generate time06:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    priorities[ijk][0] += -total_spin + 2 * len([val for val in site_nbrs_same if val[0] == i and val[1] == j and val[2] == k]) - 2 * len([val for val in site_nbrs_opposite if val[0] == i and val[1] == j and val[2] == k])
    priorities[ijk][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022957999999999998}
#standard deviation: 0.04753655585294332
#island_id: 2
#version_generated: 3
#generate time06:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  site_nbrs_same = []
  site_nbrs_opposite = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        site_nbrs_same.append((i, j, k, site_nbr_same))
        site_nbrs_opposite.append((i, j, k, site_nbr_opposite))

  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    priorities[ijk][0] += -total_spin + 2 * len([val for val in site_nbrs_same if val[0] == i and val[1] == j and val[2] == k]) - 2 * len([val for val in site_nbrs_opposite if val[0] == i and val[1] == j and val[2] == k])
    priorities[ijk][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.15111500000000025}
#standard deviation: 0.04533140120269834
#island_id: 1
#version_generated: 3
#generate time06:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2-1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
  
  return priorities




#score: {'data3D.txt': -0.15111500000000025}
#standard deviation: 0.04533140120269834
#island_id: 1
#version_generated: 3
#generate time06:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]
        
        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2-1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
        
        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)
  
  return priorities




#score: {'data3D.txt': -0.15111500000000025}
#standard deviation: 0.04533140120269834
#island_id: 1
#version_generated: 3
#generate time06:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%N, j%N, k] for d in range(6)]

        site_neighbors = [J[0, i%N, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]

        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k-1)%2-1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors) - abs(h[site_nbr][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

        # Add the site's own spin to the priority
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i][j][k] > 0 else -1) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (1 if h[i][j][k] > 0 else -1)

  return priorities




#score: {'data3D.txt': -0.17687819999999999}
#standard deviation: 0.041012266515763306
#island_id: 2
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins) + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + h[i][j][k]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.06464539999999999}
#standard deviation: 0.04701773345068858
#island_id: 2
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -np.sum(site_neighbors) + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = np.sum(site_neighbors) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.07218019999999999}
#standard deviation: 0.04576133879116739
#island_id: 2
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) + h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) + h[i][j][k])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(site_neighbors) + h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.17687819999999999}
#standard deviation: 0.041012266515763306
#island_id: 2
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(interacting_spins)
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + h[i][j][k]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) + h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0991026}
#standard deviation: 0.045752206430291424
#island_id: 1
#version_generated: 2
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 3 * (sum([1 if val > 0 else -1 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 2
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5420358}
#standard deviation: 0.04009336451783512
#island_id: 1
#version_generated: 2
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0025346}
#standard deviation: 0.04696443849169284
#island_id: 3
#version_generated: 2
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 2
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 3
#version_generated: 2
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.12817979999999998}
#standard deviation: 0.04522191451011335
#island_id: 0
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

        # Add a new term based on the site interactions
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d, i, j, k])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * np.abs(J[d, i, j, k])

  return(priorities)




#score: {'data3D.txt': -0.1773510000000005}
#standard deviation: 0.04574976326714708
#island_id: 0
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.1510162}
#standard deviation: 0.04558199751612472
#island_id: 0
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

        # Add a new term based on the site interactions
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d, i, j, k])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * np.abs(J[d, i, j, k])

        # Add a new term based on the spin interactions
        for d1 in range(6):
          for d2 in range(d1+1, 6):
            if J[d1, i, j, k] < 0 and J[d2, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * np.abs(J[d1, i, j, k]) * np.abs(J[d2, i, j, k])
            elif J[d1, i, j, k] > 0 and J[d2, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d1, i, j, k]) * np.abs(J[d2, i, j, k])

  return(priorities)




#score: {'data3D.txt': 0.18090340000000002}
#standard deviation: 0.04728928323034723
#island_id: 0
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins[0][i][j][k])) - np.sum(np.abs(interacting_spins[1][i][j][k]))
          priorities[i * N * N + j * N + k][1] = 2
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += h[i][j][k] + len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0])
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += h[i][j][k] - len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0])
        
        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
        # Add a new term based on the site interactions
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d, i, j, k])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * np.abs(J[d, i, j, k])
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44435739999999996}
#standard deviation: 0.04123392468878023
#island_id: 3
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.1871170000000002}
#standard deviation: 0.04764684702055322
#island_id: 0
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
        # Add the interactions between neighboring sites
        if i > 0: 
          priorities[i * N * N + j * N + k][0] -= J[3, i-1, j, k]
          priorities[i * N * N + j * N + k][1] += J[3, i-1, j, k]
        if i < N - 1: 
          priorities[i * N * N + j * N + k][0] -= J[4, i+1, j, k]
          priorities[i * N * N + j * N + k][1] += J[4, i+1, j, k]
        if j > 0: 
          priorities[i * N * N + j * N + k][0] -= J[5, i, j-1, k]
          priorities[i * N * N + j * N + k][1] += J[5, i, j-1, k]
        if j < N - 1: 
          priorities[i * N * N + j * N + k][0] -= J[3, i, (j+1)%N, k]
          priorities[i * N * N + j * N + k][1] += J[3, i, (j+1)%N, k]
        if k > 0: 
          priorities[i * N * N + j * N + k][0] -= J[4, i, j, k-1]
          priorities[i * N * N + j * N + k][1] += J[4, i, j, k-1]
        if k < N - 1: 
          priorities[i * N * N + j * N + k][0] -= J[5, i, j, (k+1)%N]
          priorities[i * N * N + j * N + k][1] += J[5, i, j, (k+1)%N]
        
  return(priorities)




#score: {'data3D.txt': 0.24493140000000035}
#standard deviation: 0.04692453147384636
#island_id: 0
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1877622000000003}
#standard deviation: 0.04876331624448855
#island_id: 0
#version_generated: 3
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.18989460000000025}
#standard deviation: 0.04741222512011012
#island_id: 0
#version_generated: 3
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - neighbor_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [3, 4, 5]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time06:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time06:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2117470000000005}
#standard deviation: 0.04512557180801147
#island_id: 0
#version_generated: 3
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2117470000000005}
#standard deviation: 0.04512557180801147
#island_id: 0
#version_generated: 3
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2117470000000005}
#standard deviation: 0.04512557180801147
#island_id: 0
#version_generated: 3
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2117470000000005}
#standard deviation: 0.04512557180801147
#island_id: 0
#version_generated: 3
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4262234}
#standard deviation: 0.04160587617680945
#island_id: 2
#version_generated: 3
#generate time06:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin in all directions
        for d in [0, 1, 2]:
          for x in [(i-1)%N, i, (i+1)%N]:
            for y in [(j-1)%N, j, (j+1)%N]:
              for z in [(k-1)%N, k, (k+1)%N]:
                if J[d, x, y, z] > 0:
                  priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, x, y, z]] if val < 0])
                  priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, x, y, z]] if val > 0]) - len([val for val in [J[d, x, y, z]] if val < 0])
                else:
                  priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, x, y, z]] if val > 0])
                  priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3442761999999997}
#standard deviation: 0.04517523562262846
#island_id: 0
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = -2

  return priorities




#score: {'data3D.txt': -0.3442761999999997}
#standard deviation: 0.04517523562262846
#island_id: 0
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.3442761999999997}
#standard deviation: 0.04517523562262846
#island_id: 0
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.3442761999999997}
#standard deviation: 0.04517523562262846
#island_id: 0
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(np.abs(J[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(J[3:, i, j, k])
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.44435739999999996}
#standard deviation: 0.04123392468878023
#island_id: 3
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(val for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.06464539999999999}
#standard deviation: 0.04701773345068858
#island_id: 2
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -np.sum(site_neighbors) + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = np.sum(site_neighbors) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0112526}
#standard deviation: 0.04784902499779906
#island_id: 2
#version_generated: 3
#generate time06:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -np.sum(interacting_spins) - np.sum(site_neighbors) + 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - np.sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = np.sum(interacting_spins) + np.sum(site_neighbors) - 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.06464539999999999}
#standard deviation: 0.04701773345068858
#island_id: 2
#version_generated: 3
#generate time06:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -np.sum(site_neighbors) + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = np.sum(site_neighbors) + h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val > 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0024114}
#standard deviation: 0.04670429348614536
#island_id: 2
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_nbrs_same = [val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if np.sign(val) == np.sign(h[i][j][k])]
        site_nbrs_opposite = [val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if np.sign(val) != np.sign(h[i][j][k])]
        
        priorities[i * N * N + j * N + k][0] += -total_spin + len(site_nbrs_same) - len(site_nbrs_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0006657999999999994}
#standard deviation: 0.04591090186829268
#island_id: 2
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * site_nbr_same - 2 * site_nbr_opposite
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5286317999999999}
#standard deviation: 0.041519094267095956
#island_id: 1
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3600426}
#standard deviation: 0.04969967630920749
#island_id: 1
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return(priorities)




#score: {'data3D.txt': 0.1057338}
#standard deviation: 0.04733900186484714
#island_id: 0
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

        # Add a new term based on the site interactions
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d, i, j, k])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * np.abs(J[d, i, j, k])

        # Add a new term based on the site energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= (1 - abs(h[i][j][k])) * np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += (1 - abs(h[i][j][k])) * np.exp(abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.156111}
#standard deviation: 0.04475400628994012
#island_id: 3
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0028346}
#standard deviation: 0.04688176663522824
#island_id: 3
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.039743799999999996}
#standard deviation: 0.046560000875859105
#island_id: 3
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_spin = h[i][j][k]
        
        if site_spin < 0:
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) * (-1)
            priorities[i * N * N + j * N + k][1] -= (neighbor_spin < 0) * (-1)
        elif site_spin > 0:
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin > 0) * (1)
            priorities[i * N * N + j * N + k][1] += (neighbor_spin > 0) * (1)
        else:
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) * (-1)
            priorities[i * N * N + j * N + k][1] -= (neighbor_spin < 0) * (-1)
  
  return(priorities)




#score: {'data3D.txt': -0.0006657999999999994}
#standard deviation: 0.04591090186829268
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = np.sum([np.sign(val) == np.sign(h[i][j][k]) for val in site_neighbors])
        site_nbr_opposite = len(site_neighbors) - site_nbr_same
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0319914}
#standard deviation: 0.045794758281270574
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * h[i][j][k] for d in range(6)]
        total_spin = np.sum(interacting_spins)
        
        site_neighbors = [(i + 1) % N if J[0, i, j, k] < 0 else (i - 1) % N,
                  (j + 1) % N if J[1, i, j, k] < 0 else (j - 1) % N,
                  (k + 1) % N if J[2, i, j, k] < 0 else (k - 1) % N]
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if J[d, i, j, k] < 0]) + sum(J[d, s, t, k] for s, t in zip(site_neighbors, site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0006657999999999994}
#standard deviation: 0.04591090186829268
#island_id: 2
#version_generated: 3
#generate time07:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0141142}
#standard deviation: 0.04704588269296262
#island_id: 2
#version_generated: 3
#generate time07:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        site_neighbors_total_spin = np.sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite) + 4 * site_neighbors_total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0141142}
#standard deviation: 0.04704588269296262
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        site_neighbors_total_spin = np.sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (site_nbr_same - site_nbr_opposite) + 4 * site_neighbors_total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3439301999999997}
#standard deviation: 0.04524234176034656
#island_id: 0
#version_generated: 3
#generate time07:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with different spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.14236900000000033}
#standard deviation: 0.04794556871077869
#island_id: 0
#version_generated: 3
#generate time07:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with different spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3321469999999997}
#standard deviation: 0.045310962371152515
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= h[i][j][k] - neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= h[i][j][k] + neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.22377260000000057}
#standard deviation: 0.04596476138565281
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        local_energy = h[i][j][k] * (total_spin + neighbor_spin)
        magnetism_term = np.exp(-abs(total_spin)) * h[i][j][k]

        priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + local_energy
        priorities[i * N * N + j * N + k][1] = 2 if h[i][j][k] > 0 else -2

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += magnetism_term
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] -= magnetism_term

  return(priorities)




#score: {'data3D.txt': -0.04380980000000001}
#standard deviation: 0.04826315638206852
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (h[i][j][k] - neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4026858}
#standard deviation: 0.04469706610461139
#island_id: 3
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = site_neighbors[d]
          else:
            neighbor_spin = site_neighbors[1 - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37983180000000005}
#standard deviation: 0.04540113113965334
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3909514000000003}
#standard deviation: 0.04576394648672687
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.29195860000000007}
#standard deviation: 0.04827854022275322
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin as the current site
        same_spin_neighbors = [J[3, i, (j+3)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(same_spin_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in same_spin_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.4194006}
#standard deviation: 0.044117599658639636
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + (total_spin > 0)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - (total_spin < 0)
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + (total_spin > 0)
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0]) + (total_spin > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.04214219999999999}
#standard deviation: 0.04881710580483034
#island_id: 2
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d) % N, j, k] * h[i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
        # Add a new term based on the product of the site and its neighbors
        for d in range(6):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins[d]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins[d]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * interacting_spins[d]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * interacting_spins[d]
        
  return priorities




#score: {'data3D.txt': 0.08143059999999999}
#standard deviation: 0.04573857959797178
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * h[i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin
        site_neighbors_same = [val for val in site_neighbors if val > 0]
        site_neighbors_opposite = [val for val in site_neighbors if val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        
        # Add a new term based on the difference between the number of neighbors with the same spin and those with the opposite spin, for each axis separately
        site_neighbors_x = [val for val in site_neighbors if val > 0 and i < N-1]
        site_neighbors_x_opposite = [val for val in site_neighbors if val < 0 and i < N-1]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_x) - len(site_neighbors_x_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_x_opposite) - len(site_neighbors_x)
        
        site_neighbors_y = [val for val in site_neighbors if val > 0 and j < N-1]
        site_neighbors_y_opposite = [val for val in site_neighbors if val < 0 and j < N-1]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_y) - len(site_neighbors_y_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_y_opposite) - len(site_neighbors_y)
        
        site_neighbors_z = [val for val in site_neighbors if val > 0 and k < N-1]
        site_neighbors_z_opposite = [val for val in site_neighbors if val < 0 and k < N-1]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_z) - len(site_neighbors_z_opposite))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_z_opposite) - len(site_neighbors_z)
  
  return(priorities)




#score: {'data3D.txt': -0.31363739999999984}
#standard deviation: 0.04496393400537811
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d) % N, j, k] * h[i][j][k] for d in range(6)]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_same = [val for val in site_neighbors if val > 0]
          site_neighbors_opposite = [val for val in site_neighbors if val < 0]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors_opposite) - len(site_neighbors_same)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_same = [val for val in site_neighbors if val < 0]
          site_neighbors_opposite = [val for val in site_neighbors if val > 0]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len(site_neighbors_opposite) - len(site_neighbors_same))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.13644060000000002}
#standard deviation: 0.04470747131789048
#island_id: 3
#version_generated: 2
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4942222000000001}
#standard deviation: 0.04316765857861647
#island_id: 3
#version_generated: 2
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 2
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49731140000000007}
#standard deviation: 0.039625450786584124
#island_id: 3
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48482179999999997}
#standard deviation: 0.04260461529881475
#island_id: 3
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's diagonal neighbors
        diag_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(diag_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif sum(diag_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.27618420000000016}
#standard deviation: 0.05386859818447108
#island_id: 3
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * interacting_spins[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]])
        priorities[i*N*N + j*N + k][1] -= len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 1
#version_generated: 2
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5085498000000002}
#standard deviation: 0.04208820737403769
#island_id: 1
#version_generated: 2
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
        priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 1
#version_generated: 2
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.00011980000000000013}
#standard deviation: 0.04529135025542957
#island_id: 2
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = [np.roll(h, -1, axis=0), np.roll(h, 1, axis=0)]
  interacting_spins_y = [np.roll(h, -1, axis=1), np.roll(h, 1, axis=1)]
  interacting_spins_z = [np.roll(h, -1, axis=2), np.roll(h, 1, axis=2)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = np.sum([J[0, i, j, k] * h[i][j][k] for _ in range(4)])
        total_spin_y = np.sum([J[1, i, j, k] * h[i][j][k] for _ in range(4)])
        total_spin_z = np.sum([J[2, i, j, k] * h[i][j][k] for _ in range(4)])

        site_neighbors_x = [J[0, i, (j + 1) % N, k], J[0, (i + 1) % N, j, k], J[0, i, j, (k + 1) % N]]
        site_neighbors_y = [J[1, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[1, i, j, (k + 1) % N]]
        site_neighbors_z = [J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        site_nbr_same_x = len([val for val in site_neighbors_x if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite_x = len([val for val in site_neighbors_x if np.sign(val) != np.sign(h[i][j][k])])

        site_nbr_same_y = len([val for val in site_neighbors_y if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite_y = len([val for val in site_neighbors_y if np.sign(val) != np.sign(h[i][j][k])])

        site_nbr_same_z = len([val for val in site_neighbors_z if np.sign(val) == np.sign(h[i][j][k])])
        site_nbr_opposite_z = len([val for val in site_neighbors_z if np.sign(val) != np.sign(h[i][j][k])])

        priorities[i * N * N + j * N + k][0] += -total_spin_x + 2 * (site_nbr_same_x - site_nbr_opposite_x) - 4 * total_spin_y - 8 * total_spin_z
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x

  return(priorities)




#score: {'data3D.txt': -0.0005206000000000004}
#standard deviation: 0.04841461241856636
#island_id: 2
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])]) - len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.10941420000000007}
#standard deviation: 0.0481474235900531
#island_id: 2
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val == 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -total_spin - len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val == 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.03833659999999999}
#standard deviation: 0.04899122636187014
#island_id: 2
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        same_spin_count = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_spin_count = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_spin_count - opposite_spin_count
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_spins_sum = sum([np.sum(interacting_spins[d][i, j, k]) for d in range(6)])
        
        site_magnetism = h[i][j][k]
        
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += -interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= interacting_spins_sum
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] += interacting_spins_sum
        
  return(priorities)




#score: {'data3D.txt': -0.152971}
#standard deviation: 0.04437259513483519
#island_id: 2
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])]) - len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_spin = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.sum(interacting_spin) + len([val for val in interacting_spin if np.sign(val) == np.sign(h[i][j][k])])
        
  return(priorities)




#score: {'data3D.txt': 0.00018420000000000009}
#standard deviation: 0.045358456216674746
#island_id: 2
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        neighbors_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        neighbors_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (neighbors_same - neighbors_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0079434}
#standard deviation: 0.048014059153960315
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.0079434}
#standard deviation: 0.048014059153960315
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0012705999999999991}
#standard deviation: 0.049660586541441495
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0) + len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0017469999999999996}
#standard deviation: 0.04736086602882173
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + interacting_spins_sum + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0024114}
#standard deviation: 0.04670429348614536
#island_id: 2
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for ijk, (i, j, k) in enumerate(itertools.product(range(N), range(N), range(N))):
    total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
    
    site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
    
    priorities[ijk][0] += -total_spin + len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])]) - len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
    priorities[ijk][1] -= 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0024114}
#standard deviation: 0.04670429348614536
#island_id: 2
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0005206000000000004}
#standard deviation: 0.04841461241856636
#island_id: 2
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])]) - len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.12351300000000001}
#standard deviation: 0.04776047812784122
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum([np.abs(val) for val in site_neighbors + x_neighbors])
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - sum([np.abs(val) for val in site_neighbors + x_neighbors])
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.32595980000000035}
#standard deviation: 0.0490262585148
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + sum([np.abs(val) for val in site_neighbors]) + np.sum([np.abs(val) for val in x_neighbors])
          priorities[i * N * N + j * N + k][1] = 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum([np.abs(val) for val in site_neighbors]) - np.sum([np.abs(val) for val in x_neighbors])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.3487453999999996}
#standard deviation: 0.04517707581107922
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + np.sum(np.abs(site_neighbors)) + np.sum(np.abs(x_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - np.sum(np.abs(site_neighbors)) - np.sum(np.abs(x_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - np.sum(np.abs(x_neighbors))
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + np.sum(np.abs(x_neighbors))
            priorities[i * N * N + j * N + k][1] = -2

  return priorities




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 1
#version_generated: 3
#generate time07:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.12767580000000012}
#standard deviation: 0.0477765010686216
#island_id: 1
#version_generated: 3
#generate time07:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * len([val for val in site_neighbors if val > 0]) + 2 * len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 1
#version_generated: 3
#generate time07:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5085498000000002}
#standard deviation: 0.04208820737403769
#island_id: 1
#version_generated: 3
#generate time07:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
        priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.49866299999999997}
#standard deviation: 0.04316936773917357
#island_id: 1
#version_generated: 3
#generate time07:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if site_nbr == i:
            neighbor_spin = site_neighbors[d]
          else:
            neighbor_spin = site_neighbors[1 - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3918162}
#standard deviation: 0.04842632277553191
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i + d) % N, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, (j + d) % N, k] for d in [-1, 0, 1]]
        interacting_spins_z = [J[2, i, j, (k + d) % N] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins_x) + sum(interacting_spins_y) + sum(interacting_spins_z))) * len([val for val in interacting_spins_x if val < 0]) + len([val for val in interacting_spins_y if val < 0]) + len([val for val in interacting_spins_z if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins_x) + sum(interacting_spins_y) + sum(interacting_spins_z))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins_x) + sum(interacting_spins_y) + sum(interacting_spins_z))) * len([val for val in interacting_spins_x if val > 0]) + len([val for val in interacting_spins_y if val > 0]) + len([val for val in interacting_spins_z if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins_x) + sum(interacting_spins_y) + sum(interacting_spins_z))
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.116815}
#standard deviation: 0.04615874927898285
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) - 2 * sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.1723698}
#standard deviation: 0.04097747878969618
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.1723698}
#standard deviation: 0.04097747878969618
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0022378}
#standard deviation: 0.057394355568818785
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        interacting_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2979082000000004}
#standard deviation: 0.04588245343004229
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins))
            priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins))
            priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.2856514000000004}
#standard deviation: 0.04656232165646381
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.34672459999999966}
#standard deviation: 0.04519785166177702
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - sum([abs(J[3, i, (j+1)%N, k]), abs(J[4, (i+1)%N, j, k]), abs(J[5, i, j, (k+1)%N])])
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + sum([abs(J[3, i, (j+1)%N, k]), abs(J[4, (i+1)%N, j, k]), abs(J[5, i, j, (k+1)%N])])
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum([abs(J[3, i, (j+1)%N, k]), abs(J[4, (i+1)%N, j, k]), abs(J[5, i, j, (k+1)%N])])
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum([abs(J[3, i, (j+1)%N, k]), abs(J[4, (i+1)%N, j, k]), abs(J[5, i, j, (k+1)%N])])
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3813946}
#standard deviation: 0.04824969399737163
#island_id: 3
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1.5
          priorities[i * N * N + j * N + k][1] -= 2.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1.5
          priorities[i * N * N + j * N + k][1] += 2.5
        
  return(priorities)




#score: {'data3D.txt': -0.38968980000000014}
#standard deviation: 0.04780078551613979
#island_id: 3
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
                  J[3, (i - 1) % N, j, k], J[4, i, (j - 1) % N, k], J[5, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4132354}
#standard deviation: 0.042250165287724024
#island_id: 1
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1 if total_spin < 0 else 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -1 if total_spin > 0 else 1
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3201394}
#standard deviation: 0.045169932119054575
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3

  return(priorities)




#score: {'data3D.txt': -0.19056260000000025}
#standard deviation: 0.04835105212133445
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors) - np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + sum(x_neighbors) + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors) - np.sum(J[:, i, j, k])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors) + np.sum(J[:, i, j, k])
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0305718}
#standard deviation: 0.047680121274594096
#island_id: 1
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])

        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0005037999999999997}
#standard deviation: 0.04424761310579363
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same - J[3, i, j, k] * h[site_nbr][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_neighbors_same + J[3, i, j, k] * h[site_nbr][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        site_neighbors_same = sum([s if s > 0 else -s for s in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + site_neighbors_same
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13151500000000046}
#standard deviation: 0.05136099156947809
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  total_energy = 0
  for i in range(N):
    for j in range(N):
      for k in range(N):
        energy = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= energy
          priorities[i * N * N + j * N + k][1] = -2 + 2 * energy
        else:
          priorities[i * N * N + j * N + k][0] = energy
          priorities[i * N * N + j * N + k][1] = 2 - 2 * energy

  return(priorities)




#score: {'data3D.txt': 0.31689300000000026}
#standard deviation: 0.044776487926142645
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, (i + (d-1)) % N, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, (j + (d-4)) % N, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + interacting_spins_sum + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.3113586000000002}
#standard deviation: 0.04527440696508346
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        interacting_spins_sum = 0
        for d in range(3):
          interacting_spins_sum += sum(J[l, i, j, k] * h[(i + (d-1)) % N][j][k] for l in range(2))
        for d in range(3,6):
          interacting_spins_sum += sum(J[l, i, j, k] * h[i][(j + (d-4)) % N][k] for l in range(2))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - interacting_spins_sum - sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + interacting_spins_sum + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3110562}
#standard deviation: 0.04957421347394228
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 3.5
        
  return(priorities)




#score: {'data3D.txt': -0.1698086}
#standard deviation: 0.04578201880695083
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val > 0]) + total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2.5
          priorities[i * N * N + j * N + k][1] -= 3.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2.5
          priorities[i * N * N + j * N + k][1] += 3.5
  
  return(priorities)




#score: {'data3D.txt': -0.3068378}
#standard deviation: 0.04979536335001483
#island_id: 3
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 4
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.3068378}
#standard deviation: 0.04979536335001483
#island_id: 3
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 4
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 4

  return(priorities)




#score: {'data3D.txt': -0.3044582}
#standard deviation: 0.04990917122894349
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2.5
          priorities[i * N * N + j * N + k][1] -= 4.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2.5
          priorities[i * N * N + j * N + k][1] += 4.5

  return(priorities)




#score: {'data3D.txt': -0.3044582}
#standard deviation: 0.04990917122894349
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2.5
          priorities[i * N * N + j * N + k][1] -= 4.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2.5
          priorities[i * N * N + j * N + k][1] += 4.5
        
  return(priorities)




#score: {'data3D.txt': -0.2648542}
#standard deviation: 0.05302847897460382
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1.5
          priorities[i * N * N + j * N + k][1] -= 3
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1.5
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49042579999999997}
#standard deviation: 0.04373391835132087
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.07481660000000001}
#standard deviation: 0.04355461312467372
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        neighbors_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        neighbors_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (neighbors_same - neighbors_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_neighbors = [val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])]
        
        priorities[i * N * N + j * N + k][0] += sum(interacting_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 4 * len([val for val in interacting_neighbors if np.sign(val) == np.sign(h[i][j][k])])
  
  return(priorities)




#score: {'data3D.txt': 0.0002862000000000001}
#standard deviation: 0.043408310374397206
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        neighbors_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        neighbors_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (neighbors_same - neighbors_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_site_neighbors = [val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])]
        
        priorities[i * N * N + j * N + k][0] += len(interacting_site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(interacting_site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3110562}
#standard deviation: 0.04957421347394228
#island_id: 3
#version_generated: 3
#generate time08:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 3.5
        
  return(priorities)




#score: {'data3D.txt': -0.3110562}
#standard deviation: 0.04957421347394228
#island_id: 3
#version_generated: 3
#generate time08:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 3.5
        
  return(priorities)




#score: {'data3D.txt': -0.3110562}
#standard deviation: 0.04957421347394228
#island_id: 3
#version_generated: 3
#generate time08:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 3.5
        
  return(priorities)




#score: {'data3D.txt': -0.3110562}
#standard deviation: 0.04957421347394228
#island_id: 3
#version_generated: 3
#generate time08:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3.5
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 3.5
        
  return(priorities)




#score: {'data3D.txt': -0.38968980000000014}
#standard deviation: 0.04780078551613979
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
             J[3, (i - 1) % N, j, k], J[4, i, (j - 1) % N, k], J[5, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.38968980000000014}
#standard deviation: 0.04780078551613979
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
               J[3, (i - 1) % N, j, k], J[4, i, (j - 1) % N, k], J[5, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.38968980000000014}
#standard deviation: 0.04780078551613979
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
             J[3, (i - 1) % N, j, k], J[4, i, (j - 1) % N, k], J[5, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.38968980000000014}
#standard deviation: 0.04780078551613979
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
             J[3, (i - 1) % N, j, k], J[4, i, (j - 1) % N, k], J[5, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.27874140000000036}
#standard deviation: 0.04355743295971423
#island_id: 0
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.1560170000000001}
#standard deviation: 0.04785639341822575
#island_id: 0
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.2969662000000003}
#standard deviation: 0.045444151412035394
#island_id: 0
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.abs([J[d, i, j, k] for d in [0, 1, 2]])) - np.sum(np.abs(site_neighbors)) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.abs([J[d, i, j, k] for d in [0, 1, 2]])) + np.sum(np.abs(site_neighbors)) - total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -8.020000000000005e-05}
#standard deviation: 0.04389071801599969
#island_id: 1
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spin = sum(J[d, i, j, k] * (h[i][j][k] - h[(i+1)%N if d==0 else (i+N-1)//N][j][k]) for d in [0, 1, 2])
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0013038}
#standard deviation: 0.047639669872491776
#island_id: 1
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        interacting_spin = sum(J[d, i, j, k] * (h[i][j][k] if (d in [0, 2]) else -h[(i+1)%N][j][k] if d==1 else h[i][(j+1)%N][k] ) for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0022378}
#standard deviation: 0.057394355568818785
#island_id: 1
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        interacting_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))

        priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin
        priorities[i*N*N + j*N + k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': 0.0022378}
#standard deviation: 0.057394355568818785
#island_id: 1
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        interacting_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.24155180000000037}
#standard deviation: 0.04548888607956893
#island_id: 1
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * sum([val for val in site_neighbors if val > 0]) + 2 * sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.124577}
#standard deviation: 0.05319511247285788
#island_id: 1
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 2 * abs(total_spin) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - 2 * abs(total_spin) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -4 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5089218}
#standard deviation: 0.04157837520586874
#island_id: 1
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.007918600000000007}
#standard deviation: 0.04621691696814058
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        spin = h[i][j][k]
        if spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -total_spin - same_neighbors + opposite_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0001401999999999996}
#standard deviation: 0.04573166412847886
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - 2*opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0024114}
#standard deviation: 0.04670429348614536
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        same_spin_neighbors = sum(1 for val in site_neighbors if np.sign(val) * h[i][j][k] > 0)
        opposite_spin_neighbors = sum(1 for val in site_neighbors if np.sign(val) * h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.037774999999999996}
#standard deviation: 0.04696980365085636
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        total_neighbor_spin = sum(np.sign(spin) for spin in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6
  
  return(priorities)




#score: {'data3D.txt': 0.07481660000000001}
#standard deviation: 0.04355461312467372
#island_id: 2
#version_generated: 3
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        neighbors_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        neighbors_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (neighbors_same - neighbors_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_neighbors = [val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])]
        
        priorities[i * N * N + j * N + k][0] += sum(interacting_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 4 * len([val for val in interacting_neighbors if np.sign(val) == np.sign(h[i][j][k])])
  
  return(priorities)




#score: {'data3D.txt': 0.01344379999999999}
#standard deviation: 0.046029655240507714
#island_id: 2
#version_generated: 3
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = np.sum([val * h[i][j][k] for val in site_neighbors])
        
        neighbors_same = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        neighbors_opposite = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + 2 * (neighbors_same - neighbors_opposite)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        interacting_neighbors = [val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])]
        
        priorities[i * N * N + j * N + k][0] += sum(interacting_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 4 * len([val for val in interacting_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        
        # Add a bonus term to favor sites with more same-sign neighbors
        priorities[i * N * N + j * N + k][0] += (neighbors_same - neighbors_opposite) * 2
        
        # Add a penalty term to discourage sites with many opposite-sign neighbors
        priorities[i * N * N + j * N + k][1] -= (neighbors_opposite + 1) * 2
  
  return(priorities)




#score: {'data3D.txt': -0.0005037999999999996}
#standard deviation: 0.04569804794036612
#island_id: 2
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_neighbor_spin = sum(spin > 0 for spin in site_neighbors)
        
        site_energy = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        same_neighbors_energy = np.sum([spin * J[0, (i + 1) % N if spin == h[i][j][k] else 0, j, k]
                       + spin * J[1, i, (j + 1) % N if spin == h[i][j][k] else 0, k]
                       + spin * J[2, i, j, (k + 1) % N if spin == h[i][j][k] else 0] for spin in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -site_energy + same_neighbors_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

        same_neighbors = sum([s if s > 0 else -s for s in site_neighbors])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.08568019999999998}
#standard deviation: 0.04709307303585104
#island_id: 2
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        total_neighbor_spin = sum(np.sign(spin) for spin in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6
        
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][spin] -= J[d, i, j, k]
    
  return(priorities)




#score: {'data3D.txt': -0.29908180000000006}
#standard deviation: 0.05268847073848319
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.3392834}
#standard deviation: 0.04817835244630103
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins.append(sum(J[d, i, j, k] for d in [3, 4, 5]))
        total_spin += sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors.extend([J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
  
  return(priorities)




#score: {'data3D.txt': 0.44966380000000017}
#standard deviation: 0.04216105180803724
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - abs(total_spin)
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) < 0))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + abs(total_spin)
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) > 0))
          priorities[i * N * N + j * N + k][1] = -2
        priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
        priorities[i * N * N + j * N + k][1] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
  return(priorities)




#score: {'data3D.txt': 0.11531699999999999}
#standard deviation: 0.047656954487251914
#island_id: 0
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        
  return(priorities)




#score: {'data3D.txt': -0.10664259999999999}
#standard deviation: 0.06012532366016836
#island_id: 0
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': 0.3074534000000003}
#standard deviation: 0.04575847100199043
#island_id: 0
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([J[l, i, j, k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] = 0
        
  return(priorities)




#score: {'data3D.txt': -0.31856460000000003}
#standard deviation: 0.046079795863697134
#island_id: 0
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([abs(val) for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.3430038}
#standard deviation: 0.043893518719282466
#island_id: 3
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1959534}
#standard deviation: 0.04736693729216614
#island_id: 3
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.029785799999999994}
#standard deviation: 0.0471001536978384
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.28794620000000004}
#standard deviation: 0.05081755076309758
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # calculate the priority based on the interaction with the nearest neighbors along each axis
        for d in range(3):
          if h[(i+d)%N, (j+d)%N, (k+d)%N] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) + J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) + J[d, i, j, k]

        # add the priority based on the interaction with the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.2203094000000003}
#standard deviation: 0.0458973906844387
#island_id: 0
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val < 0)

  return priorities




#score: {'data3D.txt': -0.1276194000000001}
#standard deviation: 0.047876563615614695
#island_id: 0
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) 
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) 
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) 
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) 
  
  return(priorities)




#score: {'data3D.txt': 0.09128300000000006}
#standard deviation: 0.046075780525130554
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [
          J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
          J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N],
          J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]
        ]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -np.sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6)) - site_nbr
          priorities[i*N*N + j*N + k][1] = 2 * h[i][j][k]
        else:
          priorities[i*N*N + j*N + k][0] += np.sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6)) - site_nbr
          priorities[i*N*N + j*N + k][1] = 2 * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19372500000000006}
#standard deviation: 0.04863684873632338
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        interacting_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin + site_nbr
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * interacting_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0010938000000000005}
#standard deviation: 0.04806352839274287
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spin_x = interacting_spins_x[i][j][k]
        interacting_spin_y = interacting_spins_y[i][j][k]
        interacting_spin_z = interacting_spins_z[i][j][k]
        
        priorities[i*N*N + j*N + k][0] += -2 * J[0, i, j, k] * total_spin * interacting_spin_x
        priorities[i*N*N + j*N + k][1] -= 2 * J[0, i, j, k] * total_spin
        
        priorities[i*N*N + j*N + k][0] += -2 * J[1, i, j, k] * total_spin * interacting_spin_y
        priorities[i*N*N + j*N + k][1] -= 2 * J[1, i, j, k] * total_spin
        
        priorities[i*N*N + j*N + k][0] += -2 * J[2, i, j, k] * total_spin * interacting_spin_z
        priorities[i*N*N + j*N + k][1] -= 2 * J[2, i, j, k] * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19372500000000006}
#standard deviation: 0.04863684873632338
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        interacting_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin + site_nbr
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(abs(total_spin)) * interacting_spin - site_nbr
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4597834}
#standard deviation: 0.04222673755382957
#island_id: 3
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2884306000000003}
#standard deviation: 0.046322431538510574
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in site_neighbors + x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(site_neighbors) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(site_neighbors) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.29663380000000017}
#standard deviation: 0.04735474820501106
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        neighbor_spin = sum(1 for val in site_neighbors + x_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -4
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors) - total_spin - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 4
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(site_neighbors) - sum(x_neighbors) - total_spin - neighbor_spin
            priorities[i * N * N + j * N + k][1] = 4
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(site_neighbors) + sum(x_neighbors) + total_spin + neighbor_spin
            priorities[i * N * N + j * N + k][1] = -4
  
  return priorities




#score: {'data3D.txt': -0.2884306000000003}
#standard deviation: 0.046322431538510574
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(site_neighbors) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(site_neighbors) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.2832014000000004}
#standard deviation: 0.046365572982979504
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        site_energy = h[i][j][k] + sum(interacting_spins)
        neighbor_energy = sum(site_neighbors) + sum(x_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = site_energy - neighbor_energy
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -site_energy + neighbor_energy
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if site_energy > 0:
            priorities[i * N * N + j * N + k][0] = -site_energy + neighbor_energy
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = site_energy - neighbor_energy
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': 0.08568019999999998}
#standard deviation: 0.04709307303585104
#island_id: 2
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        total_neighbor_spin = sum(np.sign(spin) for spin in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6
        
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][spin] -= J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': 0.08568019999999998}
#standard deviation: 0.04709307303585104
#island_id: 2
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        total_neighbor_spin = sum(np.sign(spin) for spin in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6
        
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][spin] -= J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': 0.012401}
#standard deviation: 0.04627824844351826
#island_id: 2
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if np.sum(np.sign(site_neighbors)) > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif np.sum(np.sign(site_neighbors)) < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6
        
  return(priorities)




#score: {'data3D.txt': 0.012401}
#standard deviation: 0.04627824844351826
#island_id: 2
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        total_neighbor_spin = sum(np.sign(spin) for spin in site_neighbors)

        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6

  return(priorities)




#score: {'data3D.txt': 0.31762899999999983}
#standard deviation: 0.04607943314538492
#island_id: 0
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.sum(np.abs(interacting_spins_sum))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.sum(np.abs(interacting_spins_sum))
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': 0.36956500000000025}
#standard deviation: 0.043617211453736926
#island_id: 0
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.sum(np.abs(interacting_spins_sum))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.sum(np.abs(interacting_spins_sum))
          priorities[i * N * N + j * N + k][1] = -2
        
        if total_spin > 0 and h[i][j][k] <= 0 or total_spin < 0 and h[i][j][k] >= 0:
          priorities[i * N * N + j * N + k][1] = 3
        elif total_spin == 0:
          priorities[i * N * N + j * N + k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 0
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.sum(np.abs(interacting_spins[3, i, j, k]))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.sum(np.abs(interacting_spins[3, i, j, k]))
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': 0.18149339999999992}
#standard deviation: 0.044502001263314
#island_id: 2
#version_generated: 3
#generate time08:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0 or J[1, i, j, k] < 0 or J[2, i, j, k - 1] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 3
            priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          if J[0, i, j, k] > 0 or J[1, i, j, k] > 0 or J[2, i, j, k - 1] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * -3
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0640274}
#standard deviation: 0.05179849736469196
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
        # New improvement
        for d in [3,4,5]:
          for x in [(i+1)%N, i-1]:
            for y in [(j+1)%N, j-1]:
              for z in [(k+1)%N, k-1]:
                priorities[i * N * N + j * N + k][0] += J[d, x, y, z]
                priorities[i * N * N + j * N + k][1] -= J[d, x, y, z]
  
  return(priorities)




#score: {'data3D.txt': -0.4707526}
#standard deviation: 0.04271667722611393
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(total_spin - np.abs(total_spin)) * (np.array(site_neighbors) < 0))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-total_spin - np.abs(total_spin)) * (np.array(site_neighbors) > 0))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0025289999999999996}
#standard deviation: 0.05671584151716343
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09741380000000001}
#standard deviation: 0.055116107351299765
#island_id: 0
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  site_neighbors = [[J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]] for i in range(N) for j in range(N) for k in range(N)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        
  return(priorities)




#score: {'data3D.txt': -0.1063842}
#standard deviation: 0.05550881470865686
#island_id: 0
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        
        # Calculate additional terms
        priorities[i * N * N + j * N + k][0] += np.sum([J[d, i, j, k] * h[i][j][k] for d in [3, 4, 5]])
        priorities[i * N * N + j * N + k][1] -= np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])
        
  return(priorities)




#score: {'data3D.txt': -0.3404705999999996}
#standard deviation: 0.04561348326580639
#island_id: 0
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs([J[l, i, j, k] for l in range(6)])) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -len([val for val in [J[l, i, j, k] for l in range(6)] if val < 0]) - len([val for val in site_neighbors if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs([J[l, i, j, k] for l in range(6)])) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = len([val for val in [J[l, i, j, k] for l in range(6)] if val > 0]) + len([val for val in site_neighbors if val > 0])
        else:
          if np.sum([J[l, i, j, k] for l in range(6)]) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs([J[l, i, j, k] for l in range(6)]))
            priorities[i * N * N + j * N + k][1] = len([val for val in [J[l, i, j, k] for l in range(6)] if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs([J[l, i, j, k] for l in range(6)]))
            priorities[i * N * N + j * N + k][1] = -len([val for val in [J[l, i, j, k] for l in range(6)] if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.0333106}
#standard deviation: 0.04666672012944557
#island_id: 0
#version_generated: 3
#generate time08:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        energy = -h[i][j][k]
        for d in range(3):
          if interacting_spins[d] * J[d, i, j, k] > 0:
            energy += J[d, i, j, k]
          else:
            energy -= J[d, i, j, k]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -energy
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] = energy
          priorities[i * N * N + j * N + k][1] = -np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.22764859999999998}
#standard deviation: 0.048977606291447116
#island_id: 1
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_x = sum(np.sign(val) for val in site_neighbors)
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]]
        site_nbr_yz = sum(np.sign(val) for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr_x + site_nbr_yz
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr_x - site_nbr_yz
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.07662740000000001}
#standard deviation: 0.04977558848712891
#island_id: 1
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = np.sum(np.sign([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]]
        site_nbr = np.sum(np.sign(site_neighbors))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.021287799999999996}
#standard deviation: 0.04687169477584526
#island_id: 1
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(np.sign(np.array(site_neighbors)))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          total_spin = sum(J[d, i, j, k] for i in range(N))

          site_nbr = np.sum(np.sign(np.array(site_neighbors)))

          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.08742699999999999}
#standard deviation: 0.0511787732463372
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = []
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        for x in range(3):
          if x == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif x == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins.append(sum(J[d, i, j, k] for d in [3, 4, 5]))
        total_spin += sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]])
        site_nbr = sum(np.sign(site_neighbors))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.35786019999999996}
#standard deviation: 0.04827554511302798
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins.extend([sum(J[d, i, j, k] for d in [3, 4, 5])])
        total_spin += sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4333302}
#standard deviation: 0.04419126574290444
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        site_neighbors = np.sum(np.sign([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = sum(J[d, i, j, k] for d in [0, 1, 2]) - abs(sum(J[d, i, j, k] for d in [0, 1, 2])) + site_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] = -sum(J[d, i, j, k] for d in [0, 1, 2]) - abs(sum(J[d, i, j, k] for d in [0, 1, 2])) + site_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.3621626}
#standard deviation: 0.047808664499649024
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins.append(sum(J[d, i, j, k] for d in [3, 4, 5]))
        total_spin += sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]])
        site_nbr = sum(1 for val in site_neighbors if val < 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0685074}
#standard deviation: 0.04713419931684424
#island_id: 0
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -np.sum(np.sign(interacting_spins) + np.sign(site_neighbors))
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = np.sum(np.sign(interacting_spins) + np.sign(site_neighbors))
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins))
            priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins))
            priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.34222139999999956}
#standard deviation: 0.04501484268594082
#island_id: 0
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3435633999999997}
#standard deviation: 0.04490257075535875
#island_id: 0
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of neighbors with same spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.abs(interacting_spins)) - neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.abs(interacting_spins)) + neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3365157999999997}
#standard deviation: 0.044382634333261464
#island_id: 0
#version_generated: 3
#generate time09:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        # Add a new term based on the magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site interaction
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.abs(interacting_spins)) / (2 * len(interacting_spins))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) / len(interacting_spins)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.abs(interacting_spins)) / (2 * len(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) / len(interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.009271000000000135}
#standard deviation: 0.047538421082320356
#island_id: 0
#version_generated: 3
#generate time09:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([val for val in interacting_spins if val < 0]) - sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 0
  
  return(priorities)




#score: {'data3D.txt': -0.29074940000000027}
#standard deviation: 0.045415625060544966
#island_id: 0
#version_generated: 3
#generate time09:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.1959534}
#standard deviation: 0.04736693729216614
#island_id: 3
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2746926}
#standard deviation: 0.0450724246656423
#island_id: 3
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.22838380000000005}
#standard deviation: 0.0461888074922919
#island_id: 3
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, ((j - 1) % N), k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4597834}
#standard deviation: 0.04222673755382957
#island_id: 3
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1221794}
#standard deviation: 0.047262686504683585
#island_id: 2
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[0, i, j, k]
        if neighbor_spin > 0:
         priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
         priorities[i * N * N + j * N + k][1] -= 2
        else:
         priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
         priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
         priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
         priorities[i * N * N + j * N + k][1] -= 2
        else:
         priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
         priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.31630020000000003}
#standard deviation: 0.04291556454201669
#island_id: 2
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.003600999999999999}
#standard deviation: 0.04698396789331441
#island_id: 2
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          if (J[0, i, j, k] < 0 or J[1, i, j, k] < 0 or J[2, i, j, k - 1] < 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin < 0:
          if (J[0, i, j, k] > 0 or J[1, i, j, k] > 0 or J[2, i, j, k - 1] > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -3
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1773510000000005}
#standard deviation: 0.04574976326714708
#island_id: 0
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1773510000000005}
#standard deviation: 0.04574976326714708
#island_id: 0
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin

        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1773510000000005}
#standard deviation: 0.04574976326714708
#island_id: 0
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1773510000000005}
#standard deviation: 0.04574976326714708
#island_id: 0
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] + neighbor_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin < 0:
            priorities[i * N * N + j * N + k][0] += h[i][j][k] - neighbor_spin
        
        # Add a new term based on the local energy and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.31856460000000003}
#standard deviation: 0.046079795863697134
#island_id: 0
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[l, i, j, k] * h[i][j][k] for l in range(6)])

        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.sum([J[l, i, j, k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - np.sum([J[l, i, j, k] for l in range(6)])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([abs(val) for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin = np.sum([J[l, :, :, :] * h for l in range(6)], axis=(0, 1, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([abs(val) for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5249146}
#standard deviation: 0.04211000198100209
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.000895000000000006}
#standard deviation: 0.04691537972776092
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2]) + 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [0, 1, 2]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2]) - 2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.41759540000000006}
#standard deviation: 0.042747413709369596
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4542394}
#standard deviation: 0.04733358477487206
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return priorities




#score: {'data3D.txt': -0.48248259999999993}
#standard deviation: 0.04072530831362729
#island_id: 3
#version_generated: 3
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.043085}
#standard deviation: 0.04710414519975922
#island_id: 3
#version_generated: 3
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] += 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.017838600000000007}
#standard deviation: 0.04543135998448649
#island_id: 3
#version_generated: 3
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2]) - total_spin
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2]) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [0, 1, 2]) - total_spin
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2]) + total_spin
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.1690729999999999}
#standard deviation: 0.04542946522907793
#island_id: 3
#version_generated: 3
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2]) + total_spin
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [0, 1, 2]) + total_spin
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]))
          priorities[i * N * N + j * N + k][1] += np.sum(np.array([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]))
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.array([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]))
        
  return priorities




#score: {'data3D.txt': -0.4446930000000001}
#standard deviation: 0.04717617906316704
#island_id: 1
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in itertools.product([0,1], [0,1], [0,1])]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5085498000000002}
#standard deviation: 0.04208820737403769
#island_id: 1
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
        priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.5085498000000002}
#standard deviation: 0.04208820737403769
#island_id: 1
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) < 0))
        priorities[i * N * N + j * N + k][1] -= np.sum(np.exp(-np.abs(np.array(site_neighbors))) * (np.array(site_neighbors) > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.16552619999999998}
#standard deviation: 0.04823056741901343
#island_id: 1
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins.extend([sum(J[d, i, j, k] for d in [3, 4, 5])])
        total_spin += sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, (i - 1) % N, j, k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins.extend([sum(J[d, i-1 if i else N-1, j, k] for d in [3, 4, 5])])
        total_spin += sum(J[d, i-1 if i else N-1, j, k] for d in [3, 4, 5])
        
        site_neighbors.extend([J[3, (i - 1) % N, j, k], J[4, i-1 if i else N-1, j, k], J[5, (i+1) % N, j, k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + abs(total_spin) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3963302}
#standard deviation: 0.05171390884433317
#island_id: 1
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N],
          J[3, (i - 1) % N, j, k],
          J[4, i, (j - 1) % N, k],
          J[5, (i + 1) % N, (j + 1) % N, k]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(J[3, i, j, k] - abs(J[3, i, j, k])) * (np.array(site_neighbors) < 0)) + J[4, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in range(6))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-J[3, i, j, k] - abs(J[3, i, j, k])) * (np.array(site_neighbors) > 0)) - J[4, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in range(6))
        
  return(priorities)




#score: {'data3D.txt': 0.07622419999999999}
#standard deviation: 0.043530352793883946
#island_id: 1
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
               np.roll(np.roll(h, -1, axis=0), 1, axis=1),
               np.roll(np.roll(h, -1, axis=0), -1, axis=2), 
               np.roll(np.roll(h, -1, axis=0), 1, axis=2)])
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N],
                  J[3, (i - 1) % N, j, k],
                  J[4, i, (j - 1) % N, k],
                  J[5, i, j, (k - 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - abs(total_spin) + sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.1403058000000002}
#standard deviation: 0.04565160639407993
#island_id: 0
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
        
        if i < N//2:
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(interacting_spins))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(np.sum(np.abs(interacting_spins))) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.2654734000000004}
#standard deviation: 0.04630066362850537
#island_id: 0
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.2654734000000004}
#standard deviation: 0.04630066362850537
#island_id: 0
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.00043420000000000004}
#standard deviation: 0.046999125846764425
#island_id: 2
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        same_neighbors = sum([s if s > 0 else -s for s in site_neighbors])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        same_spin = sum([s if s > 0 else -s for s in interacting_spins[0][i][j] + interacting_spins[1][i][j] + interacting_spins[2][i][j]])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - 2 * opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

        same_neighbors = sum([s if s > 0 else -s for s in site_neighbors])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0005321999999999997}
#standard deviation: 0.04473918286200587
#island_id: 2
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])

        same_neighbors = sum([s if s > 0 else -s for s in site_neighbors])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 1
#version_generated: 3
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.30527819999999994}
#standard deviation: 0.039312789836896594
#island_id: 1
#version_generated: 3
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in itertools.product([0,1], [0,1], [0,1])]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.1700566}
#standard deviation: 0.05959243942347049
#island_id: 1
#version_generated: 3
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in itertools.product([0,1], [0,1], [0,1])]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) < 0)) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(np.array(interacting_spins))) * (np.array(interacting_spins) > 0)) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.08257300000000001}
#standard deviation: 0.04777880650455806
#island_id: 1
#version_generated: 3
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in itertools.product([0,1], [0,1], [0,1])]
        interacting_spins_y = [J[3, i, (j+d)%N, (k+e)%N] for d,e in itertools.product([0,1], [0,1])]
        interacting_spins_z = [J[4, i, j, (k+d)%N] for d in range(2)]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(np.array([total_spin_x, total_spin_y, total_spin_z]))) @ np.array([-1, -1, 2]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x + total_spin_y)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.abs(np.array([total_spin_x, total_spin_y, total_spin_z]))) @ np.array([-1, -1, 2]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y)

  return(priorities)




#score: {'data3D.txt': -0.14612540000000024}
#standard deviation: 0.04648230023180867
#island_id: 0
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        for d in range(6):
          interacting_spins.append(J[d, i, (j+1)%N, k])
          site_neighbors.append(J[d, (i+1)%N, j, k])
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -2 * np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 4
          else:
            priorities[i * N * N + j * N + k][0] -= 2 * np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 4
        
        interacting_spins = [J[d, i, (j+1)%N, k] for d in range(6)]
        site_neighbors = [J[0, i, (j+2)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+2)%N]]
        
        total_spin = sum(J[d, i, (j+1)%N, k] for d in range(6))
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.002302999999999999}
#standard deviation: 0.04633438109007176
#island_id: 0
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2 - total_spin
        
        for d in range(6):
          interacting_spins.append(J[d, i, (j+1)%N, k])
          site_neighbors.append(J[d, (i+1)%N, j, k])
        
        interacting_spins += [J[d, (i+1)%N, j, k] for d in range(3)] + [J[d, i, (j+1)%N, k] for d in range(3)]
        site_neighbors += [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
        priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.1305518000000002}
#standard deviation: 0.04685335032588385
#island_id: 0
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        for d in range(6):
          interacting_spins.append(J[d, i, (j+1)%N, k])
          site_neighbors.append(J[d, (i+1)%N, j, k])
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -2 * np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 4
          else:
            priorities[i * N * N + j * N + k][0] -= 2 * np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 4
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.029458999999999996}
#standard deviation: 0.04666226482930292
#island_id: 0
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        
        for d in range(6):
          interacting_spins.append(J[d, i, (j+1)%N, k])
          site_neighbors.append(J[d, (i+1)%N, j, k])
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -2 * np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 4
          else:
            priorities[i * N * N + j * N + k][0] -= 2 * np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 4
        
        for d in range(3):
          interacting_spins.append(J[d, i, (j+1)%N, (k+1)%N])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -2 * np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] -= 2 * np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.2977758}
#standard deviation: 0.051169585637954894
#island_id: 3
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0410282}
#standard deviation: 0.04743122731661073
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0131742}
#standard deviation: 0.04671090937200859
#island_id: 2
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - 2*opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if np.sum(np.sign(site_neighbors)) > 0:
          priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 6
        elif np.sum(np.sign(site_neighbors)) < 0:
          priorities[i * N * N + j * N + k][0] -= sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 6
        
  return(priorities)




#score: {'data3D.txt': -0.0006477999999999997}
#standard deviation: 0.04604157941643618
#island_id: 2
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])

        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0028721999999999992}
#standard deviation: 0.04658498843146792
#island_id: 2
#version_generated: 3
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [h[(i + 1) % N][j][k], h[i][(j + 1) % N][k], h[i][j][(k + 1) % N]]
        total_spin = np.sum([J[d, i, j, k] * h[i][j][k] for d in range(6)])
        same_neighbors = len([val for val in site_neighbors if np.sign(val) == np.sign(h[i][j][k])])
        opposite_neighbors = len([val for val in site_neighbors if np.sign(val) != np.sign(h[i][j][k])])
        
        priorities[i * N * N + j * N + k][0] += -total_spin + same_neighbors - 3
        priorities[i * N * N + j * N + k][1] -= total_spin + opposite_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_site_neighbors
        priorities[i * N * N + j * N + k][1] -= total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.14195020000000036}
#standard deviation: 0.048913028529830385
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if sum(val for val in interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif sum(val for val in interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5479138}
#standard deviation: 0.039583065691782895
#island_id: 2
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3237977999999999}
#standard deviation: 0.04556031118374851
#island_id: 0
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2

  return priorities




#score: {'data3D.txt': -0.3237977999999999}
#standard deviation: 0.04556031118374851
#island_id: 0
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2
        else:
          x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -2
  
  return priorities




#score: {'data3D.txt': -0.1183534}
#standard deviation: 0.05343234402906165
#island_id: 3
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(6):
          if d % 3 == 0:
            site_neighbors.append(J[d, i, (j + 1) % N, k])
          elif d % 3 == 1:
            site_neighbors.append(J[d, (i + 1) % N, j, k])
          else:
            site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.07077340000000001}
#standard deviation: 0.05159984081797152
#island_id: 3
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interactions with other sites
        for l in range(3):
          interacting_spins.append(J[l, i, (j + 1) % N, k])
          
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4542394}
#standard deviation: 0.04733358477487206
#island_id: 3
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbrs_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_nbrs_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': 0.098359}
#standard deviation: 0.052524839447636584
#island_id: 3
#version_generated: 3
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(6):
          if d % 3 == 0:
            site_neighbors.append(J[d, i, (j + 1) % N, k])
          elif d % 3 == 1:
            site_neighbors.append(J[d, (i + 1) % N, j, k])
          else:
            site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interactions with other sites
        for l in range(3):
          interacting_spins.append(J[l, i, (j + 1) % N, k])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.098359}
#standard deviation: 0.052524839447636584
#island_id: 3
#version_generated: 3
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in range(6):
          if d % 3 == 0:
            site_neighbors.append(J[d, i, (j + 1) % N, k])
          elif d % 3 == 1:
            site_neighbors.append(J[d, (i + 1) % N, j, k])
          else:
            site_neighbors.append(J[d, i, j, (k + 1) % N])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add interactions with other sites
        for l in range(3):
          interacting_spins.append(J[l, i, (j + 1) % N, k])

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': 0.1635026000000003}
#standard deviation: 0.04854800915835787
#island_id: 0
#version_generated: 3
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = np.exp(-h[i][j][k]) * (3 - 2 * np.sum(interacting_spins))
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -np.exp(-h[i][j][k]) * (3 + 2 * np.sum(interacting_spins))
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = np.exp(-h[i][j][k]) * (3 - 2 * np.sum(interacting_spins))
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -np.exp(-h[i][j][k]) * (3 + 2 * np.sum(interacting_spins))
  
  return priorities




#score: {'data3D.txt': -0.2856514000000004}
#standard deviation: 0.04656232165646381
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
        
  return priorities




#score: {'data3D.txt': -0.2856514000000004}
#standard deviation: 0.04656232165646381
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return priorities




#score: {'data3D.txt': -0.2856514000000004}
#standard deviation: 0.04656232165646381
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - sum(site_neighbors) - sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = -3
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) + sum(site_neighbors) + sum(x_neighbors)
          priorities[i * N * N + j * N + k][1] = 3
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = 3
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + sum(x_neighbors)
            priorities[i * N * N + j * N + k][1] = -3
  
  return(priorities)




#score: {'data3D.txt': -0.21808460000000002}
#standard deviation: 0.04445314660223728
#island_id: 2
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.40963940000000026}
#standard deviation: 0.04469211124616961
#island_id: 2
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47556780000000004}
#standard deviation: 0.04081208305342917
#island_id: 2
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        site_neighbors = []

        for d in [0, 1, 2]:
          total_spin += J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 1
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
    
  return(priorities)




#score: {'data3D.txt': -0.41868740000000004}
#standard deviation: 0.04433433253405312
#island_id: 1
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_site_neighbors
        priorities[i * N * N + j * N + k][1] -= total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.28276379999999995}
#standard deviation: 0.046497125175219166
#island_id: 1
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_site_neighbors
        priorities[i * N * N + j * N + k][1] -= total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.1519386}
#standard deviation: 0.04637052889540942
#island_id: 1
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.33854459999999975}
#standard deviation: 0.045454786445873877
#island_id: 0
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) - np.sum(np.abs(site_neighbors)) - sum(x_neighbors) + len([val for val in interacting_spins + site_neighbors + x_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) + np.sum(np.abs(site_neighbors)) + sum(x_neighbors) - len([val for val in interacting_spins + site_neighbors + x_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2
        else:
          if np.sum(interacting_spins) > 0:
            priorities[i * N * N + j * N + k][0] = -np.sum(np.abs(interacting_spins)) - sum(x_neighbors) - len([val for val in interacting_spins + site_neighbors + x_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = 2
          else:
            priorities[i * N * N + j * N + k][0] = np.sum(np.abs(interacting_spins)) + sum(x_neighbors) + len([val for val in interacting_spins + site_neighbors + x_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] = -2
  
  return(priorities)




#score: {'data3D.txt': -0.33122500000000016}
#standard deviation: 0.03972953731167782
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = np.array([J[d, i, (j+1)%N, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, j, (k+1)%N] for d in [0, 1, 2]])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.21876180000000034}
#standard deviation: 0.04607274010475175
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[d, i, (j+1)%N, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, j, (k+1)%N] for d in [0, 1, 2]]
        site_neighbors = np.array(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) + np.sum(np.where(site_neighbors < 0, 1, -1))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - np.sum(np.where(site_neighbors > 0, 1, -1))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.14582420000000001}
#standard deviation: 0.04653134786743235
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[d, i, (j+1)%N, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, j, (k+1)%N] for d in [0, 1, 2]]
        site_neighbors = np.array(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) + len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[d, i, (j+1)%N, k] for d in [0, 1, 2]] + [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, j, (k+1)%N] for d in [0, 1, 2]]
        site_neighbors = np.array(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5079642000000001}
#standard deviation: 0.04230590075107727
#island_id: 2
#version_generated: 3
#generate time10:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                  J[1, i, (j + 1) % N, k], 
                  J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47556780000000004}
#standard deviation: 0.04081208305342917
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        site_neighbors = []

        for d in [0, 1, 2]:
          total_spin += J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4375322}
#standard deviation: 0.04167831478310993
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.273671}
#standard deviation: 0.04968336259755372
#island_id: 1
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.3227686}
#standard deviation: 0.04356832535271467
#island_id: 1
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.15594180000000035}
#standard deviation: 0.048177971031997606
#island_id: 0
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        
        # Add a new term based on the difference between site energy and neighbor spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] + 1)
        
  return priorities




#score: {'data3D.txt': -0.2519186000000005}
#standard deviation: 0.0466138834902221
#island_id: 0
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        
        # Add a new term based on the difference between site energy and neighbor spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] + 1)
        
  return priorities




#score: {'data3D.txt': -0.2519186000000005}
#standard deviation: 0.0466138834902221
#island_id: 0
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(1 for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1 + neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] - neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1 - neighbor_spin
          
          # Add a term based on the product of local magnetism and neighbor spin
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k] * (neighbor_spin - 1)
        
        # Add a new term based on the difference between site energy and neighbor spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - 1)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (h[i][j][k] + 1)
        
  return priorities




#score: {'data3D.txt': -0.020192599999999998}
#standard deviation: 0.045734907294538156
#island_id: 0
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] = -(np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val < 0))
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0]) - sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.27874140000000036}
#standard deviation: 0.04355743295971423
#island_id: 0
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': 0.0275334}
#standard deviation: 0.04604215117085647
#island_id: 0
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([val for val in interacting_spins if val >= 0])
          priorities[i * N * N + j * N + k][1] = -np.sum([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([val for val in interacting_spins if val >= 0])
          priorities[i * N * N + j * N + k][1] = np.sum([val for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.0029246}
#standard deviation: 0.04734975010324764
#island_id: 0
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([1 for val in interacting_spins if val < 0]) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = np.sum([1 for val in interacting_spins if val > 0]) + sum(1 for val in site_neighbors if val < 0)
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([1 for val in interacting_spins if val > 0]) - sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = np.sum([1 for val in interacting_spins if val < 0]) + sum(1 for val in site_neighbors if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.273671}
#standard deviation: 0.04968336259755372
#island_id: 1
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.3067850000000001}
#standard deviation: 0.04617578819034928
#island_id: 1
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr + (total_spin > 0) * 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr + (total_spin < 0) * 3
    
  return(priorities)




#score: {'data3D.txt': -0.043169}
#standard deviation: 0.04412102762855824
#island_id: 1
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbors_sum
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add the priority based on the interaction with the next-nearest neighbors
        for d in range(3):
          next_neighbors = [J[d, i, (j + 1) % N, k], J[d, (i + 1) % N, j, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += sum([np.exp(-abs(val)) * len([val for val in next_neighbors if val < 0]) for val in next_neighbors])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(next_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.22299180000000002}
#standard deviation: 0.045857061100336556
#island_id: 1
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
        
        # Add the priority based on the magnetism at the current site and its neighbors
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum
    
  return(priorities)




#score: {'data3D.txt': -0.030262600000000004}
#standard deviation: 0.04590362732116058
#island_id: 1
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbors_sum
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add the priority based on the interaction with neighbors in all three directions
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - 2
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) + 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) + 2
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3973982}
#standard deviation: 0.04548718189512294
#island_id: 3
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum(site_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        elif sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val != 0])
          priorities[i * N * N + j * N + k][1] = 0
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        site_neighbors = []

        for d in [0, 1, 2]:
          total_spin += J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])

        for l in [0, 1]:
          if (i + (l - 1) % 2 == 0):
            neighbor_spin = J[l, i + l, j, k]
          else:
            neighbor_spin = J[1 - l, i - l, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0032062}
#standard deviation: 0.04692887130072489
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        site_neighbors = []

        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          total_spin += J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        return(priorities)




#score: {'data3D.txt': -0.0011597999999999975}
#standard deviation: 0.052851908801480406
#island_id: 1
#version_generated: 3
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]
  interacting_spins = np.array([np.roll(interacting_spins[0], -1), np.roll(interacting_spins[1], -1), 
                 np.roll(interacting_spins[2], 1), np.roll(interacting_spins[3], 1), 
                 np.roll(interacting_spins[4], 1), np.roll(interacting_spins[5], 1)]).T
  
  interacting_spins_sum = interacting_spins.sum(axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], 
                    h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins_sum[0])) * len([val for val in interacting_spins[:, 0] if val < 0]) - site_neighbors_mag_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins_sum[0] - site_neighbors_mag_sum
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins_sum[0])) * len([val for val in interacting_spins[:, 0] if val > 0]) - site_neighbors_mag_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * interacting_spins_sum[0] - site_neighbors_mag_sum
  
  return(priorities)




#score: {'data3D.txt': -0.2536602}
#standard deviation: 0.04718796812705544
#island_id: 3
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2]) - total_spin
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2]) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [3, 4, 5]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [3, 4, 5]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [3, 4, 5])
        
  return(priorities)




#score: {'data3D.txt': -0.4413570000000001}
#standard deviation: 0.043990643902993745
#island_id: 3
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_spin = J[0, i, j, site_nbr]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + site_nbr][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + site_nbr][1] = -len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.37995980000000007}
#standard deviation: 0.0499158999113509
#island_id: 3
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.3053566000000002}
#standard deviation: 0.05069084568677071
#island_id: 3
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors_site_nbr = [J[d, i, site_nbr, k] for d in [0, 1, 2]]
        total_neighbor_spin_site_nbr = sum(site_neighbors_site_nbr)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += total_spin + 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -total_spin - 2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': 0.0411534}
#standard deviation: 0.04641635604439452
#island_id: 3
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
        
        for d in range(6):
          site_neighbors.append(J[d, (i + ((k - 1) % 2 - 1)) % N, (j + ((d - 3) % 3 - 1)) % N, (k + ((d - 3) % 3 - 1)) % N])
        
        priorities[i * N * N + j * N + k][0] += -sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.0009694000000000007}
#standard deviation: 0.0470635950989722
#island_id: 3
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4569186}
#standard deviation: 0.04420754838305332
#island_id: 3
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        interacting_spins.sort()
        site_neighbors.sort()
        
        priorities[i*N*N+j*N+k][0] = np.sum((np.arange(3)-1)*interacting_spins)
        priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
  
  return(priorities)




#score: {'data3D.txt': -0.08061339999999999}
#standard deviation: 0.045671127207897996
#island_id: 2
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.14247859999999993}
#standard deviation: 0.046063464286134635
#island_id: 2
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += total_spin > 0
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= total_spin < 0
        
  return(priorities)




#score: {'data3D.txt': -0.005086200000000001}
#standard deviation: 0.04567558264061883
#island_id: 1
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.005086200000000001}
#standard deviation: 0.04567558264061883
#island_id: 1
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin

  return priorities




#score: {'data3D.txt': -0.043443800000000005}
#standard deviation: 0.04536327547212613
#island_id: 1
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.1426554}
#standard deviation: 0.0451496818464981
#island_id: 0
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors) + len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors) - len([val for val in x_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37983180000000005}
#standard deviation: 0.04540113113965334
#island_id: 0
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(x_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0007562000000000005}
#standard deviation: 0.047152848923050245
#island_id: 0
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors) - len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.29012940000000015}
#standard deviation: 0.04597829417931901
#island_id: 1
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr + (total_spin > 0) * 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr + (total_spin < 0) * 3
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1721578000000001}
#standard deviation: 0.04521965611501264
#island_id: 1
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin - site_nbr + (total_spin > 0) * 3
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin - site_nbr + (total_spin < 0) * 3
        
        # Add the priority based on the magnetism at the current site
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.29012940000000015}
#standard deviation: 0.04597829417931901
#island_id: 1
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr + (total_spin > 0) * 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr + (total_spin < 0) * 3
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.35179580000000005}
#standard deviation: 0.04950682076603183
#island_id: 3
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # new addition
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(J[d, i, j, k] for d in [0, 1, 2]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1, 2]) + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(J[d, i, j, k] for d in [0, 1, 2]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2]) - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1068518}
#standard deviation: 0.05231870178779286
#island_id: 3
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2365098}
#standard deviation: 0.04606696586448906
#island_id: 1
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
        
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
        
        # Add the priority based on the magnetism at the current site and its neighbors
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum
        
  return priorities




#score: {'data3D.txt': -0.29761180000000004}
#standard deviation: 0.04259173606182307
#island_id: 1
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_neighbors_mag_sum
          
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_neighbors_mag_sum
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
  return priorities




#score: {'data3D.txt': -0.4250398}
#standard deviation: 0.042837419809787794
#island_id: 1
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.30238940000000003}
#standard deviation: 0.04562606456445701
#island_id: 3
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        spin_sum = sum(J[d, i, j, k] for d in [3, 4, 5])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in [J[3, i, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
  return(priorities)




#score: {'data3D.txt': 0.3640966}
#standard deviation: 0.04716643794521694
#island_id: 3
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -sum(abs(val) for val in interacting_spins) - sum(abs(val) for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = total_spin + len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum(abs(val) for val in interacting_spins) - sum(abs(val) for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.08688780000000002}
#standard deviation: 0.046728745020169334
#island_id: 3
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_neighbor_spin = sum(site_neighbors)

        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.09559980000000003}
#standard deviation: 0.046067659371407194
#island_id: 3
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
          
          site_neighbors.sort()
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors.count(1) - 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
          
          site_neighbors.sort()
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbors.count(-1) - 1)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.0033818}
#standard deviation: 0.04694026362047831
#island_id: 2
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if total_spin + interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:d+1] if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + interacting_spins[d])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:d+1] if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + interacting_spins[d])
        
        return(priorities)




#score: {'data3D.txt': -0.47556780000000004}
#standard deviation: 0.04081208305342917
#island_id: 2
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3870718}
#standard deviation: 0.04243751930497352
#island_id: 0
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        total_site_neighbors = sum(site_neighbors)
        
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4421098}
#standard deviation: 0.04254384354944908
#island_id: 0
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2386622000000001}
#standard deviation: 0.04556672482371319
#island_id: 0
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][site_nbr] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4421098}
#standard deviation: 0.04254384354944908
#island_id: 0
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2485362}
#standard deviation: 0.04853203611595129
#island_id: 0
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4421098}
#standard deviation: 0.04254384354944908
#island_id: 0
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3202926}
#standard deviation: 0.0432791195062931
#island_id: 2
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.43681620000000004}
#standard deviation: 0.04021137970226837
#island_id: 2
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        site_priority = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += site_priority
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0025474}
#standard deviation: 0.04750891277686746
#island_id: 2
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -sum(J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6))
        priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.22299180000000002}
#standard deviation: 0.045857061100336556
#island_id: 1
#version_generated: 3
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
        
        # Add the priority based on the magnetism at the current site and its neighbors
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum
        
  return(priorities)




#score: {'data3D.txt': 0.3425942}
#standard deviation: 0.04720649961986167
#island_id: 1
#version_generated: 3
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum(J[d, i, j, k] for d in range(6))
        priorities[i*N*N + j*N + k][1] -= sum(J[d, i, j, k] for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.1801306}
#standard deviation: 0.04719369304938955
#island_id: 1
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin

        # Add the priority based on the magnetism at the current site and its neighbors
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum

        # Add the priority based on the interaction with nearest neighbors
        for d in [0, 1, 2]:
          neighbor_magnetism = h[(i+1)%N if d == 0 else (i-1+N)%N][j][k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_magnetism
          priorities[i * N * N + j * N + k][1] -= neighbor_magnetism

  return priorities




#score: {'data3D.txt': -0.305575}
#standard deviation: 0.04637036785491355
#island_id: 1
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
        
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum
        
  return priorities




#score: {'data3D.txt': -0.2467722}
#standard deviation: 0.04437112920762779
#island_id: 1
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
          
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_mag_sum - total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum
        
  return priorities




#score: {'data3D.txt': 0.2353518000000003}
#standard deviation: 0.046873142381965396
#island_id: 1
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin - site_nbr
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin - site_nbr
        
  return priorities




#score: {'data3D.txt': -0.3297306}
#standard deviation: 0.048552342308481884
#island_id: 1
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
  
  return priorities




#score: {'data3D.txt': -0.3693714}
#standard deviation: 0.045565761071664324
#island_id: 1
#version_generated: 3
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.13750700000000002}
#standard deviation: 0.04563992584349803
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][site_nbr] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * 1
        elif h[i][j][site_nbr] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.18368460000000028}
#standard deviation: 0.04654764272055031
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.3202926}
#standard deviation: 0.0432791195062931
#island_id: 2
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3202926}
#standard deviation: 0.0432791195062931
#island_id: 2
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3202926}
#standard deviation: 0.0432791195062931
#island_id: 2
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3202926}
#standard deviation: 0.0432791195062931
#island_id: 2
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0861026}
#standard deviation: 0.05138357552019906
#island_id: 2
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])))*(len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])))*(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])))*(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] += sum(J[d, i, j, k] for d in [0, 1])
        
  return(priorities)




#score: {'data3D.txt': -0.10848300000000008}
#standard deviation: 0.04833859194267041
#island_id: 2
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.3071254}
#standard deviation: 0.04459509743054723
#island_id: 3
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          for spin in site_neighbors:
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
          for spin in site_neighbors:
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.022466200000000002}
#standard deviation: 0.04589887555877594
#island_id: 1
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  # Initialize priorities matrix with zeros
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.2733901999999999}
#standard deviation: 0.044701185039772724
#island_id: 1
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        neighbor_spins = [J[0, i, j, (k - 1) % N], J[1, (i - 1) % N, j, k], J[2, i, (j - 1) % N, k]]
        total_neighbor_spin -= sum(val for val in neighbor_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - sum(J[d, i, j, k] for d in [0, 1, 2])
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.07185340000000001}
#standard deviation: 0.047034240170752195
#island_id: 1
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin - site_nbr
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.32403020000000005}
#standard deviation: 0.04187788733878537
#island_id: 1
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.17023580000000002}
#standard deviation: 0.04906290858031147
#island_id: 1
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add the priority based on the magnetism at the current site and its neighbors
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum

  return priorities




#score: {'data3D.txt': -0.32403020000000005}
#standard deviation: 0.04187788733878537
#island_id: 1
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.32403020000000005}
#standard deviation: 0.04187788733878537
#island_id: 1
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.373367}
#standard deviation: 0.0477716961285655
#island_id: 1
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (total_spin + total_site_neighbors) / 2
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (total_spin + total_site_neighbors) / 2
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_site_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_site_neighbors
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_site_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.39686699999999997}
#standard deviation: 0.04671943269133306
#island_id: 1
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_site_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4408918}
#standard deviation: 0.04259939920656159
#island_id: 0
#version_generated: 3
#generate time11:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in [J[2, i, j, k - 1]] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in [J[2, i, j, k - 1]] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.5680618}
#standard deviation: 0.0405232789981265
#island_id: 0
#version_generated: 3
#generate time11:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0032022000000000005}
#standard deviation: 0.046943269114538666
#island_id: 0
#version_generated: 3
#generate time11:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.019167}
#standard deviation: 0.0469633745699774
#island_id: 0
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
        # Add the magnetization term
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add the magnetization term for site neighbor
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.2255502000000004}
#standard deviation: 0.047130674936393606
#island_id: 0
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.11391659999999999}
#standard deviation: 0.04915125435266124
#island_id: 0
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,j,k-1], J[1,i,N-1,k-1]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k-1] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.18368460000000028}
#standard deviation: 0.04654764272055031
#island_id: 0
#version_generated: 3
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.3838098}
#standard deviation: 0.049725120653046184
#island_id: 1
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) + sum(site_neighbors))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) + sum(site_neighbors))
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2788610000000001}
#standard deviation: 0.04637681747381983
#island_id: 1
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr + (total_spin > 0) * 3 + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr + (total_spin < 0) * 3 - h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.29012940000000015}
#standard deviation: 0.04597829417931901
#island_id: 1
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]

        site_nbr_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - abs(sum(J[d, i, j, k] for d in [0, 1, 2])) + site_nbr_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - site_nbr_sum + (sum(J[d, i, j, k] for d in [0, 1, 2]) > 0) * 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - abs(sum(J[d, i, j, k] for d in [0, 1, 2])) + site_nbr_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - site_nbr_sum + (sum(J[d, i, j, k] for d in [0, 1, 2]) < 0) * 3
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.11391659999999999}
#standard deviation: 0.04915125435266124
#island_id: 0
#version_generated: 3
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,j,k-1], J[1,i,N-1,k-1]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k-1] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.11391659999999999}
#standard deviation: 0.04915125435266124
#island_id: 0
#version_generated: 3
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,j,k-1], J[1,i,N-1,k-1]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k-1] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.24400100000000033}
#standard deviation: 0.04406363715128383
#island_id: 0
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors += [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
          
        else:
          priorities[i * N * N + j * N + k][0] = -sum([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors += [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
          
        priorities[i * N * N + j * N + k][0] += sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4725534}
#standard deviation: 0.04088782249570158
#island_id: 0
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val == total_spin])
        
  return(priorities)




#score: {'data3D.txt': -0.002851}
#standard deviation: 0.04696130917042241
#island_id: 0
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N+k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N+k][1] = -2 + 2 * total_neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0032257999999999996}
#standard deviation: 0.046933506307967235
#island_id: 0
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[d, i + (d - 1) % 2, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.0030158000000000008}
#standard deviation: 0.04698862447827134
#island_id: 0
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N+k][1] += 1
          else:
            priorities[i * N * N + j * N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N+k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N+k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.5689174}
#standard deviation: 0.04285095398284617
#island_id: 0
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.006040200000000006}
#standard deviation: 0.04589650906071179
#island_id: 1
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.395213}
#standard deviation: 0.04748128169078843
#island_id: 1
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors.count(1) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors.count(1) / 2
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_neighbor_spin
  
  return priorities




#score: {'data3D.txt': -0.005086200000000001}
#standard deviation: 0.04567558264061883
#island_id: 1
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_nbr
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.3199478}
#standard deviation: 0.043327791948817335
#island_id: 2
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3202926}
#standard deviation: 0.0432791195062931
#island_id: 2
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4109514}
#standard deviation: 0.04307944937020435
#island_id: 2
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': 0.08391180000000002}
#standard deviation: 0.0462675871508338
#island_id: 0
#version_generated: 3
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(h, -1, axis=0), 
             np.roll(h, -1, axis=1)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        for d in [0, 1, 2]:
          interacting_spins[d][i,j,k] += -J[d, i, j, k]*site_spin
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.18368460000000028}
#standard deviation: 0.04654764272055031
#island_id: 0
#version_generated: 3
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.25592980000000004}
#standard deviation: 0.04466404719637485
#island_id: 0
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][site_nbr] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum([val for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif sum([val for val in site_neighbors]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.19190780000000002}
#standard deviation: 0.043745234473711536
#island_id: 0
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        spin_sum = sum([val for val in interacting_spins + site_neighbors if val > 0]) - sum([val for val in interacting_spins + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (spin_sum + len([val for val in interacting_spins if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][site_nbr] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.42121379999999997}
#standard deviation: 0.0441826274632915
#island_id: 3
#version_generated: 3
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1, 2])
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2975974}
#standard deviation: 0.048790888834289545
#island_id: 3
#version_generated: 3
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_neighbor_spin = sum(site_neighbors)
        
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (-total_spin - len([val for val in interacting_spins if val < 0]) - total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) - total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (total_spin - len([val for val in interacting_spins if val < 0]) - total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (-total_spin - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5079642000000001}
#standard deviation: 0.04230590075107727
#island_id: 2
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                 J[1, i, (j + 1) % N, k], 
                 J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        site_neighbors = []

        for d in [0, 1, 2]:
          total_spin += J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])

        interacting_spins.sort()

        for spin in [-1, 1]:
          if total_spin < 0:
            priority = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          else:
            priority = -np.exp(abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin

          priorities[i * N * N + j * N + k][0] += spin * (1 - np.tanh(priority))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin

  return(priorities)




#score: {'data3D.txt': -0.47889660000000017}
#standard deviation: 0.04313158365328127
#island_id: 2
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        site_neighbors = []

        for d in [0, 1, 2]:
          total_spin += J[d, i, j, k]
          interacting_spins.append(J[d, i, j, k])
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])

        site_neighbors.sort()

        for l in [0, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.35842579999999996}
#standard deviation: 0.046839097497283176
#island_id: 3
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-total_spin)
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin)
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin))
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.14003660000000012}
#standard deviation: 0.04906264954565744
#island_id: 2
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (-1)**d for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10848300000000008}
#standard deviation: 0.04833859194267041
#island_id: 2
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val > 0])
        
        # add more spin interactions here...
  
  return(priorities)




#score: {'data3D.txt': 0.021198199999999993}
#standard deviation: 0.05006557576578941
#island_id: 1
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_neighbors_mag_sum
        
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - site_neighbors_mag_sum
        
        # Add the priority based on the magnetism at the current site and its neighbors
        site_magnetism = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_magnetism - 1)
        priorities[i * N * N + j * N + k][1] -= site_magnetism - 1
        
  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.45610619999999996}
#standard deviation: 0.04278587479016878
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0031969999999999998}
#standard deviation: 0.04700086244953384
#island_id: 2
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = []
        for d in range(3):
          interacting_spins.append(J[d, i, (j + d % N) % N, k])
          interacting_spins.append(J[d, (i + d % N) % N, j, k])
          interacting_spins.append(J[d, i, j, (k + d % N) % N])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.2473394000000001}
#standard deviation: 0.043555970975745685
#island_id: 2
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1743942000000004}
#standard deviation: 0.051809215457870046
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.13339380000000017}
#standard deviation: 0.04332667171108347
#island_id: 1
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(total_neighbor_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin - site_nbr
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - abs(total_neighbor_spin) - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin - site_nbr
        
  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.11412420000000009}
#standard deviation: 0.046460147808202255
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.1743942000000004}
#standard deviation: 0.051809215457870046
#island_id: 3
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1743942000000004}
#standard deviation: 0.051809215457870046
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d][i][j][k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2][i][j][k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i+d][j][k]
          else:
            neighbor_spin = J[1-d][i-d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i+d][j][k]
          else:
            neighbor_spin = J[1-d][i-d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.437247}
#standard deviation: 0.05169863432432234
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.35518700000000003}
#standard deviation: 0.046837092469537434
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the same spin in all directions
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 4
        
        # Add a new term based on the number of nearest neighbors with the opposite spin in all directions
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 4
  
  return(priorities)




#score: {'data3D.txt': -0.1884914000000002}
#standard deviation: 0.046631456400588654
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4498294}
#standard deviation: 0.04429535568928192
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site interaction with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.41125220000000023}
#standard deviation: 0.04461568821793518
#island_id: 2
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.40025380000000027}
#standard deviation: 0.04718720192552213
#island_id: 2
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
        
        # Add priority based on the spin of the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4817066000000002}
#standard deviation: 0.04507949197184902
#island_id: 2
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+n) % N, j, k] for d in [0, 1, 2] for n in [-1, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+n) % N, j, k] for n in [-1, 1]] + [J[1, i, (j+m) % N, k] for m in [-1, 1]] + [J[2, i, j, (k+p) % N] for p in [-1, 1]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3826910000000003}
#standard deviation: 0.04864443975420006
#island_id: 2
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k - 1) % 2 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, (k + ((d - 2) % 3 - 1)) % N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d][i][j][k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4334334000000002}
#standard deviation: 0.04353068118511356
#island_id: 2
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
        
        if h[i][j][k] == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != 0]) / abs(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != 0]) / abs(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3676726000000001}
#standard deviation: 0.04747866014579603
#island_id: 2
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
        
        if i < N // 2 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif i >= N // 2 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if i < N // 2 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        elif i >= N // 2 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3897494000000003}
#standard deviation: 0.04849212430529312
#island_id: 2
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbor_spin = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) - site_neighbor_spin

        site_nbr_spin = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], site_nbr, j, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[[0, 1, 2], site_nbr, j, k] if val > 0]) - site_nbr_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], site_nbr, j, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in J[[0, 1, 2], site_nbr, j, k] if val < 0]) - site_nbr_spin

  return(priorities)




#score: {'data3D.txt': -0.0028662000000000006}
#standard deviation: 0.04698016493755636
#island_id: 0
#version_generated: 3
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2859298}
#standard deviation: 0.04967134215984102
#island_id: 1
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 2 * total_neighbor_spin
          
  return priorities




#score: {'data3D.txt': -0.1587229999999999}
#standard deviation: 0.04686823008179422
#island_id: 2
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += total_spin > 0
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= total_spin < 0
        
  return(priorities)




#score: {'data3D.txt': -0.07828619999999986}
#standard deviation: 0.047180710990403704
#island_id: 2
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          interacting_spins.append(neighbor_spin)
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += total_spin > 0
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= total_spin < 0
        
  return(priorities)




#score: {'data3D.txt': 0.018253400000000124}
#standard deviation: 0.04646938678786283
#island_id: 2
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [J[0, i, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin += sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += total_spin > 0
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= total_spin < 0
  
  return(priorities)




#score: {'data3D.txt': -0.1995209999999999}
#standard deviation: 0.04593450423156868
#island_id: 2
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += total_spin > 0
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= total_spin < 0

  return(priorities)




#score: {'data3D.txt': -0.37947420000000004}
#standard deviation: 0.055393506969319065
#island_id: 3
#version_generated: 3
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2796446}
#standard deviation: 0.05273783358121568
#island_id: 3
#version_generated: 3
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.12102380000000014}
#standard deviation: 0.05300472237036999
#island_id: 3
#version_generated: 3
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the number of nearest neighbors with opposite spin
        neighbor_opposite_spins = len([val for val in [J[0, i+1 if i+1<N else (i+1)%N, j, k], J[0, i, j+1 if j+1<N else (j+1)%N, k], 
                          J[0, i-1 if i>0 else (i-1+N)%N, j, k], J[0, i, j-1 if j>0 else (j-1+N)%N, k],
                          J[1, i, j+1 if j+1<N else (j+1)%N, k], J[1, i, j-1 if j>0 else (j-1+N)%N, k],
                         J[2, i, j, k-1 if k>0 else (k-1+N)%N]] if val < 0])
        
        # Calculate the number of nearest neighbors with same spin
        neighbor_same_spins = len([val for val in [J[0, i+1 if i+1<N else (i+1)%N, j, k], J[0, i, j+1 if j+1<N else (j+1)%N, k], 
                          J[0, i-1 if i>0 else (i-1+N)%N, j, k], J[0, i, j-1 if j>0 else (j-1+N)%N, k],
                          J[1, i, j+1 if j+1<N else (j+1)%N, k], J[1, i, j-1 if j>0 else (j-1+N)%N, k],
                         J[2, i, j, k-1 if k>0 else (k-1+N)%N]] if val > 0])
        
        # Calculate the total spin of the site's neighbors
        neighbor_total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_opposite_spins - neighbor_same_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-neighbor_opposite_spins + neighbor_same_spins)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33644939999999995}
#standard deviation: 0.04918482936475433
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1, 2]:
          site_neighbors[d] += J[d, (i + 1) % N if d == 0 else i, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors[d])) * len([val for val in site_neighbors[:d] if val < 0]) - site_neighbors[d]
          
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
        
  return priorities




#score: {'data3D.txt': -0.4139642}
#standard deviation: 0.04549656996258069
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin) + sum([J[d, i, j, k] * J[d, i, (j + 1) % N, k] if d != 0 else 0 for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin) + sum([J[d, i, j, k] * J[d, i, (j + 1) % N, k] if d != 0 else 0 for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin) + sum([J[d, i, j, k] * J[d, i, (j + 1) % N, k] if d != 0 else 0 for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.387279}
#standard deviation: 0.044603572491449604
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4250398}
#standard deviation: 0.042837419809787794
#island_id: 1
#version_generated: 3
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.28902580000000017}
#standard deviation: 0.04429337844825114
#island_id: 2
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k - 1) % 2 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, (k + ((d - 2) % 3 - 1)) % N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in range(6):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.004350199999999999}
#standard deviation: 0.04721808848269909
#island_id: 2
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:, i, j, k] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3826910000000003}
#standard deviation: 0.04864443975420006
#island_id: 2
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k - 1) % 2 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, (k + ((d - 2) % 3 - 1)) % N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.3838098}
#standard deviation: 0.049725120653046184
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) + sum(site_neighbors))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) + sum(site_neighbors))
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3838098}
#standard deviation: 0.049725120653046184
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) + sum(site_neighbors))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) + sum(site_neighbors))
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3838098}
#standard deviation: 0.049725120653046184
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) + sum(site_neighbors))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) + sum(site_neighbors))
        
        # Add the priority based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.48313180000000017}
#standard deviation: 0.04368204698454503
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+n) % N, j, k] for n in [-1, 1]] + \
                   [J[1, i, (j+m) % N, k] for m in [-1, 1]] + \
                   [J[2, i, j, (k+p) % N] for p in [-1, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, (i+n) % N, j, k] for n in [-1, 1]] + \
                 [J[1, i, (j+m) % N, k] for m in [-1, 1]] + \
                 [J[2, i, j, (k+p) % N] for p in [-1, 1]]

        site_neighbors.sort()

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.48313180000000017}
#standard deviation: 0.04368204698454503
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+n) % N, j, k] for n in [-1, 1]] + [J[1, i, (j+m) % N, k] for m in [-1, 1]] + [J[2, i, j, (k+p) % N] for p in [-1, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+n) % N, j, k] for n in [-1, 1]] + [J[1, i, (j+m) % N, k] for m in [-1, 1]] + [J[2, i, j, (k+p) % N] for p in [-1, 1]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0899006}
#standard deviation: 0.04538221148908458
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.42360140000000013}
#standard deviation: 0.05060214025157434
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+n) % N, j, k] for n in [-1, 1]] + [J[1, i, (j+m) % N, k] for m in [-1, 1]] + [J[2, i, j, (k+p) % N] for p in [-1, 1]]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3693714}
#standard deviation: 0.045565761071664324
#island_id: 1
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.3693714}
#standard deviation: 0.045565761071664324
#island_id: 1
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.31877980000000006}
#standard deviation: 0.05054911939846233
#island_id: 3
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4174174000000003}
#standard deviation: 0.04596101888818393
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.060384999999999994}
#standard deviation: 0.04468287071126921
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(neighbor_spin_sum)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * abs(neighbor_spin_sum)
          priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.4174174000000003}
#standard deviation: 0.04596101888818393
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.17477460000000003}
#standard deviation: 0.04484665377528184
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.17023580000000002}
#standard deviation: 0.04906290858031147
#island_id: 1
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum

  return priorities




#score: {'data3D.txt': -0.12957619999999997}
#standard deviation: 0.04980833698850023
#island_id: 1
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

        # Add the priority based on the magnetism at the current site and its neighbors
        site_neighbors_mag = [h[(i+1)%N][j][k], h[(i-1+N)%N][j][k], h[i][(j+1)%N][k], h[i][(j-1+N)%N][k], h[i][j][(k+1)%N], h[i][j][(k-1+N)%N]]
        site_neighbors_mag_sum = sum(site_neighbors_mag)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_mag_sum
        priorities[i * N * N + j * N + k][1] -= site_neighbors_mag_sum

  return priorities




#score: {'data3D.txt': -0.27390459999999994}
#standard deviation: 0.04698954754879004
#island_id: 1
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in [0, 1, 2]:
          if d == 0:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[1, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[2, i, j, (k + 1) % N])
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

        # Adjust the priority based on the interactions between neighboring sites
        for d in [0, 1, 2]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i+1)%N, j, k]
            priorities[i * N * N + j * N + k][1] -= J[d, (i+1)%N, j, k]

          elif d == 1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, (j+1)%N, k]
            priorities[i * N * N + j * N + k][1] -= J[d, i, (j+1)%N, k]

          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, j, (k+1)%N]
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, (k+1)%N]

  return priorities




#score: {'data3D.txt': -0.1167802000000001}
#standard deviation: 0.05139364209666408
#island_id: 2
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k,0] += np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i*N*N + j*N + k,1] = -2
        else:
          priorities[i*N*N + j*N + k,0] -= np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i*N*N + j*N + k,1] = 2
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k,0] += np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i*N*N + j*N + k,1] -= len([val for val in site_neighbors if val < 0])
        else:
          priorities[i*N*N + j*N + k,0] -= np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i*N*N + j*N + k,1] = -len([val for val in site_neighbors if val > 0])
        
        diagonal_neighbors = [J[3,i,j,k], J[4,(i+1)%N,(j+1)%N,k], J[5,(i+1)//N,(j+1)//N,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k,0] += np.exp(-sum(abs(val) for val in diagonal_neighbors))
          priorities[i*N*N + j*N + k,1] -= len([val for val in diagonal_neighbors if val < 0])
        else:
          priorities[i*N*N + j*N + k,0] -= np.exp(-sum(abs(val) for val in diagonal_neighbors))
          priorities[i*N*N + j*N + k,1] = -len([val for val in diagonal_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10848300000000008}
#standard deviation: 0.04833859194267041
#island_id: 2
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in site_neighbors))
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3223069999999998}
#standard deviation: 0.04502203672647428
#island_id: 2
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k],
                   J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N],
                  J[3, (i+1)%N, (j+1)%N, k], J[4, i, (j+1)%N, (k+1)%N], J[5, (i+1)%N, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins)))) - np.sum(np.exp(-np.abs(np.array(site_neighbors))))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-np.abs(np.array(interacting_spins)))) + np.sum(np.exp(-np.abs(np.array(site_neighbors))))
          priorities[i * N * N + j * N + k][1] = 2
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.38582540000000004}
#standard deviation: 0.04376743303919022
#island_id: 3
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2, i, j, k], *site_neighbors] if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2, i, j, k], *site_neighbors] if val > 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.25104220000000016}
#standard deviation: 0.043457195712102735
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        site_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in site_neighbors])
        edge_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in edge_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * site_neighbor_spins
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * site_neighbor_spins
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3596142000000001}
#standard deviation: 0.04226633741359666
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        edge_neighbors.sort()
        
        for d, neighbor in enumerate(edge_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.22735460000000035}
#standard deviation: 0.04743325477805628
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        for d in range(3):
          site_neighbor_spin = site_neighbors[d]
          edge_neighbor_spin = edge_neighbors[d]
          
          if site_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif site_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
          
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.24514340000000023}
#standard deviation: 0.0446017375944032
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        edge_neighbors = [J[d, (i+1)%N if d == 0 else i-1 if d == 2 else i, j, k] for d in range(3)]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = total_spin - np.sum(np.exp(-np.abs(interacting_spins)) * np.sign(interacting_spins))
          priorities[i*N*N + j*N + k][1] = -2
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin + np.sum(np.exp(-np.abs(interacting_spins)) * np.sign(interacting_spins))
          priorities[i*N*N + j*N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N + j*N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N + j*N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35956419999999994}
#standard deviation: 0.04044911616290274
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.237525}
#standard deviation: 0.04662688939871499
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
    
  return(priorities)




#score: {'data3D.txt': -0.17477460000000003}
#standard deviation: 0.04484665377528184
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        site_neighbor_spin = sum(site_neighbors)
        edge_neighbor_spin = sum(edge_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0919786}
#standard deviation: 0.04637099591382527
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        site_neighbor_spin = sum(site_neighbors)
        edge_neighbor_spin = sum(edge_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * abs(site_neighbor_spin) - np.exp(-abs(total_spin)) * abs(edge_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.exp(-abs(total_spin)) * abs(site_neighbor_spin) - np.exp(-abs(total_spin)) * abs(edge_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.09261259999999999}
#standard deviation: 0.04365269523454422
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        spin_product = np.prod([val > 0 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # new term
        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif spin_product == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.17477460000000003}
#standard deviation: 0.04484665377528184
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2

        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.25708339999999996}
#standard deviation: 0.046006896487809305
#island_id: 1
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        priorities[i * N * N + j * N + k][1] = 2 - total_spin

  return priorities




#score: {'data3D.txt': -0.5479138}
#standard deviation: 0.039583065691782895
#island_id: 1
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49172180000000004}
#standard deviation: 0.04429817157355369
#island_id: 1
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1052834}
#standard deviation: 0.0449052411689326
#island_id: 0
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        spin_product = np.prod([val > 0 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # new term
        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif spin_product == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
        
        # additional term
        if np.prod([val < 0 for val in interacting_spins]) > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        elif np.prod([val > 0 for val in interacting_spins]) > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.033727400000000005}
#standard deviation: 0.04445743547754414
#island_id: 0
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        spin_product = np.prod([val > 0 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # new term
        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif spin_product == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
        
        # new term
        spin_product_site = np.prod([val > 0 for val in site_neighbors])
        if spin_product_site > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif spin_product_site == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.033727400000000005}
#standard deviation: 0.04445743547754414
#island_id: 0
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        spin_product = np.prod([val > 0 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # new term
        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif spin_product == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
        
        # new term
        if np.prod([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
        elif np.prod([val > 0 for val in site_neighbors]) == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2998478}
#standard deviation: 0.04534011022439183
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the second nearest neighbors' spins
        site_second_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_second_neighbors if val < 0]) - len([val for val in site_second_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_second_neighbors if val < 0]) - len([val for val in site_second_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35956419999999994}
#standard deviation: 0.04044911616290274
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a term based on the number of nearest neighbors with same spin
        same_neighbors = sum(1 for val in site_neighbors if val > 0 if h[i][j][k] > 0 or val < 0 if h[i][j][k] < 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_neighbors
        priorities[i * N * N + j * N + k][1] -= same_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.35956419999999994}
#standard deviation: 0.04044911616290274
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.3172858}
#standard deviation: 0.04019526686514222
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23699900000000007}
#standard deviation: 0.04736911439957472
#island_id: 0
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[0] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          if J[1, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[1, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[0] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if J[1, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif J[1, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.45610619999999996}
#standard deviation: 0.04278587479016878
#island_id: 0
#version_generated: 3
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -site_spin
          priorities[i * N * N + j * N + k][1] = 2 - site_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = site_spin
          priorities[i * N * N + j * N + k][1] = -2 + site_spin
        else:
          if np.sum([spin * abs(spin) for spin in interacting_spins]) > 0 and site_neighbors.count(0) > 0:
            priorities[i * N * N + j * N + k][0] = -site_spin
            priorities[i * N * N + j * N + k][1] = 2 - site_spin
          elif np.sum([spin * abs(spin) for spin in interacting_spins]) > 0 and site_neighbors.count(0) == 0:
            priorities[i * N * N + j * N + k][0] = site_spin
            priorities[i * N * N + j * N + k][1] = -2 + site_spin

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        def get_priority(spin):
          return total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0) if spin == 1 else 2 - total_spin

        priorities[i * N * N + j * N + k] = minimize(get_priority, [0.5]).x.tolist()

  return priorities




#score: {'data3D.txt': 0.17093580000000022}
#standard deviation: 0.04652566515763102
#island_id: 1
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -site_spin
          priorities[i * N * N + j * N + k][1] = 2 - site_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = site_spin
          priorities[i * N * N + j * N + k][1] = -2 + site_spin
        else:
          if np.sum([spin * abs(spin) for spin in interacting_spins]) > 0 and site_neighbors.count(0) > 0:
            priorities[i * N * N + j * N + k][0] = -site_spin
            priorities[i * N * N + j * N + k][1] = 2 - site_spin
          elif np.sum([spin * abs(spin) for spin in interacting_spins]) > 0 and site_neighbors.count(0) == 0:
            priorities[i * N * N + j * N + k][0] = site_spin
            priorities[i * N * N + j * N + k][1] = -2 + site_spin

  return priorities




#score: {'data3D.txt': 0.17093580000000022}
#standard deviation: 0.04652566515763102
#island_id: 1
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] = total_spin - np.sum([spin*abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k]>0:
          priorities[i*N*N+j*N+k][1] += 2-2*total_spin
        else:
          priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return priorities




#score: {'data3D.txt': 0.17093580000000022}
#standard deviation: 0.04652566515763102
#island_id: 1
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.39723260000000005}
#standard deviation: 0.03974386012002357
#island_id: 1
#version_generated: 3
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        priorities[i * N * N + j * N + k][1] = 2 - total_spin

        for d in range(3):
          if i > 0:
            neighbor_spin = J[3 + (d-1) % 3, i-1, j, k]
          elif i < N-1:
            neighbor_spin = J[3 + (d-1) % 3, i+1, j, k]
          else:
            neighbor_spin = 0
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.25708339999999996}
#standard deviation: 0.046006896487809305
#island_id: 1
#version_generated: 3
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_sites = sum([spin * abs(spin) for spin in interacting_spins]) + site_neighbors.count(0)

        priorities[i * N * N + j * N + k][0] = total_spin - interacting_sites
        priorities[i * N * N + j * N + k][1] = 2 - total_spin

  return priorities




#score: {'data3D.txt': -0.1676470000000002}
#standard deviation: 0.04497748938080027
#island_id: 1
#version_generated: 3
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.13814100000000032}
#standard deviation: 0.0490070680514556
#island_id: 0
#version_generated: 3
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        edge_neighbors = [J[d, (i+1)%N if d == 0 else i-1 if d == 2 else i, j, k] for d in range(3)]
        
        site_priority = total_spin - np.sum(np.exp(-np.abs(interacting_spins)) * np.sign(interacting_spins))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = site_priority
          priorities[i*N*N + j*N + k][1] = -2
        else:
          priorities[i*N*N + j*N + k][0] = -site_priority
          priorities[i*N*N + j*N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N + j*N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N + j*N + k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.sum(np.exp(-np.abs(interacting_spins)) * np.sign(interacting_spins))
          priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': -0.18603019999999998}
#standard deviation: 0.04553593930029335
#island_id: 0
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        edge_neighbors = [J[d, (i+1)%N if d == 0 else i-1 if d == 2 else i, j, k] for d in range(3)]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i*N*N + j*N + k][0] = -total_spin + np.sum(np.exp(-np.abs(interacting_spins)) * np.sign(interacting_spins))
          priorities[i*N*N + j*N + k][1] = 2
        else:
          priorities[i*N*N + j*N + k][0] = total_spin - np.sum(np.exp(-np.abs(interacting_spins)) * np.sign(interacting_spins))
          priorities[i*N*N + j*N + k][1] = -2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N + j*N + k][1] -= len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N + j*N + k][1] -= len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i*N*N + j*N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.417089}
#standard deviation: 0.04047802908986552
#island_id: 2
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + h[site_nbr][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + h[site_nbr][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.46880219999999995}
#standard deviation: 0.04078823697047961
#island_id: 2
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.327835}
#standard deviation: 0.05121708713896174
#island_id: 2
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin) + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin) - len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.3172858}
#standard deviation: 0.04019526686514222
#island_id: 2
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.37506259999999997}
#standard deviation: 0.040074232634449786
#island_id: 2
#version_generated: 3
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        site_neighbors += [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.31877980000000006}
#standard deviation: 0.05054911939846233
#island_id: 3
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])) - len([val for val in interacting_spins if val < 0]) - sum(val for val in site_neighbors if val > 0))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])) - len([val for val in interacting_spins if val < 0]) - sum(val for val in site_neighbors if val > 0))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])) - len([val for val in interacting_spins if val > 0]) - sum(val for val in site_neighbors if val < 0))
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])) - len([val for val in interacting_spins if val > 0]) - sum(val for val in site_neighbors if val < 0))
  
  return(priorities)




#score: {'data3D.txt': -0.28855460000000005}
#standard deviation: 0.0399298271826964
#island_id: 2
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        site_neighbors += [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the interactions between neighboring sites and the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[(i+1)%N][j][k] + h[(i-1)%N][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[(i+1)%N][j][k] + h[(i-1)%N][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.4352698}
#standard deviation: 0.04839490931864632
#island_id: 2
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin) - len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.15932979999999997}
#standard deviation: 0.042947775634600685
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]) 
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        site_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in site_neighbors])
        edge_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in edge_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * site_neighbor_spins
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * site_neighbor_spins
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.18500380000000005}
#standard deviation: 0.04192316049106985
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        site_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in site_neighbors])
        edge_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in edge_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * site_neighbor_spins
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * site_neighbor_spins
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        for d in range(3):
          site_neighbor = site_neighbors[d]
          if site_neighbor > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
          elif site_neighbor < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.19475660000000014}
#standard deviation: 0.04453490492231908
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[d, (i + 1) % N if d == 0 else i - 1 if d == 2 else i, j, k] for d in range(3)]
        
        site_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in site_neighbors])
        edge_neighbor_spins = sum([1 if neighbor > 0 else -1 for neighbor in edge_neighbors])
        
        site_magnetism = h[i][j][k]
        total_spin += site_magnetism
        
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(3):
          edge_neighbor_spin = edge_neighbors[d]
          if edge_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          elif edge_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.437247}
#standard deviation: 0.05169863432432234
#island_id: 3
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.478019}
#standard deviation: 0.041131579096844804
#island_id: 1
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4864038}
#standard deviation: 0.04268684979662941
#island_id: 1
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with zero spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4251846}
#standard deviation: 0.05069378071164154
#island_id: 1
#version_generated: 3
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.44003980000000004}
#standard deviation: 0.050187789510597096
#island_id: 3
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        def get_priority(spin):
          return total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0) if spin == 1 else 2 - total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k] = minimize(get_priority, [0.5]).x.tolist()
        else:
          priorities[i * N * N + j * N + k] = [-p for p in minimize(get_priority, [-0.5]).x.tolist()]
  
  return priorities




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        def get_priority(spin):
          return np.exp(-abs(total_spin)) * sum([1 if spin * val < 0 else 0 for val in interacting_spins]) + total_spin - site_neighbors.count(0)

        priorities[i * N * N + j * N + k] = [get_priority(1), get_priority(-1)]

  return priorities




#score: {'data3D.txt': -0.28072100000000005}
#standard deviation: 0.04673877832164637
#island_id: 2
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.1399914}
#standard deviation: 0.04731849581337091
#island_id: 2
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - d)
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - d
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - d)
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - d
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.237525}
#standard deviation: 0.04662688939871499
#island_id: 2
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
  return(priorities)




#score: {'data3D.txt': -0.28072100000000005}
#standard deviation: 0.04673877832164637
#island_id: 2
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.2296990000000001}
#standard deviation: 0.04553421306007166
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        site_nbr = (i + ((k - 1) % 2))
        if site_nbr < N:
          for d in [0, 1]:
            if J[d, i, j, site_nbr] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif J[d, i, j, site_nbr] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.28072100000000005}
#standard deviation: 0.04673877832164637
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return priorities




#score: {'data3D.txt': -0.10214220000000004}
#standard deviation: 0.04931491517948704
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        site_nbr = (i + ((k - 1) % N)) % N
        while site_nbr != i:
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          site_nbr = (site_nbr + ((k - 1) % N)) % N
        
  return priorities




#score: {'data3D.txt': -0.28072100000000005}
#standard deviation: 0.04673877832164637
#island_id: 2
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors.sort()

        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.24677460000000007}
#standard deviation: 0.045580300512831205
#island_id: 2
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [J[d, i, (j + 1) % N, k] for d in [0, 1]] + [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, val in enumerate(site_neighbors):
          if val < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d % 2)
            priorities[i * N * N + j * N + k][1] -= (d % 2)
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.151295}
#standard deviation: 0.0466347464343916
#island_id: 2
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]] + [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d // 3)
            priorities[i * N * N + j * N + k][1] -= d // 3
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d // 3)
            priorities[i * N * N + j * N + k][1] += d // 3
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
    
  return(priorities)




#score: {'data3D.txt': -0.1400198}
#standard deviation: 0.04689969432693565
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            if J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
              priorities[i * N * N + j * N + k][1] -= 1
            elif J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.27781260000000035}
#standard deviation: 0.04498871726599903
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d == 0)
            priorities[i * N * N + j * N + k][1] -= (d == 0)
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d == len(site_neighbors) - 1)
            priorities[i * N * N + j * N + k][1] += (d == len(site_neighbors) - 1)
  
  return(priorities)




#score: {'data3D.txt': -0.4782746000000001}
#standard deviation: 0.04400863454868829
#island_id: 3
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        site_neighbors.append(J[2, i, (j + 1) % N, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1743942000000004}
#standard deviation: 0.051809215457870046
#island_id: 3
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1743942000000004}
#standard deviation: 0.051809215457870046
#island_id: 3
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          site_neighbors.append(J[2, i, (j + 1) % N, k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        def get_priority(spin):
          return total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k, 1] = minimize(get_priority, [1]).x[0]
          priorities[i * N * N + j * N + k, 0] = -priorities[i * N * N + j * N + k, 1]
        else:
          priorities[i * N * N + j * N + k, 0] = minimize(get_priority, [-1]).x[0]
          priorities[i * N * N + j * N + k, 1] = -priorities[i * N * N + j * N + k, 0]

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        def get_priority(spin):
          return total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k] = [max(get_priority(1), get_priority(-1))]
        else:
          priorities[i * N * N + j * N + k] = [min(get_priority(1), get_priority(-1))]
  
  return priorities




#score: {'data3D.txt': -0.10214220000000004}
#standard deviation: 0.04931491517948704
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        site_nbr = (i + ((k - 1) % N)) % N
        while site_nbr != i:
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          site_nbr = (site_nbr + ((k - 1) % N)) % N
        
  return priorities




#score: {'data3D.txt': -0.1729702000000002}
#standard deviation: 0.046362544709711524
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_up = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priority_down = -total_spin
        else:
          priority_down = total_spin
        
        priorities[i * N * N + j * N + k][1] = min(priority_up, priority_down)
        priorities[i * N * N + j * N + k][0] = max(priority_up, priority_down)
        
  return priorities




#score: {'data3D.txt': -0.11070300000000009}
#standard deviation: 0.047502183434027546
#island_id: 1
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[0, i, j, (k + 1) % N],
                  J[1, (i + 1) % N, j, k], J[1, i, j, (k + 1) % N],
                  J[2, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.2502310000000003}
#standard deviation: 0.04554522015535768
#island_id: 2
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d == 0 or d == 1)
            priorities[i * N * N + j * N + k][1] -= (d == 0 or d == 1)
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d == len(site_neighbors) - 2 or d == len(site_neighbors) - 1)
            priorities[i * N * N + j * N + k][1] += (d == len(site_neighbors) - 2 or d == len(site_neighbors) - 1)
  
  return(priorities)




#score: {'data3D.txt': 0.27781260000000035}
#standard deviation: 0.04498871726599903
#island_id: 2
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d == 0)
            priorities[i * N * N + j * N + k][1] -= (d == 0)
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d == len(site_neighbors) - 1)
            priorities[i * N * N + j * N + k][1] += (d == len(site_neighbors) - 1)
  
  return(priorities)




#score: {'data3D.txt': 0.2846742000000003}
#standard deviation: 0.04580952012802576
#island_id: 2
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - d
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - d
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (len(site_neighbors) - 1 - d)
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - (len(site_neighbors) - 1 - d)
  
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        def get_priority(spin):
          return total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k, 1] = minimize(get_priority, [1]).x[0]
          priorities[i * N * N + j * N + k, 0] = -priorities[i * N * N + j * N + k, 1]
        else:
          priorities[i * N * N + j * N + k, 0] = minimize(get_priority, [-1]).x[0]
          priorities[i * N * N + j * N + k, 1] = -priorities[i * N * N + j * N + k, 0]

  return priorities




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+x)%N, (j+y)%N, (k+z)%N] 
                   for d, x, y, z in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        def get_priority(spin):
          return total_spin - np.sum([spin*abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k, 1] = minimize(get_priority, [1]).x[0]
          priorities[i*N*N + j*N + k, 0] = -priorities[i*N*N + j*N + k, 1]
        else:
          priorities[i*N*N + j*N + k, 0] = minimize(get_priority, [-1]).x[0]
          priorities[i*N*N + j*N + k, 1] = -priorities[i*N*N + j*N + k, 0]

  return priorities




#score: {'data3D.txt': -0.1729702000000002}
#standard deviation: 0.046362544709711524
#island_id: 1
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31877980000000006}
#standard deviation: 0.05054911939846233
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2289438}
#standard deviation: 0.04401437675987245
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          if any(val < 0 for val in interacting_spins):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif any(val > 0 for val in interacting_spins):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if any(val > 0 for val in site_neighbors):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif any(val < 0 for val in site_neighbors):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          if any(val < 0 for val in interacting_spins):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif any(val > 0 for val in interacting_spins):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          if any(val > 0 for val in site_neighbors):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif any(val < 0 for val in site_neighbors):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.003177000000000001}
#standard deviation: 0.046990280601417994
#island_id: 0
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.3305006}
#standard deviation: 0.0484470292137712
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, i, j, k] for d in range(6) for i in range(N) for j in range(N) for k in range(N)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(3)] if val < 0]) + sum(val for val in [J[d, i, j, k] for d in range(3)])
        
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44003980000000004}
#standard deviation: 0.050187789510597096
#island_id: 3
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) - neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) + neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) - neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.237525}
#standard deviation: 0.04662688939871499
#island_id: 2
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
  return(priorities)




#score: {'data3D.txt': -0.237525}
#standard deviation: 0.04662688939871499
#island_id: 2
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
  return(priorities)




#score: {'data3D.txt': 0.0816814}
#standard deviation: 0.04679737315320166
#island_id: 2
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
        priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.22227420000000017}
#standard deviation: 0.045262171118495856
#island_id: 2
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors.count(site_neighbors[d]) + 1)
            priorities[i * N * N + j * N + k][1] -= site_neighbors.count(site_neighbors[d])
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors.count(site_neighbors[d]) + 1)
            priorities[i * N * N + j * N + k][1] += site_neighbors.count(site_neighbors[d])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
  return(priorities)




#score: {'data3D.txt': 0.24584019999999987}
#standard deviation: 0.04582225511648244
#island_id: 0
#version_generated: 3
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4481218}
#standard deviation: 0.04221486757956254
#island_id: 0
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45880699999999996}
#standard deviation: 0.04209047102373648
#island_id: 0
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.003177000000000001}
#standard deviation: 0.046990280601417994
#island_id: 0
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.4481218}
#standard deviation: 0.04221486757956254
#island_id: 0
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.06699020000000001}
#standard deviation: 0.04691090730267322
#island_id: 2
#version_generated: 3
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, val in enumerate(site_neighbors):
          if val < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
        priorities[i * N * N + j * N + k][1] += 3
  
  return(priorities)




#score: {'data3D.txt': -0.2066334}
#standard deviation: 0.04702590992676271
#island_id: 2
#version_generated: 3
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, val in enumerate(site_neighbors):
          if val < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d % 3 == 1)
            priorities[i * N * N + j * N + k][1] -= (d % 3 == 1)
          elif val > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (d % 3 == 2)
            priorities[i * N * N + j * N + k][1] += (d % 3 == 2)
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return priorities




#score: {'data3D.txt': 0.06699020000000001}
#standard deviation: 0.04691090730267322
#island_id: 2
#version_generated: 3
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, val in enumerate(site_neighbors):
          if val < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif val > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        for d in [0, 1]:
          site_neighbors[d] *= -1
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
        priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.0552026}
#standard deviation: 0.04663202626135819
#island_id: 1
#version_generated: 3
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -2 * np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = 2 * np.sum([spin * abs(spin) for spin in interacting_spins]) + site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = -2
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
  
  return priorities




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.016503399999999998}
#standard deviation: 0.04686308897672026
#island_id: 1
#version_generated: 3
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if all([spin == 0 for spin in site_neighbors]):
          priorities[i * N * N + j * N + k][0] = total_spin - abs(total_spin)
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][1] = -2
          else:
            priorities[i * N * N + j * N + k][1] = 2
        elif all([spin == J[0, i, (j + 1) % N, k] for spin in site_neighbors]):
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]])
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][1] = -2
          else:
            priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': -0.1729702000000002}
#standard deviation: 0.046362544709711524
#island_id: 1
#version_generated: 3
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.04118499999999999}
#standard deviation: 0.04617051066427574
#island_id: 1
#version_generated: 3
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1729702000000002}
#standard deviation: 0.046362544709711524
#island_id: 1
#version_generated: 3
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.2836522}
#standard deviation: 0.04481454356746256
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Add a new term based on the total spin of the site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.016503399999999998}
#standard deviation: 0.04686308897672026
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if all([spin == 0 for spin in site_neighbors]):
          priorities[i * N * N + j * N + k][0] = total_spin - abs(total_spin)
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][1] = -2
          else:
            priorities[i * N * N + j * N + k][1] = 2
        elif all([spin == J[0, i, (j + 1) % N, k] for spin in site_neighbors]):
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]])
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][1] = -2
          else:
            priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': -0.10139780000000001}
#standard deviation: 0.04657715185753634
#island_id: 2
#version_generated: 3
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in [0, N//2]:
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.14055099999999998}
#standard deviation: 0.04974150499331519
#island_id: 2
#version_generated: 3
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for spin in interacting_spins if spin > 0) - sum(1 for spin in interacting_spins if spin < 0)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k - 1] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            if J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
              priorities[i * N * N + j * N + k][1] -= 1
            elif J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.28072100000000005}
#standard deviation: 0.04673877832164637
#island_id: 2
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.09988780000000003}
#standard deviation: 0.05221247984112611
#island_id: 2
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        for d in range(3):
          if interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins.count(interacting_spins[d]))
            priorities[i * N * N + j * N + k][1] -= interacting_spins.count(interacting_spins[d])
          elif interacting_spins[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins.count(interacting_spins[d]))
            priorities[i * N * N + j * N + k][1] += interacting_spins.count(interacting_spins[d])
  
  return priorities




#score: {'data3D.txt': -0.28072100000000005}
#standard deviation: 0.04673877832164637
#island_id: 2
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.43131460000000005}
#standard deviation: 0.0477239422809977
#island_id: 3
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

        neighbor_spins = []
        for d in range(3):
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[2-d, i-d, j, k]
          neighbor_spins.append(neighbor_spin)

        for spin in neighbor_spins:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + spin)
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0026662000000000005}
#standard deviation: 0.0444477470470664
#island_id: 1
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        priorities[i * N * N + j * N + k][1] = np.sum([spin * abs(spin) for spin in interacting_spins]) + site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 7.500000000000062e-05}
#standard deviation: 0.04775642632149102
#island_id: 1
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i + 1) % N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k + 1) % N])
          elif d == 3:
            interacting_spins.append(J[d, (i + 1) % N, (j + 1) % N, k])
          elif d == 4:
            interacting_spins.append(J[d, (i + 1) % N, j, (k + 1) % N])
          elif d == 5:
            interacting_spins.append(J[d, i, (j + 1) % N, (k + 1) % N])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = -np.sum([spin * abs(spin) for spin in interacting_spins]) - total_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.06984980000000028}
#standard deviation: 0.049494674864676104
#island_id: 3
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.10706299999999999}
#standard deviation: 0.047688174540445556
#island_id: 3
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2]])
        priority_opposite_spin = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum([np.exp(abs(val)) for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3344454000000002}
#standard deviation: 0.0492516117385005
#island_id: 3
#version_generated: 3
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority_same_spin = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_opposite_spin = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_same_spin - priority_opposite_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= priority_same_spin + priority_opposite_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43166899999999997}
#standard deviation: 0.04224515308292775
#island_id: 0
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.003177000000000001}
#standard deviation: 0.046990280601417994
#island_id: 0
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.4481218}
#standard deviation: 0.04221486757956254
#island_id: 0
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.46650140000000007}
#standard deviation: 0.04404627655137266
#island_id: 0
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2990422}
#standard deviation: 0.05355928172744665
#island_id: 2
#version_generated: 3
#generate time14:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 2
        
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_spin) - len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.22227420000000017}
#standard deviation: 0.045262171118495856
#island_id: 2
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors.count(site_neighbors[d]) + 1)
            priorities[i * N * N + j * N + k][1] -= site_neighbors.count(site_neighbors[d])
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors.count(site_neighbors[d]) + 1)
            priorities[i * N * N + j * N + k][1] += site_neighbors.count(site_neighbors[d])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            site_neighbors[d] *= -1
        
  return priorities




#score: {'data3D.txt': -0.0552026}
#standard deviation: 0.04663202626135819
#island_id: 1
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -2 * np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = 2 * np.sum([spin * abs(spin) for spin in interacting_spins]) + site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = -2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        
  return priorities




#score: {'data3D.txt': -0.0552026}
#standard deviation: 0.04663202626135819
#island_id: 1
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -2 * np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = 2 * np.sum([spin * abs(spin) for spin in interacting_spins]) + site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = -2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
  
  return priorities




#score: {'data3D.txt': -0.3527309999999996}
#standard deviation: 0.044933721846737766
#island_id: 3
#version_generated: 3
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 4 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2890822000000002}
#standard deviation: 0.055207841500641924
#island_id: 3
#version_generated: 3
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3490286000000002}
#standard deviation: 0.053764428594006285
#island_id: 3
#version_generated: 3
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        site_neighbors.append(J[3, i, (j + 1) % N, k])
        site_neighbors.append(J[4, (i + 1) % N, j, k])
        site_neighbors.append(J[5, i, j, (k + 1) % N])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1399914}
#standard deviation: 0.04731849581337091
#island_id: 2
#version_generated: 3
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - d)
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - d
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - d)
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - d
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.1399914}
#standard deviation: 0.04731849581337091
#island_id: 2
#version_generated: 3
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - d)
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - d
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - d)
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - d
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.1399914}
#standard deviation: 0.04731849581337091
#island_id: 2
#version_generated: 3
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - d)
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - d
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - d)
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - d
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.1729702000000002}
#standard deviation: 0.046362544709711524
#island_id: 1
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.163653}
#standard deviation: 0.04619376095318501
#island_id: 1
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.163653}
#standard deviation: 0.04619376095318501
#island_id: 1
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
  
  return priorities




#score: {'data3D.txt': 0.2275378}
#standard deviation: 0.046934264787679376
#island_id: 1
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the magnetism at the site
        priorities[i * N * N + j * N + k][0] -= h[i, j, k]
        
  return priorities




#score: {'data3D.txt': 0.19167700000000024}
#standard deviation: 0.046124266400670265
#island_id: 1
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.43166899999999997}
#standard deviation: 0.04224515308292775
#island_id: 0
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.44823940000000007}
#standard deviation: 0.04204910186484368
#island_id: 0
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.4438438}
#standard deviation: 0.04321341506476895
#island_id: 0
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (k + 1) % N, j], J[1, i, j, (k + 1) % N], J[2, i, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i - 1) % N, j, k], J[1, i, j, (k - 1) % N], J[2, i, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2565122}
#standard deviation: 0.03979107049527569
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        site_neighbors += [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + h[site_nbr][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + h[site_nbr][j][k])
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin + h[i][j][k])
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.417089}
#standard deviation: 0.04047802908986552
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        site_neighbors += [J[1, i, (j + 1) % N if d == 2 else (j - 1), k] for d in [0, 2]]
        site_neighbors += [J[2, i, j, (k + 1) % N if d == 1 else (k - 1)] for d in [0, 1]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + h[site_nbr][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + h[site_nbr][j][k])
        
  return priorities




#score: {'data3D.txt': -0.3426358}
#standard deviation: 0.039590831746251554
#island_id: 2
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        site_neighbors += [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the interactions between neighboring sites' spins
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.417089}
#standard deviation: 0.04047802908986552
#island_id: 2
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = []
        for d in [0, 1]:
          site_neighbors.append(J[d, (i + 1) % N if d == 0 else (i - 1), j, k])
        site_neighbors.extend([J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + h[site_nbr][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + h[site_nbr][j][k])
        
  return priorities




#score: {'data3D.txt': -0.46697740000000004}
#standard deviation: 0.04446313899445248
#island_id: 0
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.481229}
#standard deviation: 0.042334185701392676
#island_id: 0
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        site_neighbors.sort()
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.44823940000000007}
#standard deviation: 0.04204910186484368
#island_id: 0
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44823940000000007}
#standard deviation: 0.04204910186484368
#island_id: 0
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate interacting spins for the current site
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate site neighbors' spins and add them to the priority
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3256426}
#standard deviation: 0.040850514626378946
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = []
        for d in [0, 1]:
          site_neighbors.append(J[d, (i + 1) % N if d == 0 else (i - 1), j, k])
          site_neighbors.append(J[2, i, (j + 1) % N if d == 0 else j - 1, (k + 1) % N if d == 1 else k - 1])
        
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.37506259999999997}
#standard deviation: 0.040074232634449786
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = []
        for d in [0, 1]:
          site_neighbors.append(J[d, (i + 1) % N if d == 0 else (i - 1), j, k])
        site_neighbors += [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[d, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5041274}
#standard deviation: 0.04156781313997646
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = []
        if i > 0:
          site_neighbors.append(J[0, (i - 1), j, k])
        if i < N - 1:
          site_neighbors.append(J[0, (i + 1) % N, j, k])
        if j > 0:
          site_neighbors.append(J[1, i, (j - 1) % N, k])
        if j < N - 1:
          site_neighbors.append(J[1, i, (j + 1) % N, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, (k - 1)])
        if k < N - 1:
          site_neighbors.append(J[2, i, j, (k + 1) % N])
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.49023179999999994}
#standard deviation: 0.04048488494191382
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, (i + 1) % N if d == 0 else (i - 1), j, k] for d in [0, 1]]
        site_neighbors += [J[2, i, j, (k + 1) % N], J[2, i, j, (k - 1)]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.25604460000000007}
#standard deviation: 0.04703402567120956
#island_id: 2
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the interactions between neighboring sites
        site_neighbors_sum = sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + h[i][j][k] + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]) - 2 + 2 * (h[i][j][k] + total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.34039620000000004}
#standard deviation: 0.04708222706669683
#island_id: 2
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin) + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin) - len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the interactions between neighboring sites
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': 0.1141514000000001}
#standard deviation: 0.04659020066537598
#island_id: 2
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin) - len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (h[i][j][k] + total_neighbor_spin) + len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])

  return priorities




#score: {'data3D.txt': -0.35956419999999994}
#standard deviation: 0.04044911616290274
#island_id: 2
#version_generated: 3
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] + total_neighbor_spin)
        
        # Add a term based on the number of nearest neighbors with same spin
        same_neighbors = sum(1 for val in site_neighbors if val > 0 if h[i][j][k] > 0 or val < 0 if h[i][j][k] < 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_neighbors
        priorities[i * N * N + j * N + k][1] -= same_neighbors
        
        # Add a term based on the number of nearest neighbors with opposite spin
        opposite_neighbors = sum(1 for val in site_neighbors if val < 0 if h[i][j][k] > 0 or val > 0 if h[i][j][k] < 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= opposite_neighbors
        
  return(priorities)




#score: {'data3D.txt': 0.00036300000000000026}
#standard deviation: 0.046209943854110015
#island_id: 1
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        # This is the new part of the function that improves upon previous versions
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][1] += abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0012865999999999997}
#standard deviation: 0.04806214623214407
#island_id: 1
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0031022}
#standard deviation: 0.04622386045280078
#island_id: 1
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.09104980000000003}
#standard deviation: 0.04762854060287803
#island_id: 1
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k] = total_spin
        
  return np.array([priorities.flatten(), np.zeros(N**3)]).T




#score: {'data3D.txt': -0.0008098}
#standard deviation: 0.0451532309360028
#island_id: 1
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]:
          site_neighbors.sort()
          for spin in site_neighbors:
            if spin > 0 and total_spin <= 0:
              priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
            elif spin < 0 and total_spin >= 0:
              priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0031022}
#standard deviation: 0.04622386045280078
#island_id: 1
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                    for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0031022}
#standard deviation: 0.04622386045280078
#island_id: 1
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.455121}
#standard deviation: 0.041622491503993365
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        x_neighbors = [J[3, i-1 if i>0 else N-1, j, k], J[3, (i+1)%N, j, k]]
        for neighbor in x_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        y_neighbors = [J[4, i, j-1 if j>0 else N-1, k], J[4, i, (j+1)%N, k]]
        for neighbor in y_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.421007}
#standard deviation: 0.0409702974238655
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, j, (k - 1) % N], J[1, i, (j + 1) % N, k], J[2, (i - 1) % N, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36463379999999995}
#standard deviation: 0.04129687854499418
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.3867798}
#standard deviation: 0.042926607505834886
#island_id: 0
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, (k - 1) % N], J[1, (i - 1) % N, j, (k - 1) % N], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, (k - 1) % N], J[1, (i - 1) % N, j, (k - 1) % N], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, (k + 1) % N], J[1, (i + 1) % N, j, (k + 1) % N], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j - 1) % N, (k + 1) % N], J[1, (i - 1) % N, j, (k + 1) % N], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.377129}
#standard deviation: 0.04545848434560924
#island_id: 3
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.009091800000000002}
#standard deviation: 0.05195640877466417
#island_id: 3
#version_generated: 2
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val < 0 else -2 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.46697740000000004}
#standard deviation: 0.04446313899445248
#island_id: 0
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1, 2]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4723174000000001}
#standard deviation: 0.0438991682978163
#island_id: 0
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N],
          J[3, (i - 1) % N, j, k],
          J[4, i, (j - 1) % N, k],
          J[5, (i - 1) % N, (j - 1) % N, (k - 1) % N]
        ]
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5243878}
#standard deviation: 0.038990550280292274
#island_id: 0
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i - 1) % N, j, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5243878}
#standard deviation: 0.038990550280292274
#island_id: 0
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, (i - 1) % N, j, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k - 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0306678}
#standard deviation: 0.04898342498396779
#island_id: 0
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for neighbor in site_neighbors if neighbor > 0)
        
  return priorities




#score: {'data3D.txt': -0.457859}
#standard deviation: 0.04422360364104219
#island_id: 0
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4070966}
#standard deviation: 0.042818433278671
#island_id: 0
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if sum(J[d, i, j, k] for d in [0, 1, 2]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4614294}
#standard deviation: 0.043909679748775216
#island_id: 0
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - (np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) - (np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 1
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4216934}
#standard deviation: 0.04001368011618026
#island_id: 0
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for neighbor in [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.011878199999999997}
#standard deviation: 0.04668310020510635
#island_id: 0
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 1
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site neighbors
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site above
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.33646580000000026}
#standard deviation: 0.04999805226566331
#island_id: 0
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.377129}
#standard deviation: 0.04545848434560924
#island_id: 3
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.142693}
#standard deviation: 0.04662671027426233
#island_id: 3
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site and its neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.377129}
#standard deviation: 0.04545848434560924
#island_id: 3
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.009091800000000002}
#standard deviation: 0.05195640877466417
#island_id: 3
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val < 0 else -2 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.042711400000000004}
#standard deviation: 0.051634402001378886
#island_id: 3
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val < 0 else -2 for val in site_neighbors])
        
        # Added a new term to prioritize spins based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * abs(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': 0.0630058}
#standard deviation: 0.04721865400834717
#island_id: 3
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
          total_spin += interacting_spin
          interacting_spins.append(interacting_spin)
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([np.exp(-abs(val)) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.009091800000000002}
#standard deviation: 0.05195640877466417
#island_id: 3
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val < 0 else -2 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.33646580000000026}
#standard deviation: 0.04999805226566331
#island_id: 0
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3432866000000001}
#standard deviation: 0.05020349769129638
#island_id: 0
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_spin > 0.5:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        else:
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          
          if total_spin < -0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.24879060000000003}
#standard deviation: 0.04992272620400453
#island_id: 0
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if J[d, i, (j + 1) % N, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif J[d, i, (j + 1) % N, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(3):
          if J[d, (i + 1) % N, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif J[d, (i + 1) % N, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.29305539999999997}
#standard deviation: 0.04440367564560394
#island_id: 0
#version_generated: 3
#generate time14:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 2
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.08659300000000016}
#standard deviation: 0.04671327167947028
#island_id: 2
#version_generated: 2
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.27556780000000014}
#standard deviation: 0.047429253875219256
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.append(J[3, i, j, k])
          site_neighbors.append(J[4, i, j, k])
          site_neighbors.append(J[5, i, j, k])
          
          for neighbor in site_neighbors:
            if neighbor < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.2456066}
#standard deviation: 0.04746083097081211
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k]])
        site_neighbors.extend([J[5, i, j, (k + 1) % N]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = sum(np.exp(-abs(val)) for val in [total_spin] + site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum(-np.exp(abs(val)) for val in [total_spin] + site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3210598}
#standard deviation: 0.042395920369299685
#island_id: 0
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3677434}
#standard deviation: 0.043817896303222956
#island_id: 0
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0011417999999999999}
#standard deviation: 0.04558347697093762
#island_id: 1
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(spin)
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(interacting_spins))) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and sum(interacting_spins) <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(sum(interacting_spins))) * abs(spin)
          elif spin < 0 and sum(interacting_spins) >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(sum(interacting_spins))) * abs(spin)
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0031022}
#standard deviation: 0.04622386045280078
#island_id: 1
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                  for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 1
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
          J[0, (i + 1) % N, j, k],
          J[1, i, (j + 1) % N, k],
          J[2, i, j, (k + 1) % N],
          J[3, (i - 1) % N, j, k],
          J[4, i, (j - 1) % N, k],
          J[5, (i - 1) % N, (j - 1) % N, (k - 1) % N]
        ]

        site_neighbors.sort()

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in range(6)]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (total_spin + 1)
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(abs(J[d, i, j, k])) for d in range(6)]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (total_spin + 1)

  return(priorities)




#score: {'data3D.txt': -0.4723174000000001}
#standard deviation: 0.0438991682978163
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N],
          J[3, (i - 1) % N, j, k],
          J[4, i, (j - 1) % N, k],
          J[5, (i - 1) % N, (j - 1) % N, (k - 1) % N]
        ]
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36506580000000005}
#standard deviation: 0.049689070331009416
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N],
          J[3, (i - 1) % N, j, k],
          J[4, i, (j - 1) % N, k],
          J[5, (i - 1) % N, (j - 1) % N, (k - 1) % N]
        ]
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - (np.sum(np.square(site_neighbors)) / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - (np.sum(np.square(site_neighbors)) / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48737500000000006}
#standard deviation: 0.04145261071392248
#island_id: 2
#version_generated: 3
#generate time15:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0026198}
#standard deviation: 0.04702596695401382
#island_id: 3
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k-1], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 2
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.08478380000000012}
#standard deviation: 0.0497203058876351
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = []
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
          total_spin += interacting_spin
          interacting_spins.append(interacting_spin)
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([np.exp(-abs(val)) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum([np.exp(-abs(val)) for val in site_neighbors]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.043856199999999984}
#standard deviation: 0.04711183886837787
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l, i, j, k] for l in [0, 1, 2])
        interacting_spins = [J[l, (i + np.mod(k-1, N)) % N, j, k] for l in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([np.exp(-abs(val)) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0630058}
#standard deviation: 0.04721865400834717
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = 0
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
          interacting_spins.append(interacting_spin)
          total_spin += interacting_spin
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-np.abs(np.array(interacting_spins)))) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins)))) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.030092999999999995}
#standard deviation: 0.04640572153301789
#island_id: 3
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l, i, j, k] for l in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0021750000000000007}
#standard deviation: 0.04692056835759771
#island_id: 3
#version_generated: 3
#generate time15:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = 0
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, i, j, k] for l in range(6))
          total_spin += interacting_spin
          interacting_spins.append(interacting_spin)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          interacting_spin = sum(J[l, ((i + np.mod(k-1, N)) % N), (j + np.mod(d, N)) % N, k] for l in range(6))
          total_spin += interacting_spin
          interacting_spins.append(interacting_spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([np.exp(-abs(val)) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': 0.21040940000000036}
#standard deviation: 0.045813738022999165
#island_id: 3
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
          interacting_spins.append(interacting_spin)
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([np.exp(-abs(val)) for val in interacting_spins]) + sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) for val in interacting_spins]) - sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum([val for val in interacting_spins if val > 0])
        
        # Calculate the priority based on the site neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum([np.exp(-abs(val)) for val in site_neighbors]) - sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.08478380000000012}
#standard deviation: 0.0497203058876351
#island_id: 3
#version_generated: 3
#generate time15:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = 0
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
          total_spin += interacting_spin
          interacting_spins.append(interacting_spin)
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([np.exp(-abs(val)) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum([np.exp(-abs(val)) for val in site_neighbors]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.36463379999999995}
#standard deviation: 0.04129687854499418
#island_id: 0
#version_generated: 3
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

  return priorities




#score: {'data3D.txt': -0.32082619999999995}
#standard deviation: 0.041510385129025246
#island_id: 0
#version_generated: 3
#generate time15:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < -np.max([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          elif neighbor > np.max([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.14216140000000002}
#standard deviation: 0.043475865374251035
#island_id: 0
#version_generated: 3
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        site_neighbors.sort()
        site_neighbors = [neighbor for neighbor in site_neighbors if neighbor != 0]
        if site_neighbors:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val == site_neighbors[0]])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val != site_neighbors[0]])
        if not site_neighbors:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        elif site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  return priorities




#score: {'data3D.txt': 0.0009353999999999998}
#standard deviation: 0.04665617758496725
#island_id: 1
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0025134000000000003}
#standard deviation: 0.0467758320122689
#island_id: 1
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin

        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2

  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0013662000000000006}
#standard deviation: 0.045237917033833466
#island_id: 1
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.000393}
#standard deviation: 0.04732300150032751
#island_id: 1
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        # Add the magnetism of the site
        priorities[i * N * N + j * N + k][0] -= h[i, j, k]
  
  return priorities




#score: {'data3D.txt': -0.2456066}
#standard deviation: 0.04746083097081211
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k]])
        site_neighbors.extend([J[5, i, j, (k + 1) % N]])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = sum(np.exp(-abs(val)) for val in [total_spin] + site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = sum(-np.exp(abs(val)) for val in [total_spin] + site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.31607659999999976}
#standard deviation: 0.04576021167389852
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k]])
        site_neighbors.extend([J[5, i, j, (k + 1) % N]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(J[d, i, j, k])) for d in [0, 1, 2, 3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(-np.exp(np.abs(J[d, i, j, k])) for d in [0, 1, 2, 3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.03322380000000018}
#standard deviation: 0.05281131577190632
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        site_neighbors.extend([J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k]])
        site_neighbors.extend([J[5, i, j, (k + 1) % N]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2] if J[d, i, j, k] < 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2] if J[d, i, j, k] > 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          for neighbor in site_neighbors:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor)) if neighbor < 0 else -np.exp(abs(neighbor))
            priorities[i * N * N + j * N + k][1] -= 1 if neighbor < 0 else 1
        else:
          for neighbor in site_neighbors:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor)) if neighbor > 0 else -np.exp(abs(neighbor))
            priorities[i * N * N + j * N + k][1] += 1 if neighbor > 0 else -1
        
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 3
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          interacting_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
          interacting_spins.append(interacting_spin)
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-np.abs(np.array(interacting_spins)))) + np.dot(interacting_spins, interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.dot(interacting_spins, interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins)))) - np.dot(interacting_spins, interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * np.dot(interacting_spins, interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': 0.25666820000000035}
#standard deviation: 0.045178411091582216
#island_id: 3
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0]*6
        total_spin = sum(J[l, i, j, k] for l in range(6))
        
        # Calculate the interactions with neighboring sites
        for d in [0, 1, 2]:
          for l in range(3):
            if d == 0:
              interacting_spins[0] += J[(l+1)%3, i, (j+np.mod(k-1,N))%N, k]
            elif d == 1:
              interacting_spins[1] += J[l, (i+np.mod(j-1,N))%N, j, k]
            else:
              interacting_spins[2] += J[l, i, j, (k+np.mod(1,N))%N]
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-np.abs(np.array(interacting_spins)))) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins)))) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22692660000000034}
#standard deviation: 0.04752019457493835
#island_id: 3
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))
        
        # Calculate the priority based on the interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.010111799999999999}
#standard deviation: 0.05201187807376311
#island_id: 3
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [sum(J[l, (i + np.mod(k-1, N)) % N, j, k] for l in range(6))]
        for d in [0, 1]:
          interacting_spin = sum(J[l, i, (j + np.mod(k-1, N)) % N, k] for l in range(6))
          interacting_spins.append(interacting_spin)
          interacting_spin = sum(J[l, i, j, (k + np.mod(d-1, 3)) % N] for l in range(6))
          interacting_spins.append(interacting_spin)
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-np.abs(np.array(interacting_spins)))) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins)))) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 7.500000000000062e-05}
#standard deviation: 0.04775642632149102
#island_id: 1
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i + 1) % N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k + 1) % N])
          elif d == 3:
            interacting_spins.append(J[d, (i + 1) % N, (j + 1) % N, k])
          elif d == 4:
            interacting_spins.append(J[d, (i + 1) % N, j, (k + 1) % N])
          elif d == 5:
            interacting_spins.append(J[d, i, (j + 1) % N, (k + 1) % N])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = -np.sum([spin * abs(spin) for spin in interacting_spins]) - total_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 7.500000000000062e-05}
#standard deviation: 0.04775642632149102
#island_id: 1
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i+1)%N, (j+1)%N, k])
          elif d == 4:
            interacting_spins.append(J[d, (i+1)%N, j, (k+1)%N])
          elif d == 5:
            interacting_spins.append(J[d, i, (j+1)%N, (k+1)%N])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        priorities[i*N*N+j*N+k][0] = -np.sum([spin*abs(spin) for spin in interacting_spins]) - total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 7.500000000000062e-05}
#standard deviation: 0.04775642632149102
#island_id: 1
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i + 1) % N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j + 1) % N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k + 1) % N])
          elif d == 3:
            interacting_spins.append(J[d, (i + 1) % N, (j + 1) % N, k])
          elif d == 4:
            interacting_spins.append(J[d, (i + 1) % N, j, (k + 1) % N])
          elif d == 5:
            interacting_spins.append(J[d, i, (j + 1) % N, (k + 1) % N])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = -np.sum([spin * abs(spin) for spin in interacting_spins]) - total_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time15:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        # Add a new term to prioritize spins with the same orientation as the magnetism
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0009353999999999998}
#standard deviation: 0.04665617758496725
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0009353999999999998}
#standard deviation: 0.04665617758496725
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
         if spin > 0 and total_spin <= 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
         elif spin < 0 and total_spin >= 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
         if spin > 0 and total_spin <= 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
         elif spin < 0 and total_spin >= 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0009353999999999998}
#standard deviation: 0.04665617758496725
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 2
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val > 0 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        if total_spin > 0:
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        elif total_spin < 0:
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': 0.12409300000000013}
#standard deviation: 0.04655756813881069
#island_id: 1
#version_generated: 3
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        if sum(interacting_spins) > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] -= 1
        elif sum(interacting_spins) < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += 1
  
  return priorities




#score: {'data3D.txt': 0.3212774}
#standard deviation: 0.0484801523227805
#island_id: 2
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = 0 if sum(J[d, i, j, k] for d in [0, 1, 2]) > 0 else 1
        interacting_spins = np.array([J[d, i, j, k] * (site_spin != J[d-3%6,d, j, k]) for d in range(6)])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = -np.sum([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4731802}
#standard deviation: 0.04177322070369965
#island_id: 2
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.00033060000000000576}
#standard deviation: 0.046530457376217575
#island_id: 3
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 2
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 2
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.1636346}
#standard deviation: 0.05242197290106507
#island_id: 2
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 2
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1289382}
#standard deviation: 0.045484660059848754
#island_id: 2
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= 1000
        elif J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += 1000
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5281634}
#standard deviation: 0.03899731452856722
#island_id: 3
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in [J[2, i, j, k - 1]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in [J[2, i, j, k - 1]] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.33002179999999975}
#standard deviation: 0.04515802082421238
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, m] for d in [0, 1]) for m in range(k)) + J[2, i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5680113999999999}
#standard deviation: 0.039877099067509914
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.12579100000000012}
#standard deviation: 0.049379452801747416
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.3199478}
#standard deviation: 0.043327791948817335
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.1122690000000001}
#standard deviation: 0.04723824127759204
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += h[i][j][k] - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 1 - total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11425740000000015}
#standard deviation: 0.04773205155071381
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors' spin
        priorities[i * N * N + j * N + k][0] += h[i][j][k] + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 1 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10763860000000017}
#standard deviation: 0.04780160572658622
#island_id: 3
#version_generated: 3
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors' spin
        priorities[i * N * N + j * N + k][0] += h[i][j][k] + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 1 - 2 * total_neighbor_spin
        
        # Add a new term based on the number of neighboring spins aligned with this spin
        if sum(1 for val in interacting_spins if val > 0) >= 3:
          priorities[i * N * N + j * N + k][0] += 10
          priorities[i * N * N + j * N + k][1] -= 10
        
  return(priorities)




#score: {'data3D.txt': -0.3325798}
#standard deviation: 0.04305496709974356
#island_id: 3
#version_generated: 3
#generate time16:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
          neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) + sum(val for val in neighbor_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in neighbor_spins)
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
          neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) + sum(val for val in neighbor_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in neighbor_spins)
          
  return priorities




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return priorities




#score: {'data3D.txt': -0.068751}
#standard deviation: 0.04796311373336806
#island_id: 2
#version_generated: 3
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time16:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else 0 for val in interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 if val > 0 else 0 for val in interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.36419979999999996}
#standard deviation: 0.043806319634956785
#island_id: 2
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4731802}
#standard deviation: 0.04177322070369965
#island_id: 2
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(3)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0][i][(j+1)%N][k], J[1][(i+1)%N][j][k], J[2][i][j][(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val != 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr = (i+((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.030546999999999998}
#standard deviation: 0.047085460505340716
#island_id: 2
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in J[2, i, j, :k+1] if val < 0]) - np.sum([val for val in J[2, i, j, :k+1] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= np.sum([val for val in J[2, i, j, :k+1] if val < 0]) - np.sum([val for val in J[2, i, j, :k+1] if val > 0])
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          total_neighbor_spin = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.sum([val for val in J[2, i, j, :k+1] if val > 0]) - np.sum([val for val in J[2, i, j, :k+1] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -np.sum([val for val in J[2, i, j, :k+1] if val > 0]) + np.sum([val for val in J[2, i, j, :k+1] if val < 0])
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          total_neighbor_spin = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.48363219999999996}
#standard deviation: 0.04111237141250794
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[1, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5680113999999999}
#standard deviation: 0.039877099067509914
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2965702}
#standard deviation: 0.046985776059995016
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        neighbor_spin = J[0, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[1, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3868066}
#standard deviation: 0.04420010222205374
#island_id: 0
#version_generated: 3
#generate time16:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.21503619999999996}
#standard deviation: 0.04566111529036496
#island_id: 3
#version_generated: 3
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2869406}
#standard deviation: 0.04452382409047992
#island_id: 3
#version_generated: 3
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0148782}
#standard deviation: 0.04635819069765342
#island_id: 3
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += -sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3199478}
#standard deviation: 0.043327791948817335
#island_id: 3
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4488962}
#standard deviation: 0.04079330319500984
#island_id: 3
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3199478}
#standard deviation: 0.043327791948817335
#island_id: 3
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.2689494000000002}
#standard deviation: 0.04525204834745051
#island_id: 2
#version_generated: 3
#generate time16:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(3):
    interacting_spins = np.roll(h, -i, axis=i)
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23071980000000036}
#standard deviation: 0.046194379830884195
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, (k + d) % N] for d in [-1, 0, 1]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.36515139999999996}
#standard deviation: 0.04821407925118968
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - len([val for val in [J[0, site_nbr, j, k], J[1, i, (site_nbr + 1) % N, k], J[2, i, j, (site_nbr + 1) % N]] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - len([val for val in [J[0, site_nbr, j, k], J[1, i, (site_nbr + 1) % N, k], J[2, i, j, (site_nbr + 1) % N]] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.44903060000000006}
#standard deviation: 0.039039158592879535
#island_id: 2
#version_generated: 3
#generate time16:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = J[[0, 1, 2], i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0023186}
#standard deviation: 0.0471880499071534
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                    for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.0011482}
#standard deviation: 0.04644555863330745
#island_id: 1
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [(J[0, (i + x) % N, (j + y) % N, (k + z) % N], abs(x), abs(y), abs(z)) 
                    for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = total_spin - sum(spin for spin, _, _, _ in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.3481802}
#standard deviation: 0.04308634642157536
#island_id: 3
#version_generated: 3
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5191038000000001}
#standard deviation: 0.040973048526561945
#island_id: 3
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(J[0, i, j, k]) - np.count_nonzero(J[1, i, j, k]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.count_nonzero(J[0, i, j, k]) - np.count_nonzero(J[1, i, j, k]) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3273054}
#standard deviation: 0.04639353113139805
#island_id: 3
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48143779999999997}
#standard deviation: 0.041271586971668536
#island_id: 3
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2936762000000001}
#standard deviation: 0.04462162607480814
#island_id: 0
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, m] for d in [0, 1]) for m in range(k)) + J[2, i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        
        x_neighbors = [J[2, i, (j + 1) % N, k], J[3, (i + 1) % N, j, k]]
        if sum(x_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in x_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in x_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in x_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in x_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.04483660000000009}
#standard deviation: 0.04856574657554438
#island_id: 0
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, m] for d in [0, 1]) for m in range(k)) + J[2, i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        
        edge_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in edge_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in edge_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2676450000000003}
#standard deviation: 0.04470207349776964
#island_id: 0
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, m] for d in [0, 1]) for m in range(k)) + J[2, i, j, k]
        
        marginal_prob = np.exp(-abs(total_spin))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += marginal_prob
          priorities[i * N * N + j * N + k][1] -= marginal_prob
        else:
          priorities[i * N * N + j * N + k][0] -= marginal_prob
          priorities[i * N * N + j * N + k][1] += marginal_prob
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += marginal_prob * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) * marginal_prob
        else:
          priorities[i * N * N + j * N + k][0] += marginal_prob * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0]) * marginal_prob
        
  return(priorities)




#score: {'data3D.txt': -0.08585740000000001}
#standard deviation: 0.04857250853353161
#island_id: 0
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, m] for d in [0, 1]) for m in range(k)) + J[2, i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        
        # New logic to consider all neighboring spins
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= J[d, i, (j + 1) % N, k]
          priorities[i * N * N + j * N + k][1] += J[d, i, (j + 1) % N, k]
          
  return(priorities)




#score: {'data3D.txt': -0.48143779999999997}
#standard deviation: 0.041271586971668536
#island_id: 3
#version_generated: 3
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        # Add a new term to prioritize spins with the same orientation as the magnetism
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])

  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        # Add a new term to prioritize spins with the same orientation as the magnetism
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.13324220000000014}
#standard deviation: 0.046427780683121186
#island_id: 0
#version_generated: 3
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) - len([val for val in J[1, i, :, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) - len([val for val in J[1, i, :, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.492031}
#standard deviation: 0.042100173384441074
#island_id: 0
#version_generated: 3
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        for spin in site_neighbors:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.44823940000000007}
#standard deviation: 0.04204910186484368
#island_id: 0
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        for spin in site_neighbors:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49467700000000003}
#standard deviation: 0.04349733636672481
#island_id: 0
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        for spin in site_neighbors:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5680113999999999}
#standard deviation: 0.039877099067509914
#island_id: 0
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.24125580000000035}
#standard deviation: 0.04593556581081809
#island_id: 1
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 2
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 2
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][1] -= sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][1] += sum(interacting_spins)
  
  return priorities




#score: {'data3D.txt': 0.24356660000000036}
#standard deviation: 0.04615178917918567
#island_id: 1
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 2
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 2
        
        if all([spin == J[0, i, (j + 1) % N, k] for spin in site_neighbors]):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += -total_spin
        elif all([spin == J[0, (i + 1) % N, j, k] for spin in site_neighbors]):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += -total_spin
        elif all([spin == J[0, i, (k + 1) % N, k] for spin in site_neighbors]):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += -total_spin
        
  return priorities




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.1522638000000003}
#standard deviation: 0.04583448624736619
#island_id: 3
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.00033060000000000576}
#standard deviation: 0.046530457376217575
#island_id: 3
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09770860000000015}
#standard deviation: 0.04655739346269291
#island_id: 3
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and neighbor's spin
        priorities[i * N * N + j * N + k][0] += h[i][j][k] + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.05250819999999993}
#standard deviation: 0.04490672747773991
#island_id: 3
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        # Add a new term based on the total spin of the site itself
        priorities[i * N * N + j * N + k][0] += total_spin
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.08659300000000016}
#standard deviation: 0.04671327167947028
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.03985260000000004}
#standard deviation: 0.04677725593961236
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.23071980000000036}
#standard deviation: 0.046194379830884195
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, (k + d) % N] for d in [-1, 0, 1]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.23046780000000036}
#standard deviation: 0.04390835186112091
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0] * 6
        site_neighbors = [0] * 3
        for d in range(3):
          interacting_spins[d] = J[d, i, (j + d) % N, (k + d) % N]
          site_neighbors[d] = J[3+d, (i + d) % N, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
  return(priorities)




#score: {'data3D.txt': -0.23071980000000036}
#standard deviation: 0.046194379830884195
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, (k + d) % N] for d in [-1, 0, 1]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.23071980000000036}
#standard deviation: 0.046194379830884195
#island_id: 2
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, (k + d) % N] for d in [-1, 0, 1]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.3665014}
#standard deviation: 0.04846383144201457
#island_id: 3
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34776260000000003}
#standard deviation: 0.04167883973001168
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1109802}
#standard deviation: 0.04166972579655402
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = J[0, i, j, k] + J[1, i+1 if i < N-1 else 0, j, k]
        interacting_spins_y = J[2, i, j, k] + J[3, i, j+1 if j < N-1 else 0, k]
        interacting_spins_z = J[4, i, j, k] + J[5, i, j, k+1 if k < N-1 else 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins_x)) + np.exp(-abs(interacting_spins_y)) + np.exp(-abs(interacting_spins_z))
        priorities[i * N * N + j * N + k][1] -= 3 - interacting_spins_x - interacting_spins_y - interacting_spins_z
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        interacting_spins = np.array([J[0, i-1 if i==0 else i, j, k], J[1, i, j-1 if j==0 else j, k], J[2, i, j, k-1 if k==0 else k]])
        interacting_spin_values = interacting_spins[np.nonzero(interacting_spins)]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin_values if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spin_values if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47599100000000005}
#standard deviation: 0.042371453114095584
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d-1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.2008298000000001}
#standard deviation: 0.04335328213595829
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] -= sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] += sum(interacting_spins)

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': 0.22074220000000033}
#standard deviation: 0.04718706241291144
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i, j, k])
        
  return priorities




#score: {'data3D.txt': 0.24254100000000017}
#standard deviation: 0.04634057141425858
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] += -site_spin
        elif site_spin < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += site_spin
        
  return priorities




#score: {'data3D.txt': 0.10456620000000007}
#standard deviation: 0.04750091554443978
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a term based on the site's magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= abs(h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][1] += abs(h[i, j, k])
  
  return priorities




#score: {'data3D.txt': -0.27874740000000026}
#standard deviation: 0.04555573897150608
#island_id: 0
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.30119060000000003}
#standard deviation: 0.04553164209250527
#island_id: 0
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, m, n, k] for d in [0, 1]) for m in range(i) for n in range(j)) + J[2, i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        
        edge_neighbors = [J[2, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        if sum(edge_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in edge_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in edge_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in edge_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in edge_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.33002179999999975}
#standard deviation: 0.04515802082421238
#island_id: 0
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, m] for d in [0, 1]) for m in range(k)) + J[2, i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.22161180000000033}
#standard deviation: 0.04573449792836913
#island_id: 0
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[2, i, j - 1 if j > 0 else (N - 1), k], J[1, i - 1 if i > 0 else (N - 1), j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.32695939999999996}
#standard deviation: 0.042577099850036756
#island_id: 0
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        z_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        for d in [3, 4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in z_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in z_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.34776260000000003}
#standard deviation: 0.04167883973001168
#island_id: 0
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40742980000000006}
#standard deviation: 0.04274720238752473
#island_id: 0
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.04118499999999999}
#standard deviation: 0.04617051066427574
#island_id: 1
#version_generated: 3
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.037353}
#standard deviation: 0.04834418838909181
#island_id: 3
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
        diagonals = [J[3, (i+a)%N, (j+b)%N, (k+c)%N] 
               for a,b,c in [(1,0,1), (0,1,1), (1,1,0)]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in diagonals)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in diagonals)
  
  return(priorities)




#score: {'data3D.txt': 0.12579100000000012}
#standard deviation: 0.049379452801747416
#island_id: 3
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.2156670000000003}
#standard deviation: 0.04404241536292032
#island_id: 3
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
              for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': 0.12579100000000012}
#standard deviation: 0.049379452801747416
#island_id: 3
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.0004370000000000008}
#standard deviation: 0.04598015779659744
#island_id: 1
#version_generated: 3
#generate time16:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 2
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 2
        
        if all([spin == J[0, i, (j + 1) % N, k] for spin in site_neighbors]):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += -total_spin
        elif all([spin == J[0, (i + 1) % N, j, k] for spin in site_neighbors]):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += -total_spin
        elif all([spin == J[0, i, (k + 1) % N, k] for spin in site_neighbors]):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += -total_spin
        
  return np.argsort(priorities, axis=0)[::-1]




#score: {'data3D.txt': 0.0006582000000000002}
#standard deviation: 0.04715796616437142
#island_id: 1
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(spin)
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(interacting_spins))) * abs(spin)
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] += -site_spin
        elif site_spin < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += site_spin
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * abs(h[i, j, k])
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0014314000000000002}
#standard deviation: 0.04694102527683008
#island_id: 1
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(spin)
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(interacting_spins))) * abs(spin)
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] -= -site_spin
        elif site_spin < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += site_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.1522638000000003}
#standard deviation: 0.04583448624736619
#island_id: 3
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -1.2599999999999807e-05}
#standard deviation: 0.049447304893593544
#island_id: 3
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
        priorities[i * N * N + j * N + k][1] = site_energy_mean
  
  return(priorities)




#score: {'data3D.txt': -0.1522638000000003}
#standard deviation: 0.04583448624736619
#island_id: 3
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 2
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate the energy of each site based on its magnetism and interactions with neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning a spin of +1
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) - h[i][j][k]

        # Calculate the priority for assigning a spin of -1
        priorities[i * N * N + j * N + k][1] = 2 + np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 2
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 2
#version_generated: 2
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 2
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20150420000000027}
#standard deviation: 0.04498022034583646
#island_id: 0
#version_generated: 2
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        
  return priorities




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time16:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.289021}
#standard deviation: 0.047812835923002936
#island_id: 2
#version_generated: 3
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  # Add a bias term to encourage the spins to align with the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.4358294000000001}
#standard deviation: 0.04380160699837393
#island_id: 2
#version_generated: 3
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20150420000000027}
#standard deviation: 0.04498022034583646
#island_id: 0
#version_generated: 3
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))

  return priorities




#score: {'data3D.txt': -0.21503619999999996}
#standard deviation: 0.04566111529036496
#island_id: 3
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.21503619999999996}
#standard deviation: 0.04566111529036496
#island_id: 3
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.21503619999999996}
#standard deviation: 0.04566111529036496
#island_id: 3
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*abs(total_spin)
        
        site_nbr = (i+((k-1)%2-1))%N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3351058}
#standard deviation: 0.04864784852755567
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 0
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2923610000000002}
#standard deviation: 0.045143304697374556
#island_id: 0
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] = 2 * len([val for val in site_neighbors if val > 0]) - 2 * len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20150420000000027}
#standard deviation: 0.04498022034583646
#island_id: 0
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        
  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.13780900000000013}
#standard deviation: 0.04551261933793748
#island_id: 0
#version_generated: 3
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + len([val for val in site_neighbors if val > 0]))
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return [[priority[0], priority[1]] for priority in priorities]




#score: {'data3D.txt': -0.0017765999999999993}
#standard deviation: 0.045509128451773274
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]
        
        for spin in interacting_spins:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin)) - np.exp(abs(spin))
          else:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(spin)) + np.exp(abs(spin))
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.mean([spin for spin in site_neighbors if spin < 0])
        else:
          priorities[i * N * N + j * N + k][1] = -np.mean([spin for spin in site_neighbors if spin > 0])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0010450000000000004}
#standard deviation: 0.04788041535951835
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin - np.sum([spin * abs(spin) for spin in interacting_spins]) - site_neighbors.count(0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.21832580000000035}
#standard deviation: 0.04557108441062161
#island_id: 1
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        spin_diff = sum([abs(spin) for spin in interacting_spins])
        site_neighbor_diff = sum([abs(site_neighbor) for site_neighbor in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities.append((total_spin - spin_diff - site_neighbor_diff, -2 + 2 * total_spin))
        else:
          priorities.append((-total_spin + spin_diff + site_neighbor_diff, 2 - 2 * total_spin))
  
  return np.array(priorities)




#score: {'data3D.txt': 0.0013922000000000003}
#standard deviation: 0.05452479196805798
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = site_energy_mean
        else:
          priorities[i * N * N + j * N + k][0] = site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = -site_energy_mean
  
  return(priorities)




#score: {'data3D.txt': -0.0008625999999999999}
#standard deviation: 0.043887955992960075
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbor = sum(J[d, i, j, k] * site_neighbors[d] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = site_energy_mean + total_spin_neighbor
        else:
          priorities[i * N * N + j * N + k][0] = site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = -site_energy_mean - total_spin_neighbor
  
  return(priorities)




#score: {'data3D.txt': -0.0026038}
#standard deviation: 0.04729395590939714
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
        priorities[i * N * N + j * N + k][1] = site_energy_mean

  # Calculate the priority for each spin assignment
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spins = [s for s in site_neighbors if s > 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(site_energy[i][j][k])) * len(neighbor_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy_mean

  return(priorities)




#score: {'data3D.txt': -1.2599999999999807e-05}
#standard deviation: 0.049447304893593544
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
        priorities[i * N * N + j * N + k][1] = site_energy_mean
  
  return(priorities)




#score: {'data3D.txt': -0.0008625999999999999}
#standard deviation: 0.043887955992960075
#island_id: 3
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbor = sum(J[d, i, j, k] * site_neighbors[d] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = site_energy_mean + total_spin_neighbor
        else:
          priorities[i * N * N + j * N + k][0] = site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = -site_energy_mean - total_spin_neighbor

  return(priorities)




#score: {'data3D.txt': -0.0008625999999999999}
#standard deviation: 0.043887955992960075
#island_id: 3
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbor = sum(J[d, i, j, k] * site_neighbors[d] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = site_energy_mean + total_spin_neighbor
        else:
          priorities[i * N * N + j * N + k][0] = site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = -site_energy_mean - total_spin_neighbor
  
  return(priorities)




#score: {'data3D.txt': -0.0022066}
#standard deviation: 0.044954337682141424
#island_id: 3
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        total_spin_neighbor = sum(J[d, i, j, k] * site_neighbors[d] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = site_energy_mean + total_spin_neighbor
        else:
          priorities[i * N * N + j * N + k][0] = site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = -site_energy_mean - total_spin_neighbor

  return(priorities)




#score: {'data3D.txt': -0.0008625999999999999}
#standard deviation: 0.043887955992960075
#island_id: 3
#version_generated: 3
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbor = sum(J[d, i, j, k] * site_neighbors[d] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = site_energy_mean + total_spin_neighbor
        else:
          priorities[i * N * N + j * N + k][0] = site_energy[i][j][k]
          priorities[i * N * N + j * N + k][1] = -site_energy_mean - total_spin_neighbor
  
  return(priorities)




#score: {'data3D.txt': -0.46853380000000006}
#standard deviation: 0.03966438979185234
#island_id: 0
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.3107778}
#standard deviation: 0.04217989790362229
#island_id: 0
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [2]) + sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.1277706}
#standard deviation: 0.04777649438416343
#island_id: 2
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  # Add a bias term to encourage the spins to align with the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  # Add a term to encourage the spins at neighboring sites to align
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3996082}
#standard deviation: 0.0479905379503085
#island_id: 3
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0]) - 2 * total_spin
        
        # Add more factors here...
        # For example, you can add the number of neighbors that have a certain spin
        # or any other factor that might be relevant
        
  return(priorities)




#score: {'data3D.txt': -0.0021826}
#standard deviation: 0.046881606385020556
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3480074000000002}
#standard deviation: 0.048726478071373064
#island_id: 3
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.037353}
#standard deviation: 0.04834418838909181
#island_id: 3
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
              for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
        diagonals = [J[3, (i+a)%N, (j+b)%N, (k+c)%N] 
            for a,b,c in [(1,0,1), (0,1,1), (1,1,0)]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in diagonals)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in diagonals)
        
  return(priorities)




#score: {'data3D.txt': 0.12579100000000012}
#standard deviation: 0.049379452801747416
#island_id: 3
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                    for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.12579100000000012}
#standard deviation: 0.049379452801747416
#island_id: 3
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.037353}
#standard deviation: 0.04834418838909181
#island_id: 3
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
        diagonals = [J[3, (i+a)%N, (j+b)%N, (k+c)%N] 
               for a,b,c in [(1,0,1), (0,1,1), (1,1,0)]]
        
        priorities[i * N * N + j * N + k][0] += -sum(val for val in diagonals)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in diagonals)
  
  return(priorities)




#score: {'data3D.txt': -0.5002802}
#standard deviation: 0.04094894977847417
#island_id: 0
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3394626}
#standard deviation: 0.04583023588462097
#island_id: 3
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
        # additional term to account for magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3325798}
#standard deviation: 0.04305496709974356
#island_id: 3
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2-2*total_spin-2*abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin-abs(total_spin)-len([val for val in interacting_spins if val > 0])-total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2+2*total_spin+2*abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.03974980000000001}
#standard deviation: 0.04621376851069387
#island_id: 3
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + abs(total_spin) + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - abs(total_spin) - len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * abs(total_spin)
        
        # Add interactions with diagonal sites
        site_diagonal_neighbors = [J[0, (i + 1) % N, (j + 1) % N, (k + 1) % N], J[1, i, (j + 1) % N, (k + 1) % N], J[2, (i + 1) % N, j, (k + 1) % N]]
        total_diagonal_neighbor_spin = sum(val for val in site_diagonal_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_diagonal_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 * total_diagonal_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_diagonal_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_diagonal_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4482146}
#standard deviation: 0.045833175613740756
#island_id: 0
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val < 0])
          
  return priorities




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        # Add a new term to prioritize spins with the same orientation as the magnetism
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        # Add a new term to prioritize spins with the same orientation as the magnetism
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0020466}
#standard deviation: 0.04455869509355048
#island_id: 1
#version_generated: 3
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
        if total_spin > 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
        elif total_spin < 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0013662000000000006}
#standard deviation: 0.045237917033833466
#island_id: 1
#version_generated: 3
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += 2 * np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0026038}
#standard deviation: 0.04729395590939714
#island_id: 3
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
        priorities[i * N * N + j * N + k][1] = site_energy_mean

  # Calculate the priority for each spin assignment
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spins = [s for s in site_neighbors if s > 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(site_energy[i][j][k])) * len(neighbor_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy_mean

  return(priorities)




#score: {'data3D.txt': -0.0026038}
#standard deviation: 0.04729395590939714
#island_id: 3
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
        priorities[i * N * N + j * N + k][1] = site_energy_mean

  # Calculate the priority for each spin assignment
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spins = [s for s in site_neighbors if s > 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(site_energy[i][j][k])) * len(neighbor_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy_mean

  return(priorities)




#score: {'data3D.txt': -0.0026038}
#standard deviation: 0.04729395590939714
#island_id: 3
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          site_energy[i][j][k] = -total_spin
        else:
          site_energy[i][j][k] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy_mean = np.mean(site_energy[max(i-1, 0):min(i+2,N), max(j-1, 0):min(j+2,N), :])
        priorities[i * N * N + j * N + k][0] = -site_energy[i][j][k]
        priorities[i * N * N + j * N + k][1] = site_energy_mean

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spins = [(s, s>0) for s in site_neighbors if s != 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(site_energy[i][j][k])) * sum(1 for val, sign in neighbor_spins if sign)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy_mean

  return(priorities)




#score: {'data3D.txt': -0.5386474000000001}
#standard deviation: 0.03826477274517647
#island_id: 0
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + 1
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + 1
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(J[d][i][j][k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2][i][j][k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i + d][j][k]
          else:
            neighbor_spin = J[1 - d][i - d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i + d][j][k]
          else:
            neighbor_spin = J[1 - d][i - d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.21816860000000032}
#standard deviation: 0.04685958614883405
#island_id: 2
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27633060000000037}
#standard deviation: 0.05061090261633355
#island_id: 2
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4591786}
#standard deviation: 0.03933371050434983
#island_id: 0
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Improved term
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.4461082}
#standard deviation: 0.04079479884446055
#island_id: 0
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.058212599999999996}
#standard deviation: 0.04786676217627426
#island_id: 0
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  import numpy as np
  from scipy.special import expit
  
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= expit(abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] = expit(abs(total_spin))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.0628574}
#standard deviation: 0.043492605638660004
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2431749999999999}
#standard deviation: 0.04657875712167512
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum([1 if val > 0 else 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum([1 if val < 0 else 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0513666}
#standard deviation: 0.0448264141376488
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.16818619999999998}
#standard deviation: 0.04769324993707181
#island_id: 2
#version_generated: 3
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a term to encourage the spins at neighboring sites to align
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': 0.22074220000000033}
#standard deviation: 0.04718706241291144
#island_id: 1
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i, j, k])
        
  return priorities




#score: {'data3D.txt': 0.14702100000000018}
#standard deviation: 0.045412536584075555
#island_id: 1
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]

        # Calculate the sum of interacting spins
        total_interacting_spins = sum(interacting_spins)

        if total_interacting_spins > 0:
          priorities[i * N * N + j * N + k][0] = -total_interacting_spins
        elif total_interacting_spins < 0:
          priorities[i * N * N + j * N + k][0] = total_interacting_spins

        # Calculate the site neighbors sum
        site_neighbors_sum = sum(site_neighbors)

        # Calculate the priority based on site's neighbors and h value
        if site_neighbors_sum > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_neighbors_sum < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][1] += 1

        # Add the magnetic field term
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i, j, k])

  return priorities




#score: {'data3D.txt': 0.22074220000000033}
#standard deviation: 0.04718706241291144
#island_id: 1
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i, j, k])
        
  return priorities




#score: {'data3D.txt': 0.22074220000000033}
#standard deviation: 0.04718706241291144
#island_id: 1
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i, j, k])
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i, j, k])
  
  return priorities




#score: {'data3D.txt': -0.46853380000000006}
#standard deviation: 0.03966438979185234
#island_id: 0
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.46853380000000006}
#standard deviation: 0.03966438979185234
#island_id: 0
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.46853380000000006}
#standard deviation: 0.03966438979185234
#island_id: 0
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.46853380000000006}
#standard deviation: 0.03966438979185234
#island_id: 0
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.19812939999999998}
#standard deviation: 0.04795028441667474
#island_id: 3
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3396706}
#standard deviation: 0.04452213759064136
#island_id: 3
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.5652457999999999}
#standard deviation: 0.04273797681641001
#island_id: 2
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1 + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 2
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0628574}
#standard deviation: 0.043492605638660004
#island_id: 2
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.07530500000000001}
#standard deviation: 0.04406635332087283
#island_id: 2
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.20199779999999998}
#standard deviation: 0.04750678893758239
#island_id: 2
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        for d in [0, 1, 2]:
          interacting_spins[d] += 2 * J[d, i, j, k]
          
        site_spin = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = - (total_spin * (site_spin > 0) + neighbor_spin * (site_neighbors[1] > 0) + sum([1 if val < 0 else -1 for val in interacting_spins]))
        priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * site_spin - 2 + 2 * neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.0009353999999999998}
#standard deviation: 0.04665617758496725
#island_id: 1
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+x)%N, (j+y)%N, (k+z)%N] for x,y,z in [(1,0,0), (0,1,0), (0,0,1)]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
         if spin > 0 and total_spin <= 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
         elif spin < 0 and total_spin >= 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        interacting_spins.sort()
        for spin in interacting_spins:
         if spin > 0 and total_spin <= 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(spin)
         elif spin < 0 and total_spin >= 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += 2
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0014129999999999998}
#standard deviation: 0.04584324106125133
#island_id: 1
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0,1,2]:
          interacting_spins.append(J[d,i,j,k])
          interacting_spins.append(-J[3+d%(d+1),i,j,k]) # Nearest neighbor along the direction
        total_spin = sum([spin*abs(spin) for spin in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] = -total_spin - h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][1] = 2
  
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.20199779999999998}
#standard deviation: 0.04750678893758239
#island_id: 2
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        for d in [0, 1, 2]:
          interacting_spins[d] += 2 * J[d, i, j, k]
          
        site_spin = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = - (total_spin * (site_spin > 0) + neighbor_spin * (site_neighbors[1] > 0) + sum([1 if val < 0 else -1 for val in interacting_spins]))
        priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * site_spin - 2 + 2 * neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.39718780000000004}
#standard deviation: 0.04445564588620887
#island_id: 2
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        interacting_spins_sum = sum(interacting_spins)
        interacting_spins_count = len([val for val in interacting_spins if val < 0])
        
        site_spin = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = - (total_spin * (site_spin > 0) + neighbor_spin * (site_neighbors[1] > 0) + interacting_spins_sum + np.exp(-abs(total_spin)) * interacting_spins_count)
        priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * site_spin - 2 + 2 * neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.35984299999999997}
#standard deviation: 0.04754086359123065
#island_id: 2
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.39718780000000004}
#standard deviation: 0.04445564588620887
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_spin = h[i][j][k]
        
        interacting_spins_sum = sum(interacting_spins)
        interacting_spins_count = len([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] = - (total_spin * (site_spin > 0) + neighbor_spin * (site_neighbors[1] > 0) + interacting_spins_sum + np.exp(-abs(total_spin)) * interacting_spins_count)
        priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * site_spin - 2 + 2 * neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.2243666}
#standard deviation: 0.044944851144930936
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
          
  return(priorities)




#score: {'data3D.txt': 0.39718780000000004}
#standard deviation: 0.04445564588620887
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        interacting_spins_sum = sum(interacting_spins)
        interacting_spins_count = len([val for val in interacting_spins if val < 0])
        
        site_spin = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = - (total_spin * (site_spin > 0) + neighbor_spin * (site_neighbors[1] > 0) + interacting_spins_sum + np.exp(-abs(total_spin)) * interacting_spins_count)
        priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * site_spin - 2 + 2 * neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.411315}
#standard deviation: 0.0448653525005655
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        interacting_spins_sum = sum(interacting_spins)
        interacting_spins_count = len([val for val in interacting_spins if val < 0])
        
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + neighbor_spin + np.exp(-abs(total_spin)) * interacting_spins_count)
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + neighbor_spin + np.exp(-abs(total_spin)) * interacting_spins_count)
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.2287754}
#standard deviation: 0.054531721363257915
#island_id: 3
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 3
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 3
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.36289619999999995}
#standard deviation: 0.03870800622041905
#island_id: 3
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbor_spin > 0) - (total_site_neighbor_spin < 0)
        priorities[i * N * N + j * N + k][1] += 2 * (total_site_neighbor_spin > 0) - 2 * (total_site_neighbor_spin < 0)

  return(priorities)




#score: {'data3D.txt': 0.0386674}
#standard deviation: 0.06045258751484506
#island_id: 3
#version_generated: 3
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - sum([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33118859999999994}
#standard deviation: 0.04788626180899905
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_val = h[site_nbr][j][k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr_val > 0) - (site_nbr_val < 0)
          priorities[i * N * N + j * N + k][1] += 2 * (site_nbr_val > 0) - 2 * (site_nbr_val < 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr_val = h[site_nbr][j][k]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_nbr_val > 0) - (site_nbr_val < 0)
          priorities[i * N * N + j * N + k][1] += 2 * (site_nbr_val > 0) - 2 * (site_nbr_val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += 2 * (sum(val for val in site_neighbors) > 0) - 2 * (sum(val for val in site_neighbors) < 0)
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, (k+d)%N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * spin for d, spin in enumerate(interacting_spins))
        
        priorities[i*N*N+k][0] += np.exp(-np.abs(total_spin)) * len([spin for spin in interacting_spins if spin < 0]) + total_spin
        priorities[i*N*N+k][1] -= 2 - 2 * (total_spin > 0)
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+k][0] += np.exp(-np.abs(total_spin)) * len([spin for spin in site_neighbors if spin < 0]) + sum(spin for spin in site_neighbors)
        priorities[i*N*N+k][1] -= 2 - 2 * (sum(spin for spin in site_neighbors) > 0)
        
        # Add a new term based on the local energy
        priorities[i*N*N+k][0] += np.exp(-np.abs(total_spin)) * h[i][j][k]
        priorities[i*N*N+k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.5376441999999999}
#standard deviation: 0.04030219555259986
#island_id: 0
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0032237999999999998}
#standard deviation: 0.0469161570629991
#island_id: 0
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (i-1)%N if d==1 else (j+1)%N if d==2 else (k+1)%N if d==3 else (i+((k-1)%2)-1)%N for d in [0, 1, 2, 3]]
        site_neighbors = [J[d, site_neighbors[d], j, k] for d in [0, 1, 2, 3]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i+1, j, k], J[1, i-1, j, k], J[2, i, j+1, k], J[3, i, j, k+1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 0
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        if sum([val for val in site_neighbors]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif sum([val for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.49869580000000013}
#standard deviation: 0.04434821825462664
#island_id: 0
#version_generated: 3
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5403194000000001}
#standard deviation: 0.04074049022336378
#island_id: 0
#version_generated: 3
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5376441999999999}
#standard deviation: 0.04030219555259986
#island_id: 0
#version_generated: 3
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2913758}
#standard deviation: 0.05251801304657289
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * ((len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) / 3) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2323182}
#standard deviation: 0.054664865395974406
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2287754}
#standard deviation: 0.054531721363257915
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2287754}
#standard deviation: 0.054531721363257915
#island_id: 3
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0606166}
#standard deviation: 0.04356664692674891
#island_id: 2
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38760900000000004}
#standard deviation: 0.04774545045342017
#island_id: 2
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] = len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.4180162}
#standard deviation: 0.03971413271821506
#island_id: 2
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.030844600000000003}
#standard deviation: 0.04551002231201387
#island_id: 3
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[3-d][i, (j+((k-1)%2-1))%N, k] for d in range(6))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - sum([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.25612180000000007}
#standard deviation: 0.05322111314844891
#island_id: 3
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0386674}
#standard deviation: 0.06045258751484506
#island_id: 3
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - sum([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.38646499999999995}
#standard deviation: 0.04824357755183585
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the interaction with neighboring sites
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.4359222}
#standard deviation: 0.04429331312015393
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': 0.18975419999999998}
#standard deviation: 0.05328704629044474
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term to make it more deterministic
        spin = (h[i][j][k] > 0) - 1
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val * spin < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val * spin > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.14807499999999998}
#standard deviation: 0.0556467754231995
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + h[(i + 1) % N][j][k] + h[i][(j + 1) % N][k])
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.5487393999999999}
#standard deviation: 0.04020609266815168
#island_id: 0
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5403194000000001}
#standard deviation: 0.04074049022336378
#island_id: 0
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5403194000000001}
#standard deviation: 0.04074049022336378
#island_id: 0
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5487393999999999}
#standard deviation: 0.04020609266815168
#island_id: 0
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.3314438}
#standard deviation: 0.04715878922915642
#island_id: 2
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': 0.033694999999999996}
#standard deviation: 0.048460149968814585
#island_id: 2
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.02814099999999999}
#standard deviation: 0.04734064552791818
#island_id: 2
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val for val in interacting_spins]) + sum(site_neighbors))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add a term to encourage the spins at neighboring sites to align
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors])

        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.17311380000000015}
#standard deviation: 0.046262081768549936
#island_id: 2
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum([val for val in interacting_spins]) - sum([1 if val < 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a term to encourage the spins at neighboring sites to align
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': -0.1137722}
#standard deviation: 0.05471000554889389
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
          priorities[i * N * N + j * N + k][1] += 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in site_neighbors]) / len(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -1
        
        # Add a new term based on the total spin of the site's corners
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
    
  return(priorities)




#score: {'data3D.txt': -0.5100466}
#standard deviation: 0.043749916896378215
#island_id: 0
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's diagonals
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5155366000000001}
#standard deviation: 0.043406137128751736
#island_id: 0
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4908430000000002}
#standard deviation: 0.04562166361499764
#island_id: 0
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.3637686}
#standard deviation: 0.04033948356189008
#island_id: 0
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.4359222}
#standard deviation: 0.04429331312015393
#island_id: 3
#version_generated: 3
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4359222}
#standard deviation: 0.04429331312015393
#island_id: 3
#version_generated: 3
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4359222}
#standard deviation: 0.04429331312015393
#island_id: 3
#version_generated: 3
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4359222}
#standard deviation: 0.04429331312015393
#island_id: 3
#version_generated: 3
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.49869580000000013}
#standard deviation: 0.04434821825462664
#island_id: 0
#version_generated: 3
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4383226000000003}
#standard deviation: 0.04738124068911662
#island_id: 0
#version_generated: 3
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.43053940000000024}
#standard deviation: 0.049047032607895856
#island_id: 0
#version_generated: 3
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 4
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.43582780000000026}
#standard deviation: 0.047928894699961526
#island_id: 0
#version_generated: 3
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
  
  return(priorities)




#score: {'data3D.txt': -0.063715}
#standard deviation: 0.052562083815237005
#island_id: 2
#version_generated: 3
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        
        # Add a term to encourage the spins at neighboring sites to align
        for d in [0, 1, 2]:
          site_neighbors = [J[d, i, (j + 1) % N, k], J[d, (i + 1) % N, j, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += -2 * sum([val for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] += 2 * sum([val for val in site_neighbors])
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.35984299999999997}
#standard deviation: 0.04754086359123065
#island_id: 2
#version_generated: 3
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val * 1 if val < 0 else val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val * 1 if val > 0 else val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.35984299999999997}
#standard deviation: 0.04754086359123065
#island_id: 2
#version_generated: 3
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -(total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1277706}
#standard deviation: 0.04777649438416343
#island_id: 2
#version_generated: 3
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  # Add a bias term to encourage the spins to align with the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  # Add a term to encourage the spins at neighboring sites to align
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': 6.379999999999919e-05}
#standard deviation: 0.04620449382430242
#island_id: 1
#version_generated: 3
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(J[d, i, j, k] for d in [0, 1, 2]) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(J[d, i, j, k] for d in [0, 1, 2])
        elif sum(J[d, i, j, k] for d in [0, 1, 2]) < 0:
          priorities[i * N * N + j * N + k][0] = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * abs(spin)
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * abs(spin)
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] -= -site_spin
        elif site_spin < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += site_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.0014314000000000002}
#standard deviation: 0.04694102527683008
#island_id: 1
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins)
        elif sum(interacting_spins) < 0:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins)
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and h[i, j, k] <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(spin)
          elif spin < 0 and h[i, j, k] >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(interacting_spins))) * abs(spin)
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] -= -site_spin
        elif site_spin < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += site_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0016238000000000001}
#standard deviation: 0.04869668277778272
#island_id: 1
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        if site_spin > 0 and h[i, j, k] <= 0:
          priorities[i * N * N + j * N + k][0] -= -site_spin
        elif site_spin < 0 and h[i, j, k] >= 0:
          priorities[i * N * N + j * N + k][0] += site_spin
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.2960802000000001}
#standard deviation: 0.05047621943014355
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors]) > 0) - (sum([val for val in site_neighbors]) < 0)
        priorities[i * N * N + j * N + k][1] += 2 * (sum([val for val in site_neighbors]) > 0) - 2 * (sum([val for val in site_neighbors]) < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.2323182}
#standard deviation: 0.054664865395974406
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]

        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.2323182}
#standard deviation: 0.054664865395974406
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
         J[0, (i + 1) % N, j, k], 
         J[1, i, (j + 1) % N, k], 
         J[2, i, j, (k + 1) % N]
        ]

        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.2323182}
#standard deviation: 0.054664865395974406
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.19967780000000038}
#standard deviation: 0.04817937470702583
#island_id: 2
#version_generated: 3
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 2
#version_generated: 3
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0872578}
#standard deviation: 0.04615849195066927
#island_id: 0
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 4
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] = -4
        
  return(priorities)




#score: {'data3D.txt': -0.5018230000000001}
#standard deviation: 0.04215674549819993
#island_id: 0
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0872578}
#standard deviation: 0.04615849195066927
#island_id: 0
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 4
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] = -4
        
  return(priorities)




#score: {'data3D.txt': -0.1347346}
#standard deviation: 0.0457789157018818
#island_id: 0
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 3
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] += 3
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] = -3
        
  return(priorities)




#score: {'data3D.txt': -0.0023221999999999995}
#standard deviation: 0.046126518047214446
#island_id: 1
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        site_neighbors.sort()
        for i, neighbor in enumerate(site_neighbors):
          if neighbor > 0 and (i % 3 == 0 or i % 3 == 2) and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(neighbor)
          elif neighbor < 0 and (i % 3 == 1 or i % 3 == 2) and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(neighbor)
        
  return np.argsort(priorities, axis=0)




#score: {'data3D.txt': -0.0036693999999999993}
#standard deviation: 0.046447764463319434
#island_id: 1
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                   for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
        # Add a new term based on the total spin of the site
        if total_spin > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-total_spin) * total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][1] += np.exp(total_spin) * -total_spin
        
  return priorities




#score: {'data3D.txt': 0.00011500000000000033}
#standard deviation: 0.04740045922773323
#island_id: 1
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N] 
                  for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
        
        site_neighbors.sort()
        for spin in site_neighbors:
          if spin > 0 and total_spin <= 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(spin)
          elif spin < 0 and total_spin >= 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * abs(spin)
        
  return np.argsort(priorities, axis=0)[::-1]




#score: {'data3D.txt': 0.0474482}
#standard deviation: 0.04516355474007776
#island_id: 3
#version_generated: 3
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbors = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * ((total_spin - total_spin_neighbors) / 3) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.5155366000000001}
#standard deviation: 0.043406137128751736
#island_id: 0
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.43582780000000026}
#standard deviation: 0.047928894699961526
#island_id: 0
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors and itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
  
  return(priorities)




#score: {'data3D.txt': -0.43582780000000026}
#standard deviation: 0.047928894699961526
#island_id: 0
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site's magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.5018230000000001}
#standard deviation: 0.04215674549819993
#island_id: 0
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        for d in itertools.product([-1, 1], repeat=len(neighbor_spins)):
          if all(val < 0 for val in neighbor_spins):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(d)
            priorities[i * N * N + j * N + k][1] -= sum(d)
          elif all(val > 0 for val in neighbor_spins):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(d)
            priorities[i * N * N + j * N + k][1] += sum(d)

  return(priorities)




#score: {'data3D.txt': -0.002395799999999992}
#standard deviation: 0.055677414652262724
#island_id: 3
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18150500000000036}
#standard deviation: 0.04616606258930904
#island_id: 3
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.31883100000000003}
#standard deviation: 0.047170938076319835
#island_id: 2
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
        
        # Add a term to encourage the spins at neighboring sites to align with the magnetism
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.28123220000000004}
#standard deviation: 0.04354998465166205
#island_id: 2
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.2787498}
#standard deviation: 0.04643647187244096
#island_id: 2
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] = -(total_spin + neighbor_spin) / 3
        priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin - 2 + 2 * neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.34726819999999997}
#standard deviation: 0.046489411576831126
#island_id: 2
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.2372062}
#standard deviation: 0.05144078150222837
#island_id: 2
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])

        x, y, z = i % 3, j % 3, k % 3
        cube_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N],
                           J[(x + 1) % 3, y, z, 0], J[x, (y + 1) % 3, z, 0], J[x, y, (z + 1) % 3, 0]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in cube_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(cube_neighbors) - 2 * sum([1 if val > 0 else 0 for val in cube_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.006804200000000002}
#standard deviation: 0.058701536115846234
#island_id: 2
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a new term based on the number of sites with spin up
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += 2
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] -= 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of sites with spin down
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= 2
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': 0.0284302}
#standard deviation: 0.04707986414551342
#island_id: 2
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a new term based on the difference between the site's spin and the total spin of its neighbors
        neighbor_spin_diff = sum([val for val in site_neighbors])
        if neighbor_spin_diff > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        else:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
  
  return(priorities)




#score: {'data3D.txt': -0.4045842}
#standard deviation: 0.04601732663204154
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) - sum([val < 0 for val in site_neighbors]))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.28447300000000003}
#standard deviation: 0.05123900770897111
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
          J[0, (i + 1) % N, j, k],
          J[1, i, (j + 1) % N, k],
          J[2, i, j, (k + 1) % N]
        ]

        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Calculate the priority for each spin in the z-direction
        z_neighbors = [
          J[3, (i + 1) % N, j, k],
          J[4, i, (j + 1) % N, k],
          J[5, i, j, (k + 1) % N]
        ]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in z_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.2300414}
#standard deviation: 0.05670579658236008
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]

        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add a new term based on the local energy and interactions
        for d in range(6):
          if J[d, i, j, k] != 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, j, k] * interacting_spins.count(J[d, i, j, k]) / (3 - (d % 3))
            priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k] / (3 - (d % 3))

  return(priorities)




#score: {'data3D.txt': -0.2323182}
#standard deviation: 0.054664865395974406
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.16610660000000002}
#standard deviation: 0.05578237388673953
#island_id: 3
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + sum([val if val < 0 else -val for val in site_neighbors]))
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.08638860000000002}
#standard deviation: 0.05550595922997819
#island_id: 3
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
        
        # Add a new term based on the interaction with the site neighbors
        if sum([val for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
        elif sum([val for val in site_neighbors]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -2
        
        if h[i][j][k] > 0 and sum([val for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
        elif h[i][j][k] < 0 and sum([val for val in site_neighbors]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
        
        if h[i][j][k] > 0 and sum([val for val in site_neighbors]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
        elif h[i][j][k] < 0 and sum([val for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
        
        priorities[i * N * N + j * N + k][1] -= 2
  return(priorities)




#score: {'data3D.txt': -0.4103094000000002}
#standard deviation: 0.04689135263180196
#island_id: 3
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, (i + 1) % N, j, k], 
          J[1, i, (j + 1) % N, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) - np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the magnetism and site neighbors
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins]) > 0) - (sum([val for val in interacting_spins]) < 0)
          priorities[i * N * N + j * N + k][1] += 2 * (sum([val for val in interacting_spins]) > 0) - 2 * (sum([val for val in interacting_spins]) < 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins]) > 0) - (sum([val for val in interacting_spins]) < 0)
          priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in interacting_spins]) > 0) - 2 * (sum([val for val in interacting_spins]) < 0)
        
  return priorities




#score: {'data3D.txt': -0.367777}
#standard deviation: 0.046213000670806914
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val * 1 if val < 0 else val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        elif site_spin == 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val * 1 if val < 0 else val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val * 1 if val > 0 else val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.35984299999999997}
#standard deviation: 0.04754086359123065
#island_id: 2
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val * 1 if val < 0 else val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val * 1 if val > 0 else val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # additional improvement
        spin_diff = abs(total_spin) / (N**3)
        priorities[i * N * N + j * N + k][0] += spin_diff * (site_spin > 0) * (1 if site_spin > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.30769979999999997}
#standard deviation: 0.051507089220417024
#island_id: 2
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val * np.exp(-abs(val)) if val < 0 else val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val * np.exp(abs(val)) if val > 0 else val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.35984299999999997}
#standard deviation: 0.04754086359123065
#island_id: 2
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val * 1 if val < 0 else val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin) - np.log(1 + np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] = -(total_spin + sum([val * 1 if val > 0 else val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + np.log(1 + np.exp(-abs(total_spin)))

  return(priorities)




#score: {'data3D.txt': 0.28796700000000003}
#standard deviation: 0.04711836999515158
#island_id: 1
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + x) % N, (j + y) % N, (k + z) % N]
                    for d, x, y, z in [(0, 1, 0, 0), (1, 0, 1, 0), (2, 0, 0, 1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        spin_diff = sum([abs(spin) for spin in interacting_spins])
        site_neighbor_diff = sum([abs(site_neighbor) for site_neighbor in site_neighbors])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += 2 - 2 * total_spin

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -(total_spin - spin_diff - site_neighbor_diff)
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][1] = -(total_spin - spin_diff - site_neighbor_diff)

  return np.array(priorities)




#score: {'data3D.txt': -0.014394200000000001}
#standard deviation: 0.04583388709633954
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add more interactions with neighbors
        site_neighbors_x = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        neighbor_spin_x = sum([1 if val > 0 else -1 for val in site_neighbors_x])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in site_neighbors_x if val < 0]) + neighbor_spin_x
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin_x
        
  return(priorities)




#score: {'data3D.txt': -0.054340200000000005}
#standard deviation: 0.043680993394839364
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add priority based on the number of neighbors with same spin as current site
        same_spin_count = sum([1 if val > 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * abs(same_spin_count)
        
  return(priorities)




#score: {'data3D.txt': -0.017912599999999997}
#standard deviation: 0.04675806669698824
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add the interactions with the next layers
        x, y, z = i % N, j % N, k % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 3
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.288579}
#standard deviation: 0.041896897247886984
#island_id: 1
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum(site_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 1
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0284302}
#standard deviation: 0.04707986414551342
#island_id: 2
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a new term based on the difference between the site's spin and the total spin of its neighbors
        neighbor_spin_diff = sum([val for val in site_neighbors])
        if neighbor_spin_diff > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        else:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        
  return(priorities)




#score: {'data3D.txt': 0.0284302}
#standard deviation: 0.04707986414551342
#island_id: 2
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a new term based on the difference between the site's spin and the total spin of its neighbors
        neighbor_spin_diff = sum([val for val in site_neighbors])
        if neighbor_spin_diff > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        else:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        
  return(priorities)




#score: {'data3D.txt': 0.0284302}
#standard deviation: 0.04707986414551342
#island_id: 2
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a new term based on the difference between the site's spin and the total spin of its neighbors
        neighbor_spin_diff = sum([val for val in site_neighbors])
        if neighbor_spin_diff > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        else:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
  
  return(priorities)




#score: {'data3D.txt': 0.08852660000000005}
#standard deviation: 0.04788072109356751
#island_id: 2
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = - (total_spin + sum([val for val in interacting_spins]) + sum([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = (total_spin + sum([val for val in interacting_spins]) + sum([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a bias term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        # Add a new term based on the difference between the site's spin and the total spin of its neighbors
        neighbor_spin_diff = sum([val for val in site_neighbors])
        if neighbor_spin_diff > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        else:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin_diff
          priorities[i * N * N + j * N + k][1] += neighbor_spin_diff
        
        # Add a new term based on the site's spin and its neighbors' spins
        if (site_spin > 0 and sum([val for val in site_neighbors]) > 0):
          priorities[i * N * N + j * N + k][0] -= 2
          priorities[i * N * N + j * N + k][1] += 2
        elif (site_spin < 0 and sum([val for val in site_neighbors]) > 0):
          priorities[i * N * N + j * N + k][0] += 2
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add more spin interactions here...
        
  return(priorities)




#score: {'data3D.txt': 0.498065}
#standard deviation: 0.041771939564736515
#island_id: 2
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning a spin of +1
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) - h[i][j][k] - total_spin
        
        # Calculate the priority for assigning a spin of -1
        priorities[i * N * N + j * N + k][1] = 2 + np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) + h[i][j][k] + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4358294000000001}
#standard deviation: 0.04380160699837393
#island_id: 2
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning a spin of +1
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) - h[i][j][k]

        # Calculate the priority for assigning a spin of -1
        priorities[i * N * N + j * N + k][1] = 2 + np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        # Calculate the priority for assigning a spin of +1
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) - h[i][j][k]

        # Calculate the priority for assigning a spin of -1
        priorities[i * N * N + j * N + k][1] = 2 + np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins)) + h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4383226000000003}
#standard deviation: 0.04738124068911662
#island_id: 0
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.4383226000000003}
#standard deviation: 0.04738124068911662
#island_id: 0
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4418986000000003}
#standard deviation: 0.04779622493503017
#island_id: 0
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's diagonal neighbors
        for d in [0, 1]:
          if (i + d == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j - d == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.126053}
#standard deviation: 0.05566834819715778
#island_id: 0
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(neighbor_spin < 0 for neighbor_spin in neighbor_spins) > len(neighbor_spins) / 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.19303140000000035}
#standard deviation: 0.046339141274305023
#island_id: 1
#version_generated: 3
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i, j, k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4299678}
#standard deviation: 0.041843474558884326
#island_id: 1
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3847634}
#standard deviation: 0.04029384941203806
#island_id: 1
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_energy
        priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3269658000000003}
#standard deviation: 0.04828122275129328
#island_id: 1
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (1 - abs(sum(J[2, i, j, k-1] for k in range(N))) / 8) + sum(J[d, i, j, k] for d in [0, 1]) * (1 - np.abs(1 - 2 * sum(J[d, i, j, k] for d in [0, 1]) / 4)) / 4
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (1 - abs(sum(J[2, i, j, k-1] for k in range(N))) / 8) - sum(J[d, i, j, k] for d in [0, 1]) * (1 - np.abs(1 - 2 * sum(J[d, i, j, k] for d in [0, 1]) / 4)) / 4
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49041500000000005}
#standard deviation: 0.0449157368302024
#island_id: 0
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's diagonals
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's edges
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            edge_spin = J[d, i + d, j, k]
          else:
            edge_spin = J[1 - d, i - d, j, k]
          if edge_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif edge_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.5487393999999999}
#standard deviation: 0.04020609266815168
#island_id: 0
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.47302059999999996}
#standard deviation: 0.04246211788924335
#island_id: 0
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4299678}
#standard deviation: 0.041843474558884326
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.34949020000000036}
#standard deviation: 0.047765260011435086
#island_id: 0
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

        for d in [0, 1]:
          if (i == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0031334}
#standard deviation: 0.04691706048379417
#island_id: 0
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] + J[1, :, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] + J[1, :, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, site_nbr, j, :] + J[1, i, :, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, site_nbr, j, :] + J[1, i, :, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the total spin of the site's diagonal neighbors
        for d in [0, 1]:
          if (i + d == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j - d == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5625426}
#standard deviation: 0.040607119883586916
#island_id: 3
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 3
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2127034}
#standard deviation: 0.04485550744824988
#island_id: 3
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.5625426}
#standard deviation: 0.040607119883586916
#island_id: 3
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.49269939999999995}
#standard deviation: 0.0410124303064327
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.054340200000000005}
#standard deviation: 0.043680993394839364
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add priority based on the number of neighbors with same spin as current site
        same_spin_count = sum([1 if val > 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * abs(same_spin_count)
        
  return(priorities)




#score: {'data3D.txt': -0.4125158}
#standard deviation: 0.04540515026249776
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.054340200000000005}
#standard deviation: 0.043680993394839364
#island_id: 2
#version_generated: 3
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add priority based on the number of neighbors with same spin as current site
        same_spin_count = sum([1 if val > 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * abs(same_spin_count)
        
  return(priorities)




#score: {'data3D.txt': -0.32582620000000007}
#standard deviation: 0.04666723040378549
#island_id: 3
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3314438}
#standard deviation: 0.04715878922915642
#island_id: 2
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum([1 if val > 0 else 0 for val in site_neighbors])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.2521238}
#standard deviation: 0.03991766718584642
#island_id: 1
#version_generated: 3
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) - 1)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins) - 2
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) - 1)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) - 3
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(site_neighbors) - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.3277754}
#standard deviation: 0.04155525953281967
#island_id: 1
#version_generated: 3
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 1
#version_generated: 3
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 1
#version_generated: 3
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3265146}
#standard deviation: 0.0459187067200286
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, l] for d in [0, 1]) for l in range(k+1))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] for d in [0, 1]]) < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] for d in [0, 1]]) > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.469119}
#standard deviation: 0.03963605175846858
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.13034940000000034}
#standard deviation: 0.04792888189432339
#island_id: 1
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.13034940000000034}
#standard deviation: 0.04792888189432339
#island_id: 1
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 1
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.025498600000000003}
#standard deviation: 0.044370277416757274
#island_id: 2
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add more interactions with neighbors
        site_neighbors_x = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        neighbor_spin_x = sum([1 if val > 0 else -1 for val in site_neighbors_x])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in site_neighbors_x if val < 0]) + neighbor_spin_x
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin_x
        
  return(priorities)




#score: {'data3D.txt': -0.0288726}
#standard deviation: 0.04495203809884486
#island_id: 2
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add more interactions with neighbors and bias term to align spins with magnetism
        site_neighbors_x = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        neighbor_spin_x = sum([1 if val > 0 else -1 for val in site_neighbors_x])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in site_neighbors_x if val < 0]) + neighbor_spin_x
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin_x
        
        # Add a bias term to encourage spins at neighboring sites to align with the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.014394200000000001}
#standard deviation: 0.04583388709633954
#island_id: 2
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        spin_sum = total_spin + h[i][j][k]
        
        # Add more interactions with neighbors
        site_neighbors_x = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        neighbor_spin_x = sum([1 if val > 0 else -1 for val in site_neighbors_x])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in site_neighbors_x if val < 0]) + neighbor_spin_x
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin_x
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.017912599999999997}
#standard deviation: 0.04675806669698824
#island_id: 2
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add the interactions with the next layers
        x, y, z = i % N, j % N, k % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0045374}
#standard deviation: 0.04688518871925334
#island_id: 2
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add the interactions with the next layers
        x, y, z = i % N, j % N, k % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val > 0])
        
        # Add the interactions with the previous layers
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in [J[0, (i-1)%N, j, k], J[1, i, (j-1)%N, k], J[2, i, j, (k-1)%N]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, (i-1)%N, j, k], J[1, i, (j-1)%N, k], J[2, i, j, (k-1)%N]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.017912599999999997}
#standard deviation: 0.04675806669698824
#island_id: 2
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        spin_sum = total_spin + h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in interacting_spins if val < 0]) + spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_sum
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        x, y, z = i % N, j % N, k % N
        
        next_layer_spin_sum = sum([J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, (x+1)%N, y, z], J[1, x, (y+1)%N, z], J[2, x, y, (z+1)%N]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4081882000000003}
#standard deviation: 0.04825598803008804
#island_id: 0
#version_generated: 3
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3471686000000002}
#standard deviation: 0.04847729627402914
#island_id: 0
#version_generated: 3
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.40371580000000007}
#standard deviation: 0.04090016711897398
#island_id: 3
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.405149}
#standard deviation: 0.04029371860476519
#island_id: 3
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.42042379999999996}
#standard deviation: 0.04317753343534112
#island_id: 0
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if i < j and j < N/2:
            neighbor_spin = J[d, i + d, j, k]
          elif i > j and i > N/2:
            neighbor_spin = J[1 - d, i, j - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.42032820000000015}
#standard deviation: 0.04612718509469226
#island_id: 0
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2, 3]:
          neighbor_spin = sum(J[d, i, j, k] for _ in range(N))
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin

  return(priorities)




#score: {'data3D.txt': -0.3363761999999996}
#standard deviation: 0.045104123465155584
#island_id: 0
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.4298946000000003}
#standard deviation: 0.04724617964280287
#island_id: 0
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin)
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin)
          priorities[i * N * N + j * N + k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5096742000000001}
#standard deviation: 0.04228557832594938
#island_id: 0
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_priority = (total_spin - total_neighbor_spin) / (N**3)
          priorities[i * N * N + j * N + k][0] += site_priority
          priorities[i * N * N + j * N + k][1] -= site_priority
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_priority = (total_spin - total_neighbor_spin) / (N**3)
          priorities[i * N * N + j * N + k][0] -= site_priority
          priorities[i * N * N + j * N + k][1] += site_priority
          
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - 1)
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin - 1)
          priorities[i * N * N + j * N + k][1] += total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.33800979999999964}
#standard deviation: 0.04498288234384275
#island_id: 1
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_nbr_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_nbr_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_nbr_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_site_nbr_spin
          
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 1
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 1
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.4908430000000002}
#standard deviation: 0.04562166361499764
#island_id: 0
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.44302100000000016}
#standard deviation: 0.04562630906615174
#island_id: 0
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.44302100000000016}
#standard deviation: 0.04562630906615174
#island_id: 0
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.44603020000000004}
#standard deviation: 0.042689350521646505
#island_id: 2
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.0015949999999999998}
#standard deviation: 0.051467859631035756
#island_id: 2
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)

  # Calculate the probability that a given spin should be aligned with its neighbors
  def calculate_probability(interacting_spins):
    total_spin = sum(interacting_spins)
    prob = norm.cdf(total_spin, loc=0, scale=np.std(interacting_spins))
    return -prob

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += calculate_probability(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= calculate_probability(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.5414058}
#standard deviation: 0.041086550674886306
#island_id: 3
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Improved part
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 3
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 3
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 3
#version_generated: 3
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.16006260000000022}
#standard deviation: 0.04607615480093798
#island_id: 1
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.16006260000000022}
#standard deviation: 0.04607615480093798
#island_id: 1
#version_generated: 3
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N * N * N)]
  for k in range(N):
    for j in range(N):
      for i in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.09951500000000006}
#standard deviation: 0.046805773308428535
#island_id: 0
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        total_neighbor_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28503620000000013}
#standard deviation: 0.04410674517077859
#island_id: 0
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len(interacting_spins) / 2)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) + len(site_neighbors) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len(interacting_spins) / 2)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) + len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.2475542000000002}
#standard deviation: 0.045731298061174694
#island_id: 0
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 if neighbor_spin > 0 else -2
        
  return(priorities)




#score: {'data3D.txt': -0.31630020000000003}
#standard deviation: 0.04291556454201669
#island_id: 1
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3882446}
#standard deviation: 0.041341599035837985
#island_id: 1
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N * N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  else:
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.5376441999999999}
#standard deviation: 0.04030219555259986
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5018230000000001}
#standard deviation: 0.04215674549819993
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.5403194000000001}
#standard deviation: 0.04074049022336378
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5487393999999999}
#standard deviation: 0.04020609266815168
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.49184700000000015}
#standard deviation: 0.045683324649153985
#island_id: 0
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the total spin of the site's diagonal neighbors
        for d in [0, 1]:
          if (i + d == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j - d == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5116394000000001}
#standard deviation: 0.04306393395452859
#island_id: 0
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's diagonal neighbors
        for d in [0, 1]:
          if (i + d == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j - d == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.003315}
#standard deviation: 0.04695547183236476
#island_id: 0
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.1945134000000003}
#standard deviation: 0.044306585294287805
#island_id: 0
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 2
        else:
          priorities[i * N * N + j * N + k][1] += 2
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 2
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] += 2
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][1] -= 2
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][1] += 2
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] += 2
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][1] -= 2
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[0, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[0, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[1, (i + 1) % N, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[1, (i + 1) % N, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[2, (i + 1) % N, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[2, (i + 1) % N, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[0, (i + 1) % N, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[0, (i + 1) % N, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[1, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[1, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
        if J[2, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        elif J[2, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
        
  return(priorities)




#score: {'data3D.txt': 0.165761}
#standard deviation: 0.054237651488610754
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(neighbor_spin < 0 for neighbor_spin in site_neighbors) > len(site_neighbors) / 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.31363660000000027}
#standard deviation: 0.04865069681350924
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(neighbor_spin < 0 for neighbor_spin in neighbor_spins) > len(neighbor_spins) / 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3

  return(priorities)




#score: {'data3D.txt': 0.126053}
#standard deviation: 0.05566834819715778
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(neighbor_spin < 0 for neighbor_spin in neighbor_spins) > len(neighbor_spins) / 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.1831686}
#standard deviation: 0.053088761278070905
#island_id: 0
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        if all(neighbor_spin < 0 for neighbor_spin in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif any(neighbor_spin > 0 for neighbor_spin in site_neighbors):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.09705780000000006}
#standard deviation: 0.04446979625723509
#island_id: 3
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4235950000000002}
#standard deviation: 0.04828487397726124
#island_id: 3
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
          
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.469119}
#standard deviation: 0.03963605175846858
#island_id: 3
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.39959619999999996}
#standard deviation: 0.0399898320271541
#island_id: 3
#version_generated: 3
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors
        for d in [2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3759318}
#standard deviation: 0.045672284251611496
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [(i+1)%N if d==0 else (i-1)%N if d==1 else (j+1)%N if d==2 else (k+1)%N if d==3 else (i+((k-1)%2)-1)%N for d in [0, 1, 2, 3]]
        site_neighbors = [J[d, site_neighbors[d], j, k] for d in [0, 1, 2, 3]]

        # Add a new term based on the total spin of neighboring sites
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the total spin of neighboring sites
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.20847100000000002}
#standard deviation: 0.04470244958612447
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (i-1)%N if d==1 else (j+1)%N if d==2 else (k+1)%N if d==3 else (i+((k-1)%2)-1)%N for d in [0, 1, 2, 3]]
        site_neighbors = [J[d, site_neighbors[d], j, k] for d in [0, 1, 2, 3]]
        
        neighbor_spins = [val if val < 0 else -val for val in site_neighbors]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(neighbor_spins) - sum(neighbor_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4235950000000002}
#standard deviation: 0.04828487397726124
#island_id: 3
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
          
  return(priorities)




#score: {'data3D.txt': -0.26568780000000003}
#standard deviation: 0.045755722824145174
#island_id: 3
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_count = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * site_neighbor_count
          priorities[i * N * N + j * N + k][1] -= site_neighbor_count
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbor_count = sum(1 if val < 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * site_neighbor_count
          priorities[i * N * N + j * N + k][1] += site_neighbor_count
          
  return(priorities)




#score: {'data3D.txt': -0.33800979999999964}
#standard deviation: 0.04498288234384275
#island_id: 1
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_nbr_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_nbr_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_nbr_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_site_nbr_spin
          
  return(priorities)




#score: {'data3D.txt': -0.44689340000000005}
#standard deviation: 0.04116139789219992
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
                  J[3, i, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs([*interacting_spins, *site_neighbors]))) * len([val for val in interacting_spins + site_neighbors if val < 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs([*interacting_spins, *site_neighbors]))) * len([val for val in interacting_spins + site_neighbors if val > 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(interacting_spins)
  return(priorities)




#score: {'data3D.txt': -0.16131660000000006}
#standard deviation: 0.044860638921442035
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add interactions with other sites
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, i, j, k])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3041954}
#standard deviation: 0.04612597900142608
#island_id: 3
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, l] for d in [0, 1]) for l in range(k+1))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] for d in [0, 1]]) < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] for d in [0, 1]]) > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3265146}
#standard deviation: 0.0459187067200286
#island_id: 3
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(sum(J[d, i, j, l] for d in [0, 1]) for l in range(k+1))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] for d in [0, 1]]) < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] for d in [0, 1]]) > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.34194139999999995}
#standard deviation: 0.0447484708793496
#island_id: 1
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][1] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 1
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 1
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.024495000000000298}
#standard deviation: 0.04639204473829539
#island_id: 1
#version_generated: 3
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N * N * N)]
  for k in range(N):
    for j in range(N):
      for i in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k]))
          priorities[i * N * N + j * N + k][1] += 1
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin))
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin))
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[2, i, j, k]))
          priorities[i * N * N + j * N + k][1] += 1
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(neighbor_spin))
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(neighbor_spin))
              priorities[i * N * N + j * N + k][1] -= 1
  return priorities




#score: {'data3D.txt': -0.2775794}
#standard deviation: 0.04480158943207262
#island_id: 3
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.26695340000000006}
#standard deviation: 0.043670066045748086
#island_id: 3
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.26279859999999994}
#standard deviation: 0.04612684032144409
#island_id: 3
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d % 2, i + d // 2, j, k]
          else:
            neighbor_spin = J[1 - d % 2, i - d // 2, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4422938}
#standard deviation: 0.04222542600803455
#island_id: 0
#version_generated: 3
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.34538300000000016}
#standard deviation: 0.04851675907354077
#island_id: 0
#version_generated: 3
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2049218}
#standard deviation: 0.04450821772167473
#island_id: 0
#version_generated: 3
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_x = sum(J[d, i, j, k] for d in [2])
        if neighbor_spin_x < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif neighbor_spin_x > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin_y = sum(J[d, i, j, k] for d in [1])
        if neighbor_spin_y < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[1, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif neighbor_spin_y > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[1, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5129914}
#standard deviation: 0.04280518807387722
#island_id: 1
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_count = sum([val for val in site_neighbors if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i * N * N + j * N + k][1] += 2 * neighbor_count
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0033650000000000004}
#standard deviation: 0.04689217178805009
#island_id: 1
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] += -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] -= 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + site_neighbors_sum
        
        return(priorities)




#score: {'data3D.txt': 0.027167}
#standard deviation: 0.047534588575057636
#island_id: 1
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else -2 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.44689340000000005}
#standard deviation: 0.04116139789219992
#island_id: 2
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
                 J[3, i, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs([*interacting_spins, *site_neighbors]))) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs([*interacting_spins, *site_neighbors]))) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d][i][j][k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2][i][j][k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i + d][j][k]
          else:
            neighbor_spin = J[1 - d][i - d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i + d][j][k]
          else:
            neighbor_spin = J[1 - d][i - d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3029586}
#standard deviation: 0.0456679888547766
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0026705999999999995}
#standard deviation: 0.046921193672369424
#island_id: 3
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1

        return(priorities)




#score: {'data3D.txt': -0.1541757999999999}
#standard deviation: 0.046915934333230554
#island_id: 3
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 3
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.1541757999999999}
#standard deviation: 0.046915934333230554
#island_id: 3
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.08838380000000001}
#standard deviation: 0.04789448420810063
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in J[[0, 1, 2], i, j, k] if val < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in J[[0, 1, 2], i, j, k] if val > 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3870134}
#standard deviation: 0.04194258385507502
#island_id: 2
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add more spin interaction terms as needed
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.4564994}
#standard deviation: 0.04275384613856395
#island_id: 1
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] += -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] -= 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]] + \
                 [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.37187739999999997}
#standard deviation: 0.04391969728083289
#island_id: 2
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10377460000000001}
#standard deviation: 0.06005793631852496
#island_id: 2
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 4, 5]]
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + np.sum(interacting_spins) - 2 + 2 * np.sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - 2 + 2 * np.sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + np.sum(interacting_spins) - 2 + 2 * np.sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - 2 + 2 * np.sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.4230814000000002}
#standard deviation: 0.04569107017831821
#island_id: 1
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  import numpy as np
  from scipy.spatial.distance import pdist, squareform

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] += -2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] -= 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors_sum = np.sum([val for val in site_neighbors if val > 0]) - np.sum([val for val in site_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in interacting_spins if val < 0])) + site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in interacting_spins if val > 0])) + site_neighbors_sum

  return priorities




#score: {'data3D.txt': -0.027906199999999992}
#standard deviation: 0.04724002499533631
#island_id: 1
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = 0
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if h[i][j][k] > 0:
            site_neighbors_sum += np.sum(J[d, i, j, k] for d in [0, 1, 2])
          else:
            site_neighbors_sum -= np.sum(J[d, l, (i+j+k)//3, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -np.exp(-abs(total_spin)) * site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.008418199999999995}
#standard deviation: 0.06077077544971759
#island_id: 1
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  priorities = h.flatten()[:, None]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities += -J[l,i,j,k]*interacting_spins[l,i,j,k]

  return np.array([priorities.flatten(), np.zeros(N**3)]).T




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
        priorities[i * N * N + j * N + k][1] += 3

  return priorities




#score: {'data3D.txt': -0.21303740000000013}
#standard deviation: 0.045958463869455
#island_id: 0
#version_generated: 3
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) / 2
        priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if sum(neighbor_spin < 0 for neighbor_spin in neighbor_spins) > len(neighbor_spins) / 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.010863800000000062}
#standard deviation: 0.049728891095217484
#island_id: 0
#version_generated: 3
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbors_total_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin

        # new added line
        neighbor_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if sum(neighbor_spin < 0 for neighbor_spin in neighbor_spins) > len(neighbor_spins) / 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3

  return(priorities)




#score: {'data3D.txt': -0.19578820000000008}
#standard deviation: 0.04256061349134902
#island_id: 0
#version_generated: 3
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) / len(interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.4755598000000001}
#standard deviation: 0.04392537972471041
#island_id: 0
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2, 3]:
          neighbor_spin = sum(J[d, i, j, k] for _ in range(N))
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [4, 5]:
          neighbor_spin = sum(J[d, i, j, k] for _ in range(N))
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4033782000000001}
#standard deviation: 0.044687181660516474
#island_id: 0
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2, 3]:
          neighbor_spin = sum(J[d, i, :, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2, 3]:
          neighbor_spin = sum(J[d, :, j, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36065580000000014}
#standard deviation: 0.047379048179126616
#island_id: 0
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in range(2, 6):
          if i < N/3 and j < N/3:
            neighbor_spin = sum(J[d, :, j, k])
          elif i > 2*N/3 and j > 2*N/3:
            neighbor_spin = sum(J[5 - d, :, j, k])
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.35809100000000027}
#standard deviation: 0.04878611440768777
#island_id: 0
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        neighbor_spin_y = sum(J[d, i, j, k] for d in [2, 3])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if neighbor_spin_x < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin_x > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if neighbor_spin_y < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin_y > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2618962000000003}
#standard deviation: 0.047302690679918
#island_id: 0
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 if neighbor_spin > 0 else -2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
  
  return(priorities)




#score: {'data3D.txt': -0.2475542000000002}
#standard deviation: 0.045731298061174694
#island_id: 0
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 if neighbor_spin > 0 else -2

  return(priorities)




#score: {'data3D.txt': -0.30037780000000003}
#standard deviation: 0.046603400167369746
#island_id: 0
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 if neighbor_spin > 0 else -2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
    
  return(priorities)




#score: {'data3D.txt': -0.29051100000000035}
#standard deviation: 0.04518993293865349
#island_id: 0
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += 2 if neighbor_spin > 0 else -2
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]] +\
            [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = []
        for d in [3,4,5]:
          if (i + (d - 3) % 2 == 0):
            site_neighbors.append(J[d-3, i + (d - 3), j, k])
          else:
            site_neighbors.append(J[1-d+3, i - (d - 3), j, k])
        for d in [6,7,8]:
          if (i + (d - 6) % 2 == 0):
            site_neighbors.append(J[d-6, i + (d - 6), j, k])
          else:
            site_neighbors.append(J[1-d+6, i - (d - 6), j, k])
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]] +\
                 [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * sum(J[d,i,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val > 0]) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * sum(J[d,i,j,k] for d in [0,1,2])
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]] +\
             [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-np.sum(np.abs([*interacting_spins,*site_neighbors]))) * len([val for val in interacting_spins+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.04751940000000004}
#standard deviation: 0.04661482707937465
#island_id: 1
#version_generated: 3
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  import numpy as np
  from scipy.spatial.distance import pdist, squareform

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] -= 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] += 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors_sum = np.sum([val for val in site_neighbors if val > 0]) - np.sum([val for val in site_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in interacting_spins if val < 0])) + site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in interacting_spins if val > 0])) + site_neighbors_sum

  return priorities




#score: {'data3D.txt': 0.4230814000000002}
#standard deviation: 0.04569107017831821
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] += -2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] -= 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors_sum = np.sum([val for val in site_neighbors if val > 0]) - np.sum([val for val in site_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in interacting_spins if val < 0])) + site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in interacting_spins if val > 0])) + site_neighbors_sum

  return priorities




#score: {'data3D.txt': 0.011671799999999927}
#standard deviation: 0.04777038334323895
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.5622493999999999}
#standard deviation: 0.04261849738834066
#island_id: 1
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37187739999999997}
#standard deviation: 0.04391969728083289
#island_id: 2
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37187739999999997}
#standard deviation: 0.04391969728083289
#island_id: 2
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3466062}
#standard deviation: 0.04365298617002049
#island_id: 2
#version_generated: 3
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23918980000000015}
#standard deviation: 0.04466587798263905
#island_id: 2
#version_generated: 3
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in site_neighbors if val < 0) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in interacting_spins if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in site_neighbors if val > 0) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4908430000000002}
#standard deviation: 0.04562166361499764
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.4908430000000002}
#standard deviation: 0.04562166361499764
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
      
  return(priorities)




#score: {'data3D.txt': -0.3946438000000003}
#standard deviation: 0.04860035433574533
#island_id: 0
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5018230000000001}
#standard deviation: 0.04215674549819993
#island_id: 0
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = J[i]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(interacting_spins[:, i, j, k])) * len([val for val in interacting_spins[:, i, j, k] if val < 0]) + sum(interacting_spins[:, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(interacting_spins[:, i, j, k])) * len([val for val in interacting_spins[:, i, j, k] if val > 0]) + sum(interacting_spins[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins[:, i, j, k])

  return(priorities)




#score: {'data3D.txt': -0.43754780000000015}
#standard deviation: 0.047400323576532684
#island_id: 0
#version_generated: 3
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's diagonal neighbors
        for d in [0, 1]:
          if (i + d == j and i < N/2):
            neighbor_spin = J[d, i + d, i, k]
          elif (j - d == i and j > N/2):
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3557894}
#standard deviation: 0.05000702438298044
#island_id: 0
#version_generated: 3
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.42152420000000007}
#standard deviation: 0.04572660991545296
#island_id: 0
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        interacting_spins = J[:, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0029978000000000006}
#standard deviation: 0.046991868606813245
#island_id: 0
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0, 
                             J[5-i, i, j-1, k] if j > 0 else 0, 
                             J[5-k, i, j, k-1] if k > 0 else 0]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0031586}
#standard deviation: 0.04699646801664993
#island_id: 0
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.4380958}
#standard deviation: 0.04251884361503733
#island_id: 0
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if i == j and i < N/2:
            neighbor_spin = J[d, i + d, i, k]
          elif j == i and j > N/2:
            neighbor_spin = J[1 - d, i, i - d, k]
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1541757999999999}
#standard deviation: 0.046915934333230554
#island_id: 3
#version_generated: 3
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 3
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 3
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.30528419999999995}
#standard deviation: 0.046145116213527966
#island_id: 3
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 3
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.37187739999999997}
#standard deviation: 0.04391969728083289
#island_id: 2
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.34158019999999967}
#standard deviation: 0.0445389165557493
#island_id: 2
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in range(6)]
  site_neighbors = []
  for i in range(3):
    site_neighbors.append(np.roll(h, -1, axis=i))
    site_neighbors.append(np.roll(h, 1, axis=i))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[:, i, j, k])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.37187739999999997}
#standard deviation: 0.04391969728083289
#island_id: 2
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = []
        for d in [3,4,5]:
          site_neighbors.extend([J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]])
        total_spin_neighbors = sum(J[d,i,j,k] for d in [3,4,5])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37187739999999997}
#standard deviation: 0.04391969728083289
#island_id: 2
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.extend([J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        
        total_spin_neighbors = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_count = sum([val for val in site_neighbors if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_count - 1)
        priorities[i * N * N + j * N + k][1] += 2 * site_neighbors_count
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val == h[i][j][k]]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_count = sum([val for val in site_neighbors if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5129914}
#standard deviation: 0.04280518807387722
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_count = sum([val for val in site_neighbors if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i * N * N + j * N + k][1] += 2 * neighbor_count
        
  return(priorities)




#score: {'data3D.txt': -0.33216260000000025}
#standard deviation: 0.05040887145374315
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < h[i][j][k]]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > h[i][j][k]]) + len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > h[i][j][k]]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < h[i][j][k]]) + len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1541757999999999}
#standard deviation: 0.046915934333230554
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.40911899999999995}
#standard deviation: 0.04385162390379631
#island_id: 3
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
  
  return priorities




#score: {'data3D.txt': 0.0019337999999999998}
#standard deviation: 0.046357971240769374
#island_id: 3
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        interacting_spins = 2 * J[0, i, j, k] * h[i-1 if i > 0 else N-1, j, k] + 2 * J[1, i, j, k] * h[i, j-1 if j > 0 else N-1, k] + 2 * J[2, i, j, k] * h[i, j, k-1 if k > 0 else N-1]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins >= 0)
        priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1) if interacting_spins >= 0 else min(priorities[i * N * N + j * N + k][1], -1)
        
  return(priorities)




#score: {'data3D.txt': -0.26695340000000006}
#standard deviation: 0.043670066045748086
#island_id: 3
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
  
  return priorities




#score: {'data3D.txt': -0.1740214}
#standard deviation: 0.044761835329217674
#island_id: 3
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
        
        for d in [0,1]:
          if (i + (d-1)%2 == 0):
            neighbor_spin = J[d,i+d,j,k]
          else:
            neighbor_spin = J[1-d,i-d,j,k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        
        neighbor_spin = J[2,i,j,k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], 1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], -1)
  
  return priorities




#score: {'data3D.txt': -0.09525139999999985}
#standard deviation: 0.0487407086329282
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2846350000000001}
#standard deviation: 0.04636383693138434
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * (1 + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * (1 + neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.00664819999999995}
#standard deviation: 0.047566429724754423
#island_id: 1
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        magnetism = h[i][j][k]
        interacting_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + len([val for val in interacting_spins if val < 0]) - abs(interacting_spin_sum) / 2)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + len([val for val in interacting_spins if val > 0]) - abs(interacting_spin_sum) / 2)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4868738}
#standard deviation: 0.039773130044792805
#island_id: 1
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + len([val for val in interacting_spins if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the site's own magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.0801362}
#standard deviation: 0.05642255550362815
#island_id: 1
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        priority = np.exp(-abs(total_spin)) * (total_neighbor_spin + len([val for val in interacting_spins if val < 0])) - 2 + 2 * total_spin
        priorities[i * N * N + j * N + k] = [priority, -priority]
  
  return priorities




#score: {'data3D.txt': -0.36065580000000014}
#standard deviation: 0.047379048179126616
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(2, 6):
          if i < N/3 and j < N/3:
            neighbor_spin = sum(J[d, :, j, k])
          elif i > 2*N/3 and j > 2*N/3:
            neighbor_spin = sum(J[5 - d, :, j, k])
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36065580000000014}
#standard deviation: 0.047379048179126616
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(2, 6):
          if i < N/3 and j < N/3:
            neighbor_spin = sum(J[d, :, j, k])
          elif i > 2*N/3 and j > 2*N/3:
            neighbor_spin = sum(J[5 - d, :, j, k])
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 2
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.11687900000000001}
#standard deviation: 0.04353028324052119
#island_id: 2
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1292478}
#standard deviation: 0.04505585772305306
#island_id: 2
#version_generated: 2
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbor = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbor
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_neighbor

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbor
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_neighbor

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2913758}
#standard deviation: 0.05251801304657289
#island_id: 1
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_count = np.sum(h[i % N, j % N, k % N] == h[i, j, k]) - 3
        
        priorities[i * N * N + j * N + k][0] = total_spin + site_neighbors_count
        priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_count = sum([val for val in site_neighbors if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_count - 1)
        priorities[i * N * N + j * N + k][1] += 2 * site_neighbors_count
        
  return(priorities)




#score: {'data3D.txt': -0.1421614}
#standard deviation: 0.052500398379821844
#island_id: 1
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_count = sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_count - 1)
        priorities[i * N * N + j * N + k][1] += 2 * site_neighbors_count
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 3
#version_generated: 2
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5258842}
#standard deviation: 0.04152726899713007
#island_id: 3
#version_generated: 2
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2485362}
#standard deviation: 0.04853203611595129
#island_id: 3
#version_generated: 2
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.5202926}
#standard deviation: 0.0424875975461075
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3559502}
#standard deviation: 0.049820865106499315
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        
        diagonal_neighbors = [J[0, i + i, j, k] if i < N/2 else J[1, i, i - i, k], 
                    J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diag_spin = sum([1 if val < 0 else -1 for val in diagonal_neighbors]) / len(diagonal_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - diag_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + diag_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3305458}
#standard deviation: 0.05026412778871231
#island_id: 0
#version_generated: 3
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin ** 2)
        priorities[i * N * N + j * N + k][1] -= 4 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.16232660000000015}
#standard deviation: 0.04674738251966628
#island_id: 0
#version_generated: 3
#generate time22:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) / len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors in z direction
        if i < (N // 2):
          neighbor_spin = J[0, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2990422000000001}
#standard deviation: 0.04478312024814707
#island_id: 0
#version_generated: 3
#generate time22:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        diagonal_neighbors = [J[0, i + (d % 2), j, k] for d in [0, 2]]
        diag_spin = sum([1 if val < 0 else -1 for val in diagonal_neighbors]) / len(diagonal_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + diag_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + diag_spin) + total_spin
          priorities[i * N * N + j * N + k][1] += len(interacting_spins) - 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d % 2) == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2485362}
#standard deviation: 0.04853203611595129
#island_id: 3
#version_generated: 3
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.48269500000000015}
#standard deviation: 0.04525692670741132
#island_id: 3
#version_generated: 3
#generate time22:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46125620000000006}
#standard deviation: 0.0433815131312867
#island_id: 3
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i+d) % N == site_nbr:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 1
          elif (i+d) % N == site_nbr+1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2485362}
#standard deviation: 0.04853203611595129
#island_id: 3
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.450449}
#standard deviation: 0.04603523996896291
#island_id: 3
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 3
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1959534}
#standard deviation: 0.04736693729216614
#island_id: 3
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5076294000000001}
#standard deviation: 0.04229124041264337
#island_id: 3
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in interacting_spins if val > 0])) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in interacting_spins if val < 0])) + sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in interacting_spins if val < 0])) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in interacting_spins if val > 0])) + sum(site_neighbors)
  
  return priorities




#score: {'data3D.txt': 0.04751940000000004}
#standard deviation: 0.04661482707937465
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] -= 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][0] += 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors_sum = np.sum([val for val in site_neighbors if val > 0]) - np.sum([val for val in site_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in interacting_spins if val < 0])) + site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in interacting_spins if val > 0])) + site_neighbors_sum

  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbors_sum / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.43967219999999996}
#standard deviation: 0.04015998041782391
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum([val for val in interacting_spins + site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighboring_spins = sum([val for val in site_neighbors if val == h[i][j][k]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - neighboring_spins
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1959534}
#standard deviation: 0.04736693729216614
#island_id: 3
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.17157740000000002}
#standard deviation: 0.048210602249297824
#island_id: 3
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + 2 * total_spin
        
        site_neighbors_site = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors_site if val < 0]) - len([val for val in site_neighbors_site if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors_site if val < 0]) - len([val for val in site_neighbors_site if val > 0])) + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 3
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.221649}
#standard deviation: 0.04797150611560992
#island_id: 3
#version_generated: 3
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0,1]:
          if (i+d) % N == site_nbr:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
          elif (i+d) % N == site_nbr+1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.471111}
#standard deviation: 0.04671225319977618
#island_id: 3
#version_generated: 3
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val < 0]) - len([val for val in interacting_spins[3:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val > 0]) - len([val for val in interacting_spins[3:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.450449}
#standard deviation: 0.04603523996896291
#island_id: 3
#version_generated: 3
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3835658000000001}
#standard deviation: 0.04954279029646998
#island_id: 3
#version_generated: 3
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional term to account for the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 * h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.4706846}
#standard deviation: 0.040896948576146855
#island_id: 3
#version_generated: 3
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.17157740000000002}
#standard deviation: 0.048210602249297824
#island_id: 3
#version_generated: 3
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + 2 * total_spin
        
        site_neighbors_site = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors_site if val < 0]) - len([val for val in site_neighbors_site if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors_site if val < 0]) - len([val for val in site_neighbors_site if val > 0])) + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.17157740000000002}
#standard deviation: 0.048210602249297824
#island_id: 3
#version_generated: 3
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + 2 * total_spin
        
        site_neighbors_site = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors_site if val < 0]) - len([val for val in site_neighbors_site if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors_site if val < 0]) - len([val for val in site_neighbors_site if val > 0])) + 2 * total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.47573620000000005}
#standard deviation: 0.041242335161336345
#island_id: 3
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[-1:] if val < 0]) - len([val for val in interacting_spins[-1:] if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.10131099999999998}
#standard deviation: 0.04620145581039627
#island_id: 3
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, j, k], J[4, (i+1)%N, j, k], J[5, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 3
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 3
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1, 2]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * int(J[d, i, j, k] < 0)
          priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4706846}
#standard deviation: 0.040896948576146855
#island_id: 3
#version_generated: 3
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4706846}
#standard deviation: 0.040896948576146855
#island_id: 3
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4706846}
#standard deviation: 0.040896948576146855
#island_id: 3
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4806974}
#standard deviation: 0.04121865006571661
#island_id: 3
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4806974}
#standard deviation: 0.04121865006571661
#island_id: 3
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i+k-1)%N, j, (k+1)%N].sum(), J[1, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum()]
        total_neighbor_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4806974}
#standard deviation: 0.04121865006571661
#island_id: 3
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4806974}
#standard deviation: 0.04121865006571661
#island_id: 3
#version_generated: 3
#generate time22:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.024883799999999973}
#standard deviation: 0.04862795880519766
#island_id: 3
#version_generated: 3
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.1959534}
#standard deviation: 0.04736693729216614
#island_id: 3
#version_generated: 3
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1824486}
#standard deviation: 0.04766974552103252
#island_id: 3
#version_generated: 3
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1, 2]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * int(J[d, i, j, k] < 0)
          priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0]) + 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.11996579999999998}
#standard deviation: 0.04716803738083661
#island_id: 3
#version_generated: 3
#generate time22:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + np.exp(abs(total_neighbor_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - np.exp(abs(total_neighbor_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.1292478}
#standard deviation: 0.04505585772305306
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin_neighbor = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbor
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_neighbor
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbor
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_neighbor
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.48269500000000015}
#standard deviation: 0.04525692670741132
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1616834}
#standard deviation: 0.050301598030678914
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4829982000000001}
#standard deviation: 0.04312486657092402
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
          J[0, (i + 1) % N, j, k],
          J[1, i, (j + 1) % N, k],
          J[2, i, j, (k + 1) % N]
        ]
        interacting_spins.extend(site_neighbors)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0199538}
#standard deviation: 0.047116491227170126
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = []
        for axis in range(3):
          site_neighbors.append(J[axis,i,(j+1)%N,k])
          site_neighbors.append(J[axis+3,i,j,(k+1)%N])
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.24171339999999997}
#standard deviation: 0.04901548551672216
#island_id: 0
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([1 if val < 0 else -1 for val in site_neighbors]) / len(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * neighbor_spin
        
        for d in range(3, 6):
          if i < N/3 and j < N/3:
            neighbor_spin = sum(J[d, :, j, k])
          elif i > 2*N/3 and j > 2*N/3:
            neighbor_spin = sum(J[5 - d, :, j, k])
          else:
            neighbor_spin = 0
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4241278}
#standard deviation: 0.04376489674567964
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_count = sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val == h[i][j][k]])
        
        priorities[i * N * N + j * N + k][0] = -total_spin + 3*np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_neighbors_count
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.4551814}
#standard deviation: 0.04298210341572409
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) - total_spin)
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_count = sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val == h[i][j][k]])
        site_neighbors = [val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val != h[i][j][k]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] += 2 * len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[d, (i+1)%N, j, k] for d in [0, 1]]
        interacting_spins_y = [J[d, i, (j+1)%N, k] for d in [2, 4]]
        interacting_spins_z = [J[d, i, j, (k+1)%N] for d in [5]]
        
        site_neighbors_count = sum([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val == h[i][j][k]])
        
        priorities[i * N * N + j * N + k][0] = (site_neighbors_count - 1) / 6
        priorities[i * N * N + j * N + k][1] = 2 * site_neighbors_count / 6
  
  return(priorities)




#score: {'data3D.txt': -0.1810418}
#standard deviation: 0.059145042503662135
#island_id: 1
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[d, i, (j+1)%N, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors_count = sum([val for val in interacting_spins if val == h[i][j][k]])
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (site_neighbors_count - 1) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.114483}
#standard deviation: 0.06332786899146378
#island_id: 2
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if i > 0:
          site_neighbors.append(J[0, i-1, j, k])
        if i < N - 1:
          site_neighbors.append(J[0, i+1, j, k])
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if j < N - 1:
          site_neighbors.append(J[1, i, j+1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        if k < N - 1:
          site_neighbors.append(J[2, i, j, k+1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.append(sum(site_neighbors))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 2
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.1216758}
#standard deviation: 0.046110401151584005
#island_id: 3
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)

        for d in range(3):
          if J[d, site_nbr, (j + 1) % N, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, site_nbr, (j + 1) % N, k] > 0) - int(J[d, site_nbr, (j + 1) % N, k] < 0)
          elif J[d, site_nbr, (j + 1) % N, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]] if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, site_nbr, (j + 1) % N, k] < 0) + int(J[d, site_nbr, (j + 1) % N, k] > 0)

  return(priorities)




#score: {'data3D.txt': 0.024883799999999973}
#standard deviation: 0.04862795880519766
#island_id: 3
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 2
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23330740000000008}
#standard deviation: 0.042887246883426794
#island_id: 0
#version_generated: 3
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[0, :, j, k])) / N**2) * len([val for val in J[0, :, j, k] if val < 0]) + np.sum(J[0, :, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (np.sum(J[0, :, j, k]) / N**2)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum(np.abs(J[0, :, j, k])) / N**2) * len([val for val in J[0, :, j, k] if val > 0]) + np.sum(J[0, :, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (np.sum(J[0, :, j, k]) / N**2)
        
        for d in [1, 3]:
          neighbor_spin = np.sum(J[d, i, :, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, i, :, k])) / N**2) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, i, :, k])) / N**2) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [1, 3]:
          neighbor_spin = np.sum(J[d, :, j, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, :, j, k])) / N**2) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, :, j, k])) / N**2) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36780179999999996}
#standard deviation: 0.0390309051491251
#island_id: 0
#version_generated: 3
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        for d in [2, 3]:
          neighbor_spin = sum(J[d, i, :, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2, 3]:
          neighbor_spin = sum(J[d, :, j, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.43967219999999996}
#standard deviation: 0.04015998041782391
#island_id: 1
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum([val for val in interacting_spins + site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.46766820000000003}
#standard deviation: 0.04083497653678767
#island_id: 1
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum([val for val in interacting_spins + site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.43967219999999996}
#standard deviation: 0.04015998041782391
#island_id: 1
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum([val for val in interacting_spins + site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 2
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.41364460000000014}
#standard deviation: 0.04892275269074707
#island_id: 3
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val < 0]) - len([val for val in interacting_spins[3:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val > 0]) - len([val for val in interacting_spins[3:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional term to account for the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.41364460000000014}
#standard deviation: 0.04892275269074707
#island_id: 3
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val < 0]) - len([val for val in interacting_spins[3:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val > 0]) - len([val for val in interacting_spins[3:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional term to account for the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 * h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.3835658000000001}
#standard deviation: 0.04954279029646998
#island_id: 3
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional term to account for the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.471111}
#standard deviation: 0.04671225319977618
#island_id: 3
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val < 0]) - len([val for val in interacting_spins[3:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val > 0]) - len([val for val in interacting_spins[3:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 0
#version_generated: 3
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins_x = J[0, i, j, k]
        interacting_spins_y = J[1, i, j, k]
        interacting_spins_z = J[2, i, j, k]
        
        site_spin = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs([site_spin] + [interacting_spins_x, interacting_spins_y, interacting_spins_z])) / 3) * (2 if site_spin == 1 and all(x < 0 for x in [interacting_spins_x, interacting_spins_y, interacting_spins_z]) else -2)
        priorities[i * N * N + j * N + k][1] = np.sum(np.abs([site_spin] + [interacting_spins_x, interacting_spins_y, interacting_spins_z])) / 3
  
  return(priorities)




#score: {'data3D.txt': -0.2142618}
#standard deviation: 0.036622238882405865
#island_id: 0
#version_generated: 3
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_spin_sum = sum(site_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[:, i, j, k])) / N**2) * len([val for val in J[:, i, j, k] if val < 0]) + site_spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (site_spin_sum / N**3)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum(np.abs(J[:, i, j, k])) / N**2) * len([val for val in J[:, i, j, k] if val > 0]) + site_spin_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (site_spin_sum / N**3)
        
        for d in [0, 1, 2]:
          neighbor_spin = sum(J[d, i, :, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, i, :, k])) / N**3) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, i, :, k])) / N**3) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1, 2]:
          neighbor_spin = sum(J[d, :, j, k])
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, :, j, k])) / N**3) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[d, :, j, k])) / N**3) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.24933860000000002}
#standard deviation: 0.04647558100809499
#island_id: 0
#version_generated: 3
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(np.abs(J[0:3, i, j, k])) / N**2) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin / N**2)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum(np.abs(J[0:3, i, j, k])) / N**2) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin / N**2)
        
  return(priorities)




#score: {'data3D.txt': -0.0033837999999999997}
#standard deviation: 0.046942479882937586
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_spin = J[1, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + site_nbr_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.16496460000000002}
#standard deviation: 0.34335853970280106
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.048256599999999976}
#standard deviation: 0.0562815511197053
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          edge_score = sum(1 if neighbor < 0 else -1 for neighbor in edge_neighbors)
          site_score = sum(1 if neighbor < 0 else -1 for neighbor in site_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (edge_score + site_score) / 6
          priorities[i * N * N + j * N + k][1] -= edge_score + site_score
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          edge_score = sum(1 if neighbor > 0 else -1 for neighbor in edge_neighbors)
          site_score = sum(1 if neighbor > 0 else -1 for neighbor in site_neighbors)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (edge_score + site_score) / 6
          priorities[i * N * N + j * N + k][1] += edge_score + site_score
          
  return(priorities)




#score: {'data3D.txt': -0.2396454000000004}
#standard deviation: 0.04595981874246242
#island_id: 1
#version_generated: 2
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 2
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.08829459999999983}
#standard deviation: 0.04606642910884238
#island_id: 1
#version_generated: 2
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_count = sum(1 for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.29812540000000004}
#standard deviation: 0.046391425876340556
#island_id: 1
#version_generated: 2
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(val for val in interacting_spins)
        
        site_neighbors = [J[d, i, (j + 1) % N, k] if d == 0 else J[d, (i + 1) % N, j, k] if d == 1 else J[d, i, j, (k + 1) % N] for d in range(3)]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2396454000000004}
#standard deviation: 0.04595981874246242
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': 0.08964580000000005}
#standard deviation: 0.04783545570348422
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0,1,2,3,4,5]:
          if interacting_spins[d][i][j][k] < 0:
            total_spin -= 1
          elif interacting_spins[d][i][j][k] > 0:
            total_spin += 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0757406}
#standard deviation: 0.0462403965341994
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[2, i, j, k - 1]
        
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2396454000000004}
#standard deviation: 0.04595981874246242
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.46707300000000007}
#standard deviation: 0.043050312786320155
#island_id: 3
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])

          diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.46707300000000007}
#standard deviation: 0.043050312786320155
#island_id: 3
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])

        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])

          diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4600634}
#standard deviation: 0.041613675882334646
#island_id: 3
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4806974}
#standard deviation: 0.04121865006571661
#island_id: 3
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        total_diagonal_spin = sum([val for val in diagonally_neighbors if val > 0]) - sum([val for val in diagonally_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        diagonally_neighbors = [J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_diagonal_spin - len([val for val in diagonally_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4831134000000001}
#standard deviation: 0.04123801523400466
#island_id: 3
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2485362}
#standard deviation: 0.04853203611595129
#island_id: 3
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.append(sum(site_neighbors))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1122834}
#standard deviation: 0.05691830184079634
#island_id: 3
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        # Add the contribution from all 6 neighboring sites
        neighbors = [(i+1, j, k), (i-1, j, k), (i, j+1, k), (i, j-1, k), (i, j, k+1), (i, j, k-1)]
        for ni, nj, nk in neighbors:
          if 0 <= ni < N and 0 <= nj < N and 0 <= nk < N:
            neighbor_spin = sum(J[d, ni, nj, nk] for d in [0, 1, 2])
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.sum(np.abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val > 0]) - len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4076422000000003}
#standard deviation: 0.048189091910514355
#island_id: 1
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  # additional improvement
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.05686499999999999}
#standard deviation: 0.05620998109766628
#island_id: 2
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13189179999999998}
#standard deviation: 0.052737626157801226
#island_id: 2
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        for l in range(3):
          interacting_spins[l] = J[l, i, (j+1)%N, k]
          site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        for l in range(3):
          interacting_spins[l] = J[l, i, j, (k+1)%N]
          site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2229126}
#standard deviation: 0.045801262004883665
#island_id: 2
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49525300000000005}
#standard deviation: 0.04154795050300315
#island_id: 2
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4687442}
#standard deviation: 0.03994008170196951
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.07095459999999999}
#standard deviation: 0.05492740134796112
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(val for val in interacting_spins)
        
        site_neighbors = [J[d, i, (j + 1) % N, k] if d == 0 else J[d, (i + 1) % N, j, k] if d == 1 else J[d, i, j, (k + 1) % N] for d in range(3)]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1949062}
#standard deviation: 0.04571042989909414
#island_id: 3
#version_generated: 3
#generate time23:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0257682}
#standard deviation: 0.04979747612841438
#island_id: 3
#version_generated: 3
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        # Add the contribution from all 6 neighboring sites
        neighbors = [(i+1, j, k), (i-1, j, k), (i, j+1, k), (i, j-1, k), (i, j, k+1), (i, j, k-1)]
        for ni, nj, nk in neighbors:
          if 0 <= ni < N and 0 <= nj < N and 0 <= nk < N:
            neighbor_spin = sum(J[d, ni, nj, nk] for d in [0, 1, 2])
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.1122834}
#standard deviation: 0.05691830184079634
#island_id: 3
#version_generated: 3
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

        # Add the contribution from all 6 neighboring sites
        neighbors = [(i+1, j, k), (i-1, j, k), (i, j+1, k), (i, j-1, k), (i, j, k+1), (i, j, k-1)]
        for ni, nj, nk in neighbors:
          if 0 <= ni < N and 0 <= nj < N and 0 <= nk < N:
            neighbor_spin = sum(J[d, ni, nj, nk] for d in [0, 1, 2])
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.04827820000000001}
#standard deviation: 0.06761634480478813
#island_id: 3
#version_generated: 3
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        # Add the contribution from all 6 neighboring sites
        neighbors = [(i+1, j, k), (i-1, j, k), (i, j+1, k), (i, j-1, k), (i, j, k+1), (i, j, k-1)]
        for ni, nj, nk in neighbors:
          if 0 <= ni < N and 0 <= nj < N and 0 <= nk < N:
            neighbor_spin = sum(J[d, ni, nj, nk] for d in [0, 1, 2])
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val < 0]) - len([val for val in [J[0, ni, nj, nk], J[1, ni, nj, nk], J[2, ni, nj, nk]] if val > 0]))
        
        # Add the contribution from the site itself
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [h[i][j][k], J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [h[i][j][k], J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in [h[i][j][k], J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [h[i][j][k], J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.35461859999999995}
#standard deviation: 0.04341154701274766
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  # Add a term to encourage the sites with more neighbors to flip
  for i in range(N):
    for j in range(N):
      for k in range(N):
        neighbor_count = 0
        for d in [0, 1, 2]:
          if (i == 0 or J[d, 0, j, k] > 0) and (j == 0 or J[d, i, 0, k] > 0) and (k == 0 or J[d, i, j, 0] > 0):
            neighbor_count += 1
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_count
        priorities[i * N * N + j * N + k][1] -= neighbor_count
  
  return(priorities)




#score: {'data3D.txt': -0.1011766}
#standard deviation: 0.04524589586293988
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val if val < 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) + len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3680742}
#standard deviation: 0.0414501635022107
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  # additional improvement
  interacting_spins = [J[d, i, j, k] for d in range(6)]
  total_spin = sum(J[d, i, j, k] for d in range(6))
  
  site_nbr = (i + ((k - 1) % 2 - 1)) % N
  if h[i][j][k] > 0:
    priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
    priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  else:
    priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
    priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_spin = J[2, i, j, k]
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.014277800000000018}
#standard deviation: 0.04631058526039161
#island_id: 2
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        # Additional improvement: adjust the bias term based on the number of neighboring sites with the same spin
        neighbors = [(i+1)%N, (j+1)%N]
        same_spin_count = sum(val > 0 for d in range(2) for val in [J[0, i, j, k], J[1, i, j, k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count >= 2)
          priorities[i * N * N + j * N + k][1] -= same_spin_count
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (same_spin_count <= -2)
          priorities[i * N * N + j * N + k][1] = -same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.2229126}
#standard deviation: 0.045801262004883665
#island_id: 2
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.11620339999999998}
#standard deviation: 0.04592584140154647
#island_id: 2
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_values = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_values = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_values if val < 0]) - len([val for val in site_neighbors_values if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors_values if val < 0]) - len([val for val in site_neighbors_values if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.471111}
#standard deviation: 0.04671225319977618
#island_id: 3
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val < 0]) - len([val for val in interacting_spins[3:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:] if val > 0]) - len([val for val in interacting_spins[3:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34448059999999997}
#standard deviation: 0.04442795002743206
#island_id: 3
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with diagonally neighboring sites
        interacting_spins.append(sum(J[d, (i+j+k-3)%N, (j+k-2)%N, (k+1)%N].sum() for d in [0,1,2]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[3:] if val < 0]) - len([val for val in interacting_spins[3:] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[3:] if val > 0]) - len([val for val in interacting_spins[3:] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional term to account for the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * (h[i][j][k] - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (h[i][j][k] + len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 * (h[i][j][k] + len([val for val in interacting_spins if val > 0]))
          
  return(priorities)




#score: {'data3D.txt': 0.0072382}
#standard deviation: 0.04752864337176057
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = []
        for axis in range(3):
          site_neighbors.append(J[axis, i, (j+1)%N, k])
          site_neighbors.append(J[axis+3, i, j, (k+1)%N])
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] = -len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+k][1] = 2 - 2*total_spin
        else:
          priorities[i*N*N+k][0] = len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0199538}
#standard deviation: 0.047116491227170126
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = []
        for axis in range(3):
          site_neighbors.append(J[axis, i, (j+1)%N, k])
          site_neighbors.append(J[axis+3, i, j, (k+1)%N])
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.076495}
#standard deviation: 0.04808763224572406
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = []
        for axis in range(3):
          site_neighbors.append(J[axis,i,(j+1)%N,k])
          site_neighbors.append(J[axis+3,i,j,(k+1)%N])
        
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2*total_spin
        else:
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + site_nbr][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3014802}
#standard deviation: 0.05035720889763451
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.048256599999999976}
#standard deviation: 0.0562815511197053
#island_id: 0
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          edge_score = sum(1 if neighbor < 0 else -1 for neighbor in edge_neighbors)
          site_score = sum(1 if neighbor < 0 else -1 for neighbor in site_neighbors)

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (edge_score + site_score) / 6
          priorities[i * N * N + j * N + k][1] -= edge_score + site_score

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          edge_score = sum(1 if neighbor > 0 else -1 for neighbor in edge_neighbors)
          site_score = sum(1 if neighbor > 0 else -1 for neighbor in site_neighbors)

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (edge_score + site_score) / 6
          priorities[i * N * N + j * N + k][1] += edge_score + site_score

  return priorities




#score: {'data3D.txt': 0.0022562000000000007}
#standard deviation: 0.04581109998199127
#island_id: 3
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_1d = [J[d, (i+k-1)%N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        spin_priority = np.exp(-abs(total_spin)) * len([val for val in interacting_spins_1d if val < 0]) - 2 * sum([val for val in site_neighbors if val > 0])
        
        antispin_priority = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins_1d if val > 0]) + 2 * sum([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] = spin_priority
        priorities[i * N * N + j * N + k][1] = antispin_priority
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
        for d in range(6):
          interacting_spins.append(J[d, i, (j+1)%N, k])
          interacting_spins.append(J[d, (i+1)%N, j, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 2
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43346460000000014}
#standard deviation: 0.04397167300478798
#island_id: 2
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [(d+1)%6 for d in range(6)]]
        total_spin = sum(J[d, i, j, k] for d in [(d+1)%6 for d in range(6)])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4910078000000001}
#standard deviation: 0.04473334303581613
#island_id: 2
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional improvement based on the site's magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.4014154}
#standard deviation: 0.046065532047725226
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d == 0 else (j+1)%N if d == 1 else (k+1)%N if d == 2 else i, j, k] 
                   for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) 
        priorities[i * N * N + j * N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0523458}
#standard deviation: 0.047856223653355685
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = J[:, i, j, k]
        total_spin = np.sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -total_spin
        
        site_neighbors = J[:, i, (j + 1) % N, k] + J[:, (i + 1) % N, j, k] + J[:, i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.49525300000000005}
#standard deviation: 0.04154795050300315
#island_id: 2
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0178366}
#standard deviation: 0.04483687567661244
#island_id: 1
#version_generated: 3
#generate time23:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[2, i, j, k - 1]
        
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
        site_nbr = (i + ((j - 1) % 2 - 1)) % N
        neighbor_spin = J[1, i, j - 1, k]
        
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.19758420000000007}
#standard deviation: 0.04861433235538673
#island_id: 1
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[2, i, j, k - 1]
        
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_spin = J[2, i, j, k]
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin and site spin
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = J[2, i, j, k]
        
        if h[i][j][k] > 0:
          # For positive magnetism, assign higher priority to the same spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          # For negative magnetism, assign higher priority to the opposite spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_spin = J[2, i, j, k]
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.08869540000000004}
#standard deviation: 0.04552519367163638
#island_id: 2
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) * N * N + (j - 1) * N + i
        for d in range(3):
          if J[d, site_neighbors[0], site_neighbors[1], site_neighbors[2]] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] += total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49525300000000005}
#standard deviation: 0.04154795050300315
#island_id: 2
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4829982000000001}
#standard deviation: 0.04312486657092402
#island_id: 3
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [
          J[0, (i+1)%N, j, k],
          J[1, i, (j+1)%N, k],
          J[2, i, j, (k+1)%N]
        ]
        interacting_spins = [val for sublist in [[J[d,i,j,k] for d in [0,1,2]], site_neighbors] for val in sublist]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5082142000000001}
#standard deviation: 0.042414386219300645
#island_id: 3
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k)%N, (j+int((k-1)/2))%N, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47474380000000016}
#standard deviation: 0.044234773669139534
#island_id: 3
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [
          J[0, (i + 1) % N, j, k],
          J[1, i, (j + 1) % N, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * total_neighbor_spin + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * total_neighbor_spin + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': -0.4829982000000001}
#standard deviation: 0.04312486657092402
#island_id: 3
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [
          J[0,(i+1)%N,j,k],
          J[1,i,(j+1)%N,k],
          J[2,i,j,(k+1)%N]
        ]
        interacting_spins.extend(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * sum(1 for val in interacting_spins if val < 0) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2]))) * sum(1 for val in interacting_spins if val > 0) + sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])

  return(priorities)




#score: {'data3D.txt': -0.4177866}
#standard deviation: 0.04525619714956174
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1810418}
#standard deviation: 0.059145042503662135
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the difference between the number of neighbors with spin up and down
        priority_diff = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        priorities[i * N * N + j * N + k][0] += priority_diff
        priorities[i * N * N + j * N + k][1] -= priority_diff
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1810418}
#standard deviation: 0.059145042503662135
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Combine similar terms
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31253380000000003}
#standard deviation: 0.04458851844993283
#island_id: 0
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4177866}
#standard deviation: 0.04525619714956174
#island_id: 0
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4177866}
#standard deviation: 0.04525619714956174
#island_id: 0
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1863754}
#standard deviation: 0.05666444665608234
#island_id: 0
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  import numpy as np

  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)] if val < 0]) - len([val for val in [J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)] if val > 0]) - len([val for val in [J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49582740000000003}
#standard deviation: 0.04171482145760665
#island_id: 0
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d - 1) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in [0, 1, 2]:
          if J[d, (i + d - 1) % N, j, k] > 0 and h[i][j][k] > 0 or J[d, (i + d - 1) % N, j, k] < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in [0, 1, 2]:
          if J[d, (i + d - 1) % N, j, k] < 0 and h[i][j][k] > 0 or J[d, (i + d - 1) % N, j, k] > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3700682}
#standard deviation: 0.0422969307250538
#island_id: 0
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          # For positive magnetism, assign higher priority to the same spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          # For negative magnetism, assign higher priority to the opposite spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44689340000000005}
#standard deviation: 0.04116139789219992
#island_id: 0
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        # Calculate the total spin and site spin
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          # For positive magnetism, assign higher priority to the same spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          # For negative magnetism, assign higher priority to the opposite spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin) / 3 - 1)
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin) / 3 - 1)
          priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.2122398}
#standard deviation: 0.04369188547041659
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        
        # Add a new term based on the site's local magnetic field
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4687442}
#standard deviation: 0.03994008170196951
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4687442}
#standard deviation: 0.03994008170196951
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val > 0]) + total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.105271}
#standard deviation: 0.05783840557103904
#island_id: 0
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) - sum([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3524782}
#standard deviation: 0.053692541798279585
#island_id: 0
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.353553}
#standard deviation: 0.05515553708377791
#island_id: 0
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (i+1)%N if d==0 else i-1 if d==5 else j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 3
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 3
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 3
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 3
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4394010000000002}
#standard deviation: 0.048028528594992376
#island_id: 3
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[0, (i-1)%N, (j+1)%N, k], J[1, i, (j-1)%N, k], J[2, (i+1)%N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          diag_nbr = (i + ((k - 1) % 3 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in diagonal_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          diag_nbr = (i + ((k - 1) % 3 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in diagonal_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[0, i-1, j, k] if i > 0 else 0, J[1, i, j-1, k] if j > 0 else 0, J[2, i+1, j, k] if i < N - 1 else 0, J[0, i, j+1, k] if j < N - 1 else 0, J[1, i-1, j, k] if i > 0 and j > 0 else 0, J[2, i, j-1, k] if i > 0 and j > 0 else 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0007633999999999995}
#standard deviation: 0.0458766247716634
#island_id: 3
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+k-1)%N, j, (k+1)%N].sum() for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([1 if val < 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.16496460000000002}
#standard deviation: 0.34335853970280106
#island_id: 0
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.16496460000000002}
#standard deviation: 0.34335853970280106
#island_id: 0
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2770214}
#standard deviation: 0.12842350525522972
#island_id: 0
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1453838}
#standard deviation: 0.32955204568862867
#island_id: 0
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          elif (i + (d - 2) % 3 == 1):
            neighbor_spin = J[4 - d, i - d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0 or neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.43346460000000014}
#standard deviation: 0.04397167300478798
#island_id: 2
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[(d+1)%6, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_nbr_values = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        for d in range(3):
          if site_nbr_values[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] -= total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.39027459999999997}
#standard deviation: 0.04112428278815328
#island_id: 0
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - sum([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - sum([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if J[d, (i+d-1)%N, j, k] > 0 and h[i][j][k] > 0 or J[d, (i+d-1)%N, j, k] < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if J[d, (i+d-1)%N, j, k] < 0 and h[i][j][k] > 0 or J[d, (i+d-1)%N, j, k] > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.38319179999999997}
#standard deviation: 0.055427749483088345
#island_id: 0
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d - 1) % N, j, k] for d in [0, 1, 2]] + \
                   [J[d, i, (j + d - 1) % N, k] for d in [3, 4]] + \
                   [J[d, i, j, (k + d - 1) % N] for d in [5]]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.16496460000000002}
#standard deviation: 0.34335853970280106
#island_id: 0
#version_generated: 3
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  site_neighbors = [np.roll(h, 1, axis=i) for i in range(3)] + [h]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin as site's spin
        for d in range(6):
          if np.all(J[d, :, i, k] == h[i][j][k]) or np.all(J[d, i, :, k] == h[i][j][k]) or np.all(J[d, i, j, :] == h[i][j][k]):
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with opposite spin as site's spin
        for d in range(6):
          if np.all(J[d, :, i, k] == -h[i][j][k]) or np.all(J[d, i, :, k] == -h[i][j][k]) or np.all(J[d, i, j, :] == -h[i][j][k]):
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.16496460000000002}
#standard deviation: 0.34335853970280106
#island_id: 0
#version_generated: 3
#generate time23:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, : , :, :] for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0].flatten()[:N**2] if val > 0]) - len([val for val in interacting_spins[0].flatten()[:N**2] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1531774000000001}
#standard deviation: 0.04887905982360954
#island_id: 3
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= int(J[2, i, j, k] > 0) - int(J[2, i, j, k] < 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -int(J[2, i, j, k] < 0) + int(J[2, i, j, k] > 0)

  return(priorities)




#score: {'data3D.txt': -0.3014802}
#standard deviation: 0.05035720889763451
#island_id: 3
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_values = [val for val in interacting_spins if val != 0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin_values if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin_values if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.008250600000000005}
#standard deviation: 0.05469385669012562
#island_id: 3
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)
        
        # Add the neighbor spin
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.09403660000000001}
#standard deviation: 0.05129799743108887
#island_id: 3
#version_generated: 3
#generate time23:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)
        
        for d in range(3):
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= int(J[d, i, j, k] > 0) - int(J[d, i, j, k] < 0)
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -int(J[d, i, j, k] < 0) + int(J[d, i, j, k] > 0)
        
  return(priorities)




