#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -34443529954139.8}
#standard deviation: 1088655316868470.5
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': 1152921495311.7778}
#standard deviation: 36440345036493.94
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -2100239.4998092}
#standard deviation: 66382172.96340937
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': 11096869494809.201}
#standard deviation: 350738324213726.44
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: None
#version_generated: None
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.5150604000000001}
#standard deviation: 0.04178103339842135
#island_id: 2
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin

  return(priorities)




#score: {'data3D.txt': -0.5150604000000001}
#standard deviation: 0.04178103339842135
#island_id: 2
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin

  return(priorities)




#score: {'data3D.txt': -0.5149464}
#standard deviation: 0.0414470902119799
#island_id: 2
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5150604000000001}
#standard deviation: 0.04178103339842135
#island_id: 2
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin

  return(priorities)




#score: {'data3D.txt': -0.5385840000000001}
#standard deviation: 0.04113275560912496
#island_id: 0
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5242496000000001}
#standard deviation: 0.04157763172476278
#island_id: 0
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.49348720000000007}
#standard deviation: 0.054656620423879115
#island_id: 0
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.2112788}
#standard deviation: 0.05363185798161388
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :, :], axis=0) + h
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = J[[0, 1, 2], i, (j + 1) % N, k] + J[[0, 1, 2], (i + 1) % N, j, k] + J[[0, 1, 2], i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.034547600000000005}
#standard deviation: 0.04589024269101222
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.005405999999999999}
#standard deviation: 0.04693571735895809
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] * interacting_spins[d] for d in [(i // N // N + k) % 3 for k in range(6)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.047010800000000005}
#standard deviation: 0.047356532425421524
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    # Add interactions along other axes
    for d in range(3):
      if i % N != 0:
        interacting_spins.append(J[d, (i-1)%N, i // N % N, i // N // N])
      if i % N != N-1:
        interacting_spins.append(J[d, (i+1)%N, i // N % N, i // N // N])
      if i // N % N != 0:
        interacting_spins.append(J[d, i % N, (i-1)%N//N, i // N // N])
      if i // N % N != N-1:
        interacting_spins.append(J[d, i % N, (i+1)%N//N, i // N // N])
      if i // N // N != 0:
        interacting_spins.append(J[d, i % N, i // N % N, (i-1)%N//N//N])
      if i // N // N != N-1:
        interacting_spins.append(J[d, i % N, i // N % N, (i+1)%N//N//N])
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in range(6))
    priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
    priorities[i][1] -= 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.034547600000000005}
#standard deviation: 0.04589024269101222
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.3042664}
#standard deviation: 0.0435175834696735
#island_id: 3
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_energy = h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.015917200000000017}
#standard deviation: 0.04741942074888727
#island_id: 3
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [1,2,3]]
        total_spin = sum(J[d,i,j,k] for d in [1,2,3])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[0,site_nbr,j,k] * h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.09388440000000012}
#standard deviation: 0.04732969212492302
#island_id: 3
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [1,2,3]]
        total_spin = sum(J[d,i,j,k] for d in [1,2,3])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
        
  return priorities




#score: {'data3D.txt': -0.5456616}
#standard deviation: 0.040751232195358214
#island_id: 2
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5149464}
#standard deviation: 0.0414470902119799
#island_id: 2
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5069864}
#standard deviation: 0.041473985762644036
#island_id: 2
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.5149464}
#standard deviation: 0.0414470902119799
#island_id: 2
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.017985599999999997}
#standard deviation: 0.04823441709650901
#island_id: 1
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] * interacting_spins[d] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    # Add a new term based on the site interaction
    site_neighbors = [J[0, i % N, (i // N) % N, i // N // N], J[1, (i // N) % N, i % N, i // N // N], J[2, i % N, i // N % N, i // N // N]]
    site_total_spin = sum(J[d, i % N, i // N % N, i // N // N] * site_neighbors[d] for d in range(3))
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(site_total_spin)) * len([val for val in site_neighbors if val < 0]) + site_total_spin
      priorities[i][1] -= 2 - 2 * site_total_spin
    else:
      priorities[i][0] -= np.exp(-abs(site_total_spin)) * len([val for val in site_neighbors if val > 0]) + site_total_spin
      priorities[i][1] = -2 + 2 * site_total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0061204000000000015}
#standard deviation: 0.048260714290611156
#island_id: 1
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] * interacting_spins[d] for d in [(i // N // N + k) % 3 for k in range(6)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] = -2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.005405999999999999}
#standard deviation: 0.04693571735895809
#island_id: 1
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] * interacting_spins[d] for d in [(i // N // N + k) % 3 for k in range(6)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5149464}
#standard deviation: 0.0414470902119799
#island_id: 2
#version_generated: 3
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0223472}
#standard deviation: 0.04591934420437643
#island_id: 3
#version_generated: 3
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += site_energy * len([val for val in interacting_spins if val < 0]) - (total_spin + site_energy)
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] -= site_energy * len([val for val in interacting_spins if val > 0]) - (total_spin - site_energy)
          priorities[i*N*N+j*N+k][1] += site_energy
  
  return priorities




#score: {'data3D.txt': -0.5129248000000001}
#standard deviation: 0.04463898682721193
#island_id: 2
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add terms for neighboring spins in x, y, and z directions
        if i > 0:
          neighbor_spin = J[0, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

        if i < N-1:
          neighbor_spin = J[0, i+1, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5211188000000001}
#standard deviation: 0.0407307663389728
#island_id: 2
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.561046}
#standard deviation: 0.04001792353433646
#island_id: 2
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5385840000000001}
#standard deviation: 0.04113275560912496
#island_id: 2
#version_generated: 3
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3821646000000001}
#standard deviation: 0.04348052514448279
#island_id: 1
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0, i, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.020420200000000003}
#standard deviation: 0.04615932963074745
#island_id: 1
#version_generated: 3
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_nbr = (i // N % N + ((i // N // N + 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 3) % 6]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 3) % 6])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.13376340000000017}
#standard deviation: 0.04622987238182689
#island_id: 3
#version_generated: 3
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [1,2,3]]
        total_spin = sum(J[d,i,j,k] for d in [1,2,3])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 4 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 4 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [1,2,3]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += J[0,site_nbr,j,k] * h[site_nbr][j][k]
          
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0002582000000000213}
#standard deviation: 0.047681991702947985
#island_id: 3
#version_generated: 3
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [1,2,3]]
        total_spin = sum(J[d,i,j,k] for d in [1,2,3])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[0,site_nbr,j,k] * h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': 0.06078499999999991}
#standard deviation: 0.0477313772585707
#island_id: 3
#version_generated: 3
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy + np.exp(-site_energy) * (total_spin / 6 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 6 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[0,site_nbr,j,k] * h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': 0.2560838}
#standard deviation: 0.04475772980793374
#island_id: 3
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': 0.2560838}
#standard deviation: 0.04475772980793374
#island_id: 3
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': 0.2560838}
#standard deviation: 0.04475772980793374
#island_id: 3
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': 0.2560838}
#standard deviation: 0.04475772980793374
#island_id: 3
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          if site_energy > 0:
            priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
            priorities[i*N*N+j*N+k][1] -= site_energy
  
  return priorities




#score: {'data3D.txt': -0.5272650000000001}
#standard deviation: 0.041248348997262915
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5031554}
#standard deviation: 0.04080529439717351
#island_id: 0
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.03366700000000024}
#standard deviation: 0.049408096006626295
#island_id: 3
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins[0:3,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins[3:6,i,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  return priorities




#score: {'data3D.txt': -0.4251526000000001}
#standard deviation: 0.04446959358078281
#island_id: 3
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-J[3,i,j,k]) * J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * J[3,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(J[4,i,j,k]) * J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] = -2 + 2 * J[4,i,j,k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += np.exp(-J[5,i,0,0]) * J[5,i,0,0]
        priorities[i*N*N+j*N+0][1] -= 2 - 2 * J[5,i,0,0]
      else:
        priorities[i*N*N+j*N+0][0] -= np.exp(J[5,N-1,0,0]) * J[5,N-1,0,0]
        priorities[i*N*N+j*N+0][1] = -2 + 2 * J[5,N-1,0,0]
        
  return priorities




#score: {'data3D.txt': 0.32531780000000016}
#standard deviation: 0.04713009402876254
#island_id: 3
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[d], 1, axis=i) for d, i in zip(range(6), range(3))]
  interacting_spins += [np.roll(J[d], -1, axis=i) for d, i in zip(range(6), range(3))]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = h[i][j][k]
        
        interacting_spin = sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (1 + np.exp(interacting_spin) / (1 + np.exp(-interacting_spin))) * len([val for val in [J[d,i,j,k] for d in range(6)] if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (1 + np.exp(interacting_spin) / (1 + np.exp(-interacting_spin))) * len([val for val in [J[d,i,j,k] for d in range(6)] if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 3
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority for -1 spin
        priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        
        # Calculate the priority for 1 spin
        priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': -0.5417738000000001}
#standard deviation: 0.03989127214767662
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5323710000000001}
#standard deviation: 0.040392267564473276
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the product of neighboring spins
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5222433999999999}
#standard deviation: 0.04097192693100973
#island_id: 2
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_neighbors_site = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_site if val < 0]) + sum(val for val in site_neighbors_site)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.051425399999999996}
#standard deviation: 0.0489573630298855
#island_id: 1
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    site_neighbors = [J[0, i % N, (site_nbr + 1) % N, i // N // N], J[1, (i // N // N + (i % N)) % N, i % N, i // N // N], J[2, i % N, i % N, (i // N // N + site_nbr) % N]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_neighbors_sum = sum(val for val in site_neighbors)
    
    priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
    priorities[i][1] -= 2 - 2 * (site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0)
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-interacting_spins_sum) * len([val for val in J[[0,1,2],i,j,k] if val < 0]) + interacting_spins_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-interacting_spins_sum) * len([val for val in J[[0,1,2],i,j,k] if val > 0]) + interacting_spins_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2 * interacting_spins_sum
        
  return priorities




#score: {'data3D.txt': -0.48402459999999997}
#standard deviation: 0.04184090623827357
#island_id: 3
#version_generated: 3
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        site_nbrs = [J[d,i,site_nbr,k] for d in [0,1,2]]
        priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin - sum(J[d,i,site_nbr,k] for d in [0,1,2])
        
  return priorities




#score: {'data3D.txt': -0.09102980000000002}
#standard deviation: 0.04788826779034716
#island_id: 3
#version_generated: 3
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add interaction energies from all six neighbors
        for d in range(6):
          site_nbr_spin = J[d,i,j,k]
          if d < 3:
            i_idx = (i + ((k-1)%2 - 1)) % N
          elif d >= 3:
            i_idx = (i + 1) % N
          priorities[i*N*N+j*N+k][0] += site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
          
  return priorities




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.121461}
#standard deviation: 0.04738801535198536
#island_id: 3
#version_generated: 3
#generate time11:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = h[i][j][k]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[3,i,site_nbr,k] * h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.1028674}
#standard deviation: 0.06044047962450331
#island_id: 3
#version_generated: 3
#generate time11:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in range(6):
          priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
        
  return priorities




#score: {'data3D.txt': 0.1028674}
#standard deviation: 0.06044047962450331
#island_id: 3
#version_generated: 3
#generate time11:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in range(6):
          priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          
  return priorities




#score: {'data3D.txt': -0.5490717999999999}
#standard deviation: 0.04073967703308409
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4939946}
#standard deviation: 0.042606520754926706
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies
  local_energies = np.sum(J[:, :, :, :], axis=0) + h
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        
        # Add new terms based on the local energy and site neighbors
        priorities[i * N*N + j*N + k][0] += np.exp(local_energies[i][j][k]) * len([val for val in interacting_spins if val < 0])
        priorities[i * N*N + j*N + k][1] -= local_energies[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5272650000000001}
#standard deviation: 0.041248348997262915
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5272650000000001}
#standard deviation: 0.041248348997262915
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.21467340000000001}
#standard deviation: 0.05285600602050821
#island_id: 2
#version_generated: 3
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = J[[0, 1, 2], i, (j + 1) % N, k] + J[[0, 1, 2], (i + 1) % N, j, k] + J[[0, 1, 2], i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  return priorities




#score: {'data3D.txt': -0.21467340000000001}
#standard deviation: 0.05285600602050821
#island_id: 2
#version_generated: 3
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = J[[0, 1, 2], i, (j + 1) % N, k] + J[[0, 1, 2], (i + 1) % N, j, k] + J[[0, 1, 2], i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  return priorities




#score: {'data3D.txt': -0.0208346}
#standard deviation: 0.045621900473785615
#island_id: 1
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.022210999999999998}
#standard deviation: 0.04636171091536635
#island_id: 1
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_nbr = (i // N % N + ((i // N // N + 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 3) % 6]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 3) % 6])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_nbr = (i // N % N + ((i // N // N + 2) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 4) % 6]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 4) % 6])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3059766}
#standard deviation: 0.04314812130834899
#island_id: 3
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_energy = h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.3059766}
#standard deviation: 0.04314812130834899
#island_id: 3
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_energy = h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.3059766}
#standard deviation: 0.04314812130834899
#island_id: 3
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_energy = h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.020333399999999932}
#standard deviation: 0.04717803222305908
#island_id: 3
#version_generated: 3
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[3,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [4,5]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k]) * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k]) * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -2 + 2 * J[d,i,j,k]

  return priorities




#score: {'data3D.txt': 0.24328059999999999}
#standard deviation: 0.0464549487529585
#island_id: 3
#version_generated: 3
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[3,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': -0.5272650000000001}
#standard deviation: 0.041248348997262915
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.002107399999999983}
#standard deviation: 0.04847746966622742
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        if h[i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i,j,k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i,j,k]
  return(priorities)




#score: {'data3D.txt': -0.0028418000000000002}
#standard deviation: 0.04698536594259962
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.5507758}
#standard deviation: 0.0394448071913148
#island_id: 1
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, max(0, k-1)]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1
        
        neighbor_spin = J[2, i, j, min(N-1, k+1)]
        if neighbor_spin < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33819780000000005}
#standard deviation: 0.04285845021883083
#island_id: 1
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + ((j-1)%2 - 1)) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.29119619999999985}
#standard deviation: 0.046636060999617
#island_id: 3
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[3,i,j,k] * h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
        else:
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Calculate the priority based on the magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': 0.24328059999999999}
#standard deviation: 0.0464549487529585
#island_id: 3
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[3,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    magnetism = h[i % N][i // N % N][i // N // N]
    
    if magnetism > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins_sum = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    interacting_spins_count = len([val for val in [J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]] if val < 0])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(interacting_spins_sum)) * interacting_spins_count - 1
      priorities[i][1] -= 2 - 2 * interacting_spins_sum + 1
    else:
      priorities[i][0] -= np.exp(-abs(interacting_spins_sum)) * interacting_spins_count - 1
      priorities[i][1] = -2 + 2 * interacting_spins_sum + 1
  
  return(priorities)




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.020333399999999932}
#standard deviation: 0.04717803222305908
#island_id: 3
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[3,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [4,5]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k]) * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k]) * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -2 + 2 * J[d,i,j,k]

  return priorities




#score: {'data3D.txt': 0.020333399999999932}
#standard deviation: 0.04717803222305908
#island_id: 3
#version_generated: 3
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[3,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        for d in [4,5]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k]) * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k]) * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -2 + 2 * J[d,i,j,k]

  return priorities




#score: {'data3D.txt': -0.4999970000000001}
#standard deviation: 0.04098962735863794
#island_id: 2
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local magnetization
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4736166}
#standard deviation: 0.04409009326866978
#island_id: 2
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_nbr_neighbors = [J[0, i, (site_nbr+1)%N, k], J[1,(i+1)%N, site_nbr, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.5137990000000001}
#standard deviation: 0.04137296362360328
#island_id: 2
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add new terms based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the energy of the current spin
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (2 - 2 * total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.14808460000000007}
#standard deviation: 0.04556587322591327
#island_id: 0
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i,j,k] += J[l,i,j,k]*interacting_spins[l,i,j,k]
          elif J[l,i,j,k] < 0:
            priorities[i,j,k] -= J[l,i,j,k]*interacting_spins[l,i,j,k]
  
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.48402459999999997}
#standard deviation: 0.04184090623827357
#island_id: 3
#version_generated: 3
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbrs = [J[d,i,site_nbr,k] for d in [0,1,2]]
        priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + sum(J[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin - sum(J[d,i,site_nbr,k] for d in [0,1,2])
        
  return priorities




#score: {'data3D.txt': -0.1916194}
#standard deviation: 0.06098300799107896
#island_id: 3
#version_generated: 3
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbrs = [J[d,i,site_nbr,k] for d in [0,1,2]]
        site_nbrs_total_spin = sum(J[d,i,site_nbr,k] for d in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin - np.exp(-site_nbrs_total_spin) * len([val for val in site_nbrs if val < 0]) - site_nbrs_total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin - 2 + 2 * site_nbrs_total_spin
        
  return priorities




#score: {'data3D.txt': -0.5029754000000002}
#standard deviation: 0.04469783076212983
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term based on the local energy and spatial correlations
  priorities[:, 0] += h.flatten()
  priorities[:, 1] -= h.flatten()

  return(priorities)




#score: {'data3D.txt': -0.5131526}
#standard deviation: 0.04237129728058843
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        # Add a new term based on the local energy and spatial correlations
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        
        # Add a new term based on the spatial correlations and the total spin
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19758820000000007}
#standard deviation: 0.04575130665631311
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5031554}
#standard deviation: 0.04080529439717351
#island_id: 0
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.501537}
#standard deviation: 0.04014193606442021
#island_id: 0
#version_generated: 3
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5031554}
#standard deviation: 0.04080529439717351
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5066341999999999}
#standard deviation: 0.04057336848673031
#island_id: 0
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the interactions with the previous and next sites
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + sum(val for val in [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5158761999999999}
#standard deviation: 0.039513760559582285
#island_id: 2
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        
        # Added computation of spin at the current site
        current_spin = h[i][j][k]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (1 if current_spin < 0 else 0) + total_spin
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 2
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5093174}
#standard deviation: 0.04286824765767782
#island_id: 2
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        
        # Additional spin assignment based on magnetism
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_neighbors_count = len([val for val in site_neighbors if val < 0])
          
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_spin)) * site_neighbors_count + site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_neighbors_count = len([val for val in site_neighbors if val > 0])
          
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_neighbors_spin)) * site_neighbors_count + site_neighbors_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3990010000000001}
#standard deviation: 0.04554041764191453
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[f, i, j, k] for f in [3, 4, 5]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3600546000000002}
#standard deviation: 0.045586714060568134
#island_id: 0
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          total_neighbor_spin = sum(val for val in site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4851314}
#standard deviation: 0.04081551535923564
#island_id: 2
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4,(i+1)%N, j, k], J[5,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add new terms based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + np.sum(J[0, i, j, k:])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - np.sum(J[0, i, j, k:])

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 2
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.011191}
#standard deviation: 0.049176297125749516
#island_id: 2
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for l in range(6):
          if l == 0:
            site_neighbors.append(J[l, (i+1)%N, j, k])
          elif l == 1:
            site_neighbors.append(J[l, i, (j+1)%N, k])
          elif l == 2:
            site_neighbors.append(J[l, i, j, (k+1)%N])
          elif l == 3:
            site_neighbors.append(J[l, (i-1)%N, j, k])
          elif l == 4:
            site_neighbors.append(J[l, i, (j-1)%N, k])
          elif l == 5:
            site_neighbors.append(J[l, i, j, (k-1)%N])

        total_energy = sum(val for val in interacting_spins) + sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += -total_energy
          priorities[i * N*N + j*N + k][1] = total_energy
        else:
          priorities[i * N*N + j*N + k][0] = total_energy
          priorities[i * N*N + j*N + k][1] = -total_energy

  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 2
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        interacting_spin_product = sum(val * (val > 0) for val in interacting_spins)
        site_neighbor_product = sum(val * (val > 0) for val in site_neighbors)

        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * abs(interacting_spin_product) - total_spin
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 2
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N*N + j*N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4976006}
#standard deviation: 0.041270589523775894
#island_id: 1
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_opposite_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.501537}
#standard deviation: 0.04014193606442021
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3826738}
#standard deviation: 0.05040896302801715
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.15200219999999998}
#standard deviation: 0.04009891513694604
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin_neighbors = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin_neighbors
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          total_spin_neighbors = sum(val for val in site_neighbors)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin_neighbors
        
  return priorities




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028418000000000002}
#standard deviation: 0.04698536594259962
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.153745}
#standard deviation: 0.05530629525650765
#island_id: 3
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.28761100000000006}
#standard deviation: 0.04600240862172328
#island_id: 3
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.28761100000000006}
#standard deviation: 0.04600240862172328
#island_id: 3
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
  return priorities




#score: {'data3D.txt': 0.2336618}
#standard deviation: 0.049878670198392414
#island_id: 3
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_energy = J[0,i,j,k] * h[i][j][k]
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + np.exp(site_energy) * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        # Add neighbor interactions
        for d in range(6):
          if d < 3:
            neighbor = (i + ((k-1)%2 - 1)) % N
          else:
            neighbor = i
          
          if h[neighbor][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d, neighbor, j, k]
            priorities[i*N*N+j*N+k][1] -= J[d, neighbor, j, k]
          
  return priorities




#score: {'data3D.txt': -0.002107399999999983}
#standard deviation: 0.04847746966622742
#island_id: 0
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        
        if h[i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i,j,k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.009542199999999999}
#standard deviation: 0.047355502944853196
#island_id: 0
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        total_spin = h[i,j,k]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.2268706}
#standard deviation: 0.04264029005107728
#island_id: 0
#version_generated: 3
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.011191}
#standard deviation: 0.049176297125749516
#island_id: 2
#version_generated: 3
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for l in range(6):
          if l == 0:
            site_neighbors.append(J[l, (i+1)%N, j, k])
          elif l == 1:
            site_neighbors.append(J[l, i, (j+1)%N, k])
          elif l == 2:
            site_neighbors.append(J[l, i, j, (k+1)%N])
          elif l == 3:
            site_neighbors.append(J[l, (i-1)%N, j, k])
          elif l == 4:
            site_neighbors.append(J[l, i, (j-1)%N, k])
          elif l == 5:
            site_neighbors.append(J[l, i, j, (k-1)%N])
        
        total_energy = sum(val for val in interacting_spins) + sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += -total_energy
          priorities[i * N*N + j*N + k][1] = total_energy
        else:
          priorities[i * N*N + j*N + k][0] = total_energy
          priorities[i * N*N + j*N + k][1] = -total_energy
        
  return(priorities)




#score: {'data3D.txt': 0.011191}
#standard deviation: 0.049176297125749516
#island_id: 2
#version_generated: 3
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = []
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        for l in range(6):
          if l == 0:
            site_neighbors.append(J[l, (i+1)%N, j, k])
          elif l == 1:
            site_neighbors.append(J[l, i, (j+1)%N, k])
          elif l == 2:
            site_neighbors.append(J[l, i, j, (k+1)%N])
          elif l == 3:
            site_neighbors.append(J[l, (i-1)%N, j, k])
          elif l == 4:
            site_neighbors.append(J[l, i, (j-1)%N, k])
          elif l == 5:
            site_neighbors.append(J[l, i, j, (k-1)%N])

        total_energy = sum(val for val in interacting_spins) + sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += -total_energy
          priorities[i * N*N + j*N + k][1] = total_energy
        else:
          priorities[i * N*N + j*N + k][0] = total_energy
          priorities[i * N*N + j*N + k][1] = -total_energy

  return(priorities)




#score: {'data3D.txt': 0.011191}
#standard deviation: 0.049176297125749516
#island_id: 2
#version_generated: 3
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = []
        for l in range(6):
          if l == 0:
            site_nbrs.append(J[l, (i+1)%N, j, k])
          elif l == 1:
            site_nbrs.append(J[l, i, (j+1)%N, k])
          elif l == 2:
            site_nbrs.append(J[l, i, j, (k+1)%N])
          elif l == 3:
            site_nbrs.append(J[l, (i-1)%N, j, k])
          elif l == 4:
            site_nbrs.append(J[l, i, (j-1)%N, k])
          elif l == 5:
            site_nbrs.append(J[l, i, j, (k-1)%N])
        
        total_energy = sum(val for val in interacting_spins) + sum(val for val in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += -total_energy
          priorities[i * N*N + j*N + k][1] = total_energy
        else:
          priorities[i * N*N + j*N + k][0] = total_energy
          priorities[i * N*N + j*N + k][1] = -total_energy
        
  return(priorities)




#score: {'data3D.txt': 0.004010199999999999}
#standard deviation: 0.049642854228579565
#island_id: 2
#version_generated: 3
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for l in range(6):
          if l == 0:
            site_neighbors.append(J[l, (i+1)%N, j, k])
          elif l == 1:
            site_neighbors.append(J[l, i, (j+1)%N, k])
          elif l == 2:
            site_neighbors.append(J[l, i, j, (k+1)%N])
          elif l == 3:
            site_neighbors.append(J[l, (i-1)%N, j, k])
          elif l == 4:
            site_neighbors.append(J[l, i, (j-1)%N, k])
          elif l == 5:
            site_neighbors.append(J[l, i, j, (k-1)%N])

        total_energy = sum(val for val in interacting_spins) + sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N*N + j*N + k][0] += -total_energy + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N*N + j*N + k][1] = total_energy - total_spin
        else:
          priorities[i * N*N + j*N + k][0] = total_energy - total_spin
          priorities[i * N*N + j*N + k][1] = -total_energy - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.5019426}
#standard deviation: 0.04226353162290156
#island_id: 2
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        site_nbr_neighbors = [J[0, i, (site_nbr+1)%N, k], J[1,(i+1)%N, site_nbr, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.5004078}
#standard deviation: 0.04244110341591039
#island_id: 2
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and magnetism of neighboring sites
        site_nbr_energy = h[site_nbr][j][k]
        if site_nbr_energy > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.023081}
#standard deviation: 0.04984204208296446
#island_id: 2
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priority_down = -np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + priority_up
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - 2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) + priority_down
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3827142}
#standard deviation: 0.041770896547237285
#island_id: 2
#version_generated: 3
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        site_nbr_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) + sum(val for val in site_nbr_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the correlation with neighboring sites
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i+1][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i+1][j][k]
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j+1][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j+1][k]
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k+1])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k+1]
  
  return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
  
  return priorities




#score: {'data3D.txt': -0.4898562000000002}
#standard deviation: 0.044501537069633904
#island_id: 1
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,i,j,k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3059766}
#standard deviation: 0.04314812130834899
#island_id: 3
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_energy = h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.3059766}
#standard deviation: 0.04314812130834899
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_energy = h[i][j][k]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if site_energy > 0:
          priorities[i*N*N+j*N+k][0] += -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val < 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        else:
          priorities[i*N*N+j*N+k][0] += site_energy + -site_energy * (total_spin / 3 + np.exp(total_spin) - np.exp(-total_spin)) * len([val for val in interacting_spins if val > 0]) - site_energy
          priorities[i*N*N+j*N+k][1] -= site_energy
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3811182}
#standard deviation: 0.045974672905416084
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.035312600000000006}
#standard deviation: 0.04970601011185669
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  return priorities




#score: {'data3D.txt': -0.5036142}
#standard deviation: 0.04161430809661504
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[0, 1, 2], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[0, 1, 2], (i + 1) % N, j, k] + J[[0, 1, 2], i, j, (k + 1) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3826738}
#standard deviation: 0.05040896302801715
#island_id: 0
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.38006619999999997}
#standard deviation: 0.051496574425489695
#island_id: 0
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3826738}
#standard deviation: 0.05040896302801715
#island_id: 0
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0323486}
#standard deviation: 0.049204709104312364
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  # Add a new term to encourage the spins to align with the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.27259300000000003}
#standard deviation: 0.049192324513078256
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energy

  return priorities




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': -0.3923366000000001}
#standard deviation: 0.04677660035145778
#island_id: 0
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[f, i, j, k] for f in [3, 4, 5]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        # Add a new line to prioritize spins that are closer to the average spin of the neighborhood
        avg_spin = np.mean([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (avg_spin - total_spin) / len([J[f, i, j, k] for f in [0, 1, 2]])
        else:
          priorities[i * N * N + j * N + k][0] -= (avg_spin - total_spin) / len([J[f, i, j, k] for f in [0, 1, 2]])
        
  return(priorities)




#score: {'data3D.txt': -0.3990010000000001}
#standard deviation: 0.04554041764191453
#island_id: 0
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[f, i, j, k] for f in [3, 4, 5]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3990010000000001}
#standard deviation: 0.04554041764191453
#island_id: 0
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[f, i, j, k] for f in [3, 4, 5]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.012913}
#standard deviation: 0.0465094174442123
#island_id: 1
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.008254999999999998}
#standard deviation: 0.047338651174278296
#island_id: 1
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                    * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                    for d in [(i // N // N + 2) % 3]])
    else:
      priorities[i][0] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] = sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                    * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                    for d in [(i // N // N + 2) % 3]])
  
  return(priorities)




#score: {'data3D.txt': 0.031820999999999995}
#standard deviation: 0.047183889612875285
#island_id: 1
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin
    else:
      priorities[i][0] = 2 - 2 * total_spin
      priorities[i][1] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0110314}
#standard deviation: 0.0464866778124658
#island_id: 1
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 1) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] += 2 - 2 * total_spin
    else:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.38006619999999997}
#standard deviation: 0.051496574425489695
#island_id: 0
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.38006619999999997}
#standard deviation: 0.051496574425489695
#island_id: 0
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  
  return priorities




#score: {'data3D.txt': -0.5465845999999999}
#standard deviation: 0.04076274724353107
#island_id: 3
#version_generated: 3
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 3
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.015595799999999998}
#standard deviation: 0.04742754750522105
#island_id: 1
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.015527000000000001}
#standard deviation: 0.04739091802233841
#island_id: 1
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + 2) % 3])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0151122}
#standard deviation: 0.04738587396218413
#island_id: 1
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.011526600000000001}
#standard deviation: 0.04662144755839312
#island_id: 1
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i%N,(i//N)%N,(i//N//N)] for d in [(i//N//N+k)%3 for k in range(6)]]
    total_spin = sum(J[d,i%N,(i//N)%N,(i//N//N)] for d in [(i//N//N+k)%3 for k in range(6)])
    
    if h[i%N][(i//N)%N][i//N//N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.011526600000000001}
#standard deviation: 0.04662144755839312
#island_id: 1
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5465845999999999}
#standard deviation: 0.04076274724353107
#island_id: 3
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5465845999999999}
#standard deviation: 0.04076274724353107
#island_id: 3
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0208346}
#standard deviation: 0.045621900473785615
#island_id: 1
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4108566000000002}
#standard deviation: 0.0436153399211791
#island_id: 1
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i % N, j % N, k] for d in [0, 1, 2, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::3, i % N, j % N, k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::3, i % N, j % N, k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        total_spin = sum(J[d, (i+1) % N, j % N, k] for d in [3])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::3, (i+1) % N, j % N, k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::3, (i+1) % N, j % N, k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        total_spin = sum(J[d, i % N, (j+1) % N, k] for d in [3])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::3, i % N, (j+1) % N, k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::3, i % N, (j+1) % N, k] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        total_spin = sum(J[d, i % N, j % N, (k+1) % N] for d in [3])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::3, i % N, j % N, (k+1) % N] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::3, i % N, j % N, (k+1) % N] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.08282099999999999}
#standard deviation: 0.06144548282013902
#island_id: 2
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]

        priorities[i * N * N + j * N + k][0] = -2 * total_spin - sum(site_nbr_neighbors) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] = np.exp(local_energies[i][j][k]) - 1

  return priorities




#score: {'data3D.txt': 0.031407}
#standard deviation: 0.04661355158105848
#island_id: 2
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  return priorities




#score: {'data3D.txt': -0.23756619999999998}
#standard deviation: 0.0467910070158786
#island_id: 2
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_nbr_neighbors if val < 0]))
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.12436459999999981}
#standard deviation: 0.04921970161266726
#island_id: 3
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.003881}
#standard deviation: 0.04783621597701892
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) - sum([val for val in interacting_spins if val < 0])
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) - sum([val for val in interacting_spins if val > 0])
      priorities[i][1] = -2 + 2 * sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.007678600000000002}
#standard deviation: 0.04825436293269242
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * (sum([1 if val < 0 else 0 for val in interacting_spins]) - sum([1 if val > 0 else 0 for val in interacting_spins])) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * (sum([1 if val < 0 else 0 for val in interacting_spins]) + sum([1 if val > 0 else 0 for val in interacting_spins])) - sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.011526600000000001}
#standard deviation: 0.04662144755839312
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.017946200000000002}
#standard deviation: 0.045944379695018196
#island_id: 1
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    # Add the magnetism to the priority
    priorities[i][0] += h[i % N][i // N % N][i // N // N]
    priorities[i][1] -= h[i % N][i // N % N][i // N // N]
  
  return(priorities)




#score: {'data3D.txt': -0.0243058}
#standard deviation: 0.04717613344011991
#island_id: 1
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin_x = [J[0, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 3 for k in range(6)]]
    interacting_spin_y = [J[1, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 3 for k in range(6)]]
    interacting_spin_z = [J[2, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin_x = sum(interacting_spin_x)
    total_spin_y = sum(interacting_spin_y)
    total_spin_z = sum(interacting_spin_z)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spin_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2 * total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spin_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2 * total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spin_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2 * total_spin_z
      
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in interacting_spin_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2 * total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in interacting_spin_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2 * total_spin_y
      
      priorities[i][0] -= np.exp(abs(total_spin_z)) * len([val for val in interacting_spin_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2 * total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.0319286}
#standard deviation: 0.048259919416012285
#island_id: 1
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, (i // N) % N, i // N // N] for d in [(d+3)%6 for d in range(3)]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -np.sum(interacting_spins) + len([val for val in interacting_spins if val < 0])
      priorities[i][1] = -2
    else:
      priorities[i][0] -= -np.sum(interacting_spins) + len([val for val in interacting_spins if val > 0])
      priorities[i][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(interacting_spins)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0175446}
#standard deviation: 0.04662528167035562
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
              for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
    # Add additional logic here to prioritize spins based on site interactions and magnetism
    if h[i % N][i // N % N][i // N // N] > 0:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][1] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][0] += 2
    
    else:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][0] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][1] += 2
  
  return(priorities)




#score: {'data3D.txt': 0.009869}
#standard deviation: 0.046161818844148675
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.008062199999999999}
#standard deviation: 0.048891056965052415
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + d) % 3 for d in [-1, 0, 1]]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.0096018}
#standard deviation: 0.04551294449670335
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d,i%N,i//N%N,i//N//N] 
               if d==0 else J[(d+1)%3,i%N,i//N%N,i//N//N] 
               for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2268706}
#standard deviation: 0.04264029005107728
#island_id: 0
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        site_neighbors_sum = 0
        for d in range(6):
          interacting_spin = -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
          interacting_spins_sum += interacting_spin
          site_neighbors_sum += interacting_spin
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.1523718}
#standard deviation: 0.047682236155197254
#island_id: 0
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0)
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0)
          priorities[i * N * N + j * N + k][1] = -4 + 4 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0060958}
#standard deviation: 0.047259502138300186
#island_id: 0
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
        site_neighbors_sum = sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.014466599999999996}
#standard deviation: 0.047427421650770775
#island_id: 0
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.27106860000000016}
#standard deviation: 0.04405785621248496
#island_id: 3
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5280286000000001}
#standard deviation: 0.041058437647333836
#island_id: 3
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the interaction energy
        site_nbr_energy = J[0, i, j, (k - 1) % N] if k > 0 else J[0, i, j, N - 1]
        priorities[i * N * N + j * N + k][0] += np.exp(site_nbr_energy) * abs(site_nbr_energy)
        priorities[i * N * N + j * N + k][1] -= site_nbr_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5356917999999999}
#standard deviation: 0.03973166209410324
#island_id: 3
#version_generated: 3
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2720174}
#standard deviation: 0.036569149528530194
#island_id: 2
#version_generated: 3
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_nbr_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4523142000000003}
#standard deviation: 0.0462153580356141
#island_id: 3
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5172093999999999}
#standard deviation: 0.042678643273187586
#island_id: 3
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the energy of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4904834}
#standard deviation: 0.040822690313598885
#island_id: 3
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the interaction between site and its neighboring sites
        for d in [0, 1, 2]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= J[d, i, j, k]
        
  return priorities




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3431957999999996}
#standard deviation: 0.044854385987994516
#island_id: 3
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0].flatten() if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0].flatten() if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors += [J[d, i, j, k] for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.38006619999999997}
#standard deviation: 0.051496574425489695
#island_id: 0
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.45291340000000024}
#standard deviation: 0.04602321914468826
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  # Add a global magnetic field term
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3964214}
#standard deviation: 0.04072070114867867
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, spin and neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (abs(h[i][j][k]) + sum(abs(val) for val in interacting_spins) + sum(abs(val) for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4786906000000002}
#standard deviation: 0.045019712922674225
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  # Add a new term based on the site magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3716502}
#standard deviation: 0.05106157694352967
#island_id: 0
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.07184940000000001}
#standard deviation: 0.04812453843560476
#island_id: 2
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin

        # Add a new term based on the spatial correlations
        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        priorities[i * N * N + j * N + k][0] += sum(site_corr)
        priorities[i * N * N + j * N + k][1] -= site_corr.sum()

  return priorities




#score: {'data3D.txt': -0.3269526}
#standard deviation: 0.051843657598977334
#island_id: 2
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N] + J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin
        
        # Add new terms to prioritize spins based on local energy and spatial correlations
        if site_nbr_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        elif site_nbr_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin))
        
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        elif site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin))
        
        if local_energy < 0:
          priorities[i * N * N + j * N + k][0] = -2 * local_energy
        elif local_energy > 0:
          priorities[i * N * N + j * N + k][1] = -2 * local_energy
        
  return priorities




#score: {'data3D.txt': 0.2657878}
#standard deviation: 0.04936759312707072
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spins
        priorities[i * N * N + j * N + k][0] += -np.exp(h[i][j][k]) - np.exp(-total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] - total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.03330780000000008}
#standard deviation: 0.051979882446577357
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.32196220000000003}
#standard deviation: 0.044285587397707625
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.031533399999999816}
#standard deviation: 0.046671769673326084
#island_id: 3
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [(d+1)%6 for d in [0, 1, 2]]]
        total_spin = sum(J[d, i, j, k] for d in [(d+1)%6 for d in [0, 1, 2]])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.012185}
#standard deviation: 0.047182994977004164
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
        
        for d in [3, 4, 5]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': 0.025603400000000005}
#standard deviation: 0.048844333432241656
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_opposite_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_neighbors if val > 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2004798}
#standard deviation: 0.04513269138839385
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09069100000000001}
#standard deviation: 0.049031518832277673
#island_id: 2
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Compute local energies and spatial correlations
  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(site_nbr_neighbors) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] = np.exp(local_energies[i][j][k]) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_nbr_neighbors if val < 0]))

  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.0946254}
#standard deviation: 0.06017930171445993
#island_id: 2
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) - site_corr.sum()
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': 0.1115438}
#standard deviation: 0.04588420034783215
#island_id: 2
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_corr_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -total_spin

        # Add a new term based on the spatial correlations
        site_corr_sum = sum(site_corr) + sum(site_corr_neighbors)
        priorities[i * N * N + j * N + k][0] += site_corr_sum
        priorities[i * N * N + j * N + k][1] -= site_corr_sum

  return priorities




#score: {'data3D.txt': -0.07184940000000001}
#standard deviation: 0.04812453843560476
#island_id: 2
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin
        
        # Add a new term based on the spatial correlations
        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_corr_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]
        
        priorities[i * N * N + j * N + k][0] += sum(site_corr) - site_corr_neighbors.sum()
        priorities[i * N * N + j * N + k][1] -= site_corr.sum() + site_corr_neighbors.sum()
        
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4216186000000002}
#standard deviation: 0.048094965371024014
#island_id: 0
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + site_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * site_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * neighbor_spin

          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + site_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * site_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2 * neighbor_spin

          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.401983}
#standard deviation: 0.04915666374968911
#island_id: 0
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': 0.012185}
#standard deviation: 0.047182994977004164
#island_id: 1
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
        
        for d in [3, 4, 5]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] -= 2
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.015269399999999999}
#standard deviation: 0.046374257769154645
#island_id: 1
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [3, 4, 5]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [3, 4, 5]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 2
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': 0.019022200000000006}
#standard deviation: 0.04744126839746172
#island_id: 1
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[3, i, j, k] < 0:
          priorities[i*N*N+j*N+k][0] -= 1
        elif J[3, i, j, k] > 0:
          priorities[i*N*N+j*N+k][1] += 1
        
        if J[4, i, j, k] < 0:
          priorities[i*N*N+j*N+k][0] -= 1
        elif J[4, i, j, k] > 0:
          priorities[i*N*N+j*N+k][1] += 1
        
        if J[5, i, j, k] < 0:
          priorities[i*N*N+j*N+k][0] -= 1
        elif J[5, i, j, k] > 0:
          priorities[i*N*N+j*N+k][1] += 1
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif interacting_spins[d] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif interacting_spins[d] > 0:
              priorities[i*N*N+j*N+k][0] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.009626599999999999}
#standard deviation: 0.04640286771784692
#island_id: 1
#version_generated: 3
#generate time16:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += np.exp(-abs(total_spin)) * len([val for val in J[3:,i,j,k] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[3:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * len([val for val in J[3:,i,j,k] if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.08440260000000001}
#standard deviation: 0.044710143292546044
#island_id: 2
#version_generated: 3
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]
        site_corr_neighbors = J[[0, 1, 2], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N] + J[[0, 1, 2], i, (j + 1) % N, k] + J[[0, 1, 2], (i + 1) % N, j, k]
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0]) + sum(val for val in site_corr_neighbors)
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin + sum(interacting_spins) + np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) - sum(val for val in site_corr_neighbors)
          priorities[i * N * N + j * N + k][1] = -total_spin
          
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.01704540000000004}
#standard deviation: 0.04639306735752661
#island_id: 2
#version_generated: 3
#generate time16:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -total_spin

        # Add a new term based on the spatial correlations and magnetism
        site_corr_sum = (site_nbr_neighbors.sum() + site_neighbors.sum()) / 2.0
        priorities[i * N * N + j * N + k][0] += site_corr_sum
        priorities[i * N * N + j * N + k][1] -= site_corr_sum

        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5274978000000001}
#standard deviation: 0.04158840698031123
#island_id: 2
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        
        local_energy = h[i][j][k]
        
        # Prioritize spins based on local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin + np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy
        
  return priorities




#score: {'data3D.txt': -0.123059}
#standard deviation: 0.06001610916245738
#island_id: 2
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        # Calculate the energy difference
        site_energy = sum(interacting_spins)
        site_neighbors_energy = sum(site_nbr_neighbors)

        priorities[i * N * N + j * N + k][0] = -site_energy - site_neighbors_energy
        priorities[i * N * N + j * N + k][1] = site_energy

  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 2
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        priorities[i * N * N + j * N + k][0] = total_spin + sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': -0.1417294}
#standard deviation: 0.049792471877182394
#island_id: 2
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin

        # Add a new term based on the spatial correlations
        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        priorities[i * N * N + j * N + k][0] += sum(site_corr)
        priorities[i * N * N + j * N + k][1] -= site_corr.sum()

        # Add a new term based on the local energy
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy) - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= local_energy

  return priorities




#score: {'data3D.txt': -0.1054562}
#standard deviation: 0.04843295986784206
#island_id: 2
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_corr = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) + sum(site_corr)
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': 0.37689419999999996}
#standard deviation: 0.04817211025437852
#island_id: 3
#version_generated: 3
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.5127902000000002}
#standard deviation: 0.04206179482570852
#island_id: 0
#version_generated: 3
#generate time16:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  # Add a new term based on the number of nearest neighbors with the same spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if all(val < 0 for val in interacting_spins) and all(val < 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif all(val > 0 for val in interacting_spins) and all(val > 0 for val in site_neighbors):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.3826738}
#standard deviation: 0.05040896302801715
#island_id: 0
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.39400460000000004}
#standard deviation: 0.04854465427665543
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4932502}
#standard deviation: 0.0401243048532931
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the interaction with the next sites
        if i > 0:
          site_neighbors = [J[0, (i-1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.501537}
#standard deviation: 0.04014193606442021
#island_id: 0
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_neighbors = [J[0, i % N, (i // N) % N, (i // N // N)], 
              J[1, (i % N), i // N % N, (i // N // N)], 
              J[2, i % N, (i // N) % N, (i // N // N)]]
    priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
    priorities[i][1] -= 2 - 2 * total_spin
    
    local_energy = h[i % N][i // N % N][i // N // N]
    priorities[i][0] += np.exp(local_energy)
    priorities[i][1] -= local_energy
  
  return(priorities)




#score: {'data3D.txt': -0.0379754}
#standard deviation: 0.04708035338482497
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] 
             for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
      
      neighbor_spin = J[2, i % N, (i // N) % N, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
        
      neighbor_spin = J[2, i % N, (i // N) % N, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
        
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
      
      neighbor_spin = J[2, i % N, (i // N) % N, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
        
      neighbor_spin = J[2, i % N, (i // N) % N, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0025878000000000008}
#standard deviation: 0.04781225335789979
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    
    site_nbr_spin = J[2, i % N, (i // N) % N, max(0, (i // N // N) - 1)]
    if site_nbr_spin < 0:
      priorities[i][0] += np.exp(-abs(sum([J[d, i % N, i // N % N, i // N // N] 
                          for d in [(i // N // N + 2) % 3]])))
      priorities[i][1] -= 1
    
    site_nbr_spin = J[2, (i // N) % N, i % N, max(0, (i // N // N) - 1)]
    if site_nbr_spin < 0:
      priorities[i][0] += np.exp(-abs(sum([J[d, i % N, i // N % N, i // N // N] 
                          for d in [(i // N // N + 2) % 3]])))
      priorities[i][1] -= 1
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
    else:
      priorities[i][0] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] = sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
  
  return(priorities)




#score: {'data3D.txt': 0.008254999999999998}
#standard deviation: 0.047338651174278296
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                    * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                    for d in [(i // N // N + 2) % 3]])
    else:
      priorities[i][0] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] = sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                    * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                    for d in [(i // N // N + 2) % 3]])
  
  return(priorities)




#score: {'data3D.txt': 0.017575000000000004}
#standard deviation: 0.04632750344018119
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
    else:
      priorities[i][0] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
      priorities[i][1] = sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                   for d in [(i // N // N + 2) % 3]])
    
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 1) % 3]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 1) % 3]])
      priorities[i][1] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                   for d in [(i // N // N + 1) % 3]])
    else:
      priorities[i][0] -= sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] < 0 else -1) 
                   for d in [(i // N // N + 1) % 3]])
      priorities[i][1] = sum([np.exp(-abs(J[d, i % N, i // N % N, i // N // N])) 
                   * (1 if J[d, i % N, i // N % N, i // N // N] > 0 else -1) 
                   for d in [(i // N // N + 1) % 3]])
  
  return(priorities)




#score: {'data3D.txt': -0.016222999999999998}
#standard deviation: 0.04678516849387207
#island_id: 1
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[(i // N // N + d) % 3, site_nbr, i % N, i // N // N] for d in range(3)]
    total_spin = sum(J[(i // N // N + d) % 3, site_nbr, i % N, i // N // N] for d in range(3))
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [(d+1)%3 for d in range(6)]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([-spin*np.exp(-abs(np.sum(interacting_spins))) for spin in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * np.sum([spin for spin in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([-spin*np.exp(-abs(np.sum(interacting_spins))) for spin in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * np.sum([spin for spin in interacting_spins])
        
  return(priorities)




#score: {'data3D.txt': -0.0151122}
#standard deviation: 0.04738587396218413
#island_id: 1
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.023763}
#standard deviation: 0.04508983334411428
#island_id: 1
#version_generated: 3
#generate time16:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    total_spin = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
      priorities[i][1] = -2 - sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3])
    else:
      priorities[i][0] = -sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
      priorities[i][1] = 2 + sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3])

  return(priorities)




#score: {'data3D.txt': 0.2976018}
#standard deviation: 0.045058283553193634
#island_id: 3
#version_generated: 3
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Consider the influence of neighbors
        for d, neighbor in enumerate(site_neighbors):
          priority_up -= J[d, i, j, k] * abs(neighbor)
          
        priority_down = -priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': 0.3880034}
#standard deviation: 0.04714978290978655
#island_id: 3
#version_generated: 3
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        # Add a term based on the magnetism at the current site
        if h[i][j][k] > 0:
          priority_up += np.exp(-abs(total_spin))
          priority_down -= np.exp(-abs(total_spin))
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': 0.1076574}
#standard deviation: 0.04657287649737774
#island_id: 3
#version_generated: 3
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
        
        # Add interaction with site_neighbors
        priority_up += np.sum([val if val > 0 else -val for val in interacting_spins]) + np.exp(h[i][j][k])
        priority_down -= priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': 0.37689419999999996}
#standard deviation: 0.04817211025437852
#island_id: 3
#version_generated: 3
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.3405214}
#standard deviation: 0.04359544863904947
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in range(6)] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in range(6)] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.18151900000000007}
#standard deviation: 0.04276110895428228
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = interacting_spins_sum - len([val for val in [J[d,i,j,k] for d in range(6)] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = interacting_spins_sum - len([val for val in [J[d,i,j,k] for d in range(6)] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.2268706}
#standard deviation: 0.04264029005107728
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3924126000000001}
#standard deviation: 0.0456956168712055
#island_id: 0
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_neighbor_spin

          if all(val < 0 for val in interacting_spins) and all(val < 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          elif all(val > 0 for val in interacting_spins) and all(val > 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2 * total_neighbor_spin

  return priorities




#score: {'data3D.txt': -0.123059}
#standard deviation: 0.06001610916245738
#island_id: 2
#version_generated: 3
#generate time16:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        site_energy = sum(interacting_spins)
        site_neighbors_energy = sum(site_nbr_neighbors)

        # Calculate the priority based on the energy difference
        priorities[i * N * N + j * N + k][0] = -site_energy - site_neighbors_energy
        priorities[i * N * N + j * N + k][1] = site_energy

  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [3, 4, 5])))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [3, 4, 5])))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.3924126000000001}
#standard deviation: 0.0456956168712055
#island_id: 0
#version_generated: 3
#generate time16:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_neighbor_spin

          if all(val < 0 for val in interacting_spins) and all(val < 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          elif all(val > 0 for val in interacting_spins) and all(val > 0 for val in site_neighbors):
            priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2 * total_neighbor_spin

        # Add more factors here like the number of positive and negative spins in the neighboring sites

  return priorities




#score: {'data3D.txt': -0.4133514000000003}
#standard deviation: 0.04776248818937305
#island_id: 3
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  # Add a new term based on the site magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.016597}
#standard deviation: 0.046791932969262984
#island_id: 3
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_energy = h[i][j][k]

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val < 0]) + site_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) + site_energy
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4709554000000002}
#standard deviation: 0.04573960002929628
#island_id: 3
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  # Add a new term based on the site magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.19971099999999986}
#standard deviation: 0.04599343560770385
#island_id: 3
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(val for val in interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5298038}
#standard deviation: 0.041235041718906996
#island_id: 3
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5107122000000001}
#standard deviation: 0.04259875222538802
#island_id: 3
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the energy of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the energy of the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.1417294}
#standard deviation: 0.049792471877182394
#island_id: 2
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin

        # Add a new term based on the spatial correlations
        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        priorities[i * N * N + j * N + k][0] += sum(site_corr)
        priorities[i * N * N + j * N + k][1] -= site_corr.sum()

        # Add a new term based on the local energy
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy) - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= local_energy

  return priorities




#score: {'data3D.txt': -0.040592199999999995}
#standard deviation: 0.12351663264176205
#island_id: 2
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) - np.sum(J[[3, 4, 5], : , : , k]) 
        priorities[i * N * N + j * N + k][1] = total_spin

        # Add a new term based on the local energy
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy) - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= local_energy

  return priorities




#score: {'data3D.txt': -0.1417294}
#standard deviation: 0.049792471877182394
#island_id: 2
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin

        # Add a new term based on the spatial correlations
        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        priorities[i * N * N + j * N + k][0] += sum(site_corr)
        priorities[i * N * N + j * N + k][1] -= site_corr.sum()

        # Add a new term based on the local energy
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy) - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= local_energy

  return priorities




#score: {'data3D.txt': -0.009542199999999999}
#standard deviation: 0.047355502944853196
#island_id: 0
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        total_spin = h[i,j,k]

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.058285399999999994}
#standard deviation: 0.05932767943245379
#island_id: 2
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        local_energy = h[i][j][k]

        priorities[i * N * N + j * N + k][0] = -total_spin - sum(site_neighbors) + local_energy
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': -0.2081818}
#standard deviation: 0.05514613194739954
#island_id: 2
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_nbr_neighbors = J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N] + J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], i, j, (k+1)%N]

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] = total_spin + sum(interacting_spins) - abs(local_energy)
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': 0.0162318}
#standard deviation: 0.07223983602390027
#island_id: 2
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = J[[0, 1, 2], :, :, :].sum(axis=0)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, :].sum(axis=0)
        total_spin = interacting_spins[i, j, k]
        
        local_energy = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - site_neighbors.sum()
        priorities[i * N * N + j * N + k][1] = total_spin
        
        if local_energy < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(local_energy))
        elif local_energy > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(local_energy))
          
  return priorities




#score: {'data3D.txt': 0.10783340000000001}
#standard deviation: 0.04641955497890948
#island_id: 2
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], (i + k - 1) % N, (j + k - 1) % N, k]
        priorities[i * N * N + j * N + k][0] = total_spin + sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] = total_spin
        
        site_nbr_neighbors = J[[3, 4, 5], (i + 1) % N if i < N - 1 else i, (j + 1) % N if j < N - 1 else j, (k + 1) % N if k < N - 1 else k]
        site_neighbors = J[[3, 4, 5], (i + k - 1) % N, (j + k - 1) % N, k]
        
        local_energy = h[i][j][k]
        if local_energy < 0:
          priorities[i * N * N + j * N + k][0] = -2 * local_energy
        elif local_energy > 0:
          priorities[i * N * N + j * N + k][1] = -2 * local_energy
        
  return priorities




#score: {'data3D.txt': -0.0346778}
#standard deviation: 0.048768561052793015
#island_id: 1
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    site_neighbors = [J[0, i % N, (site_nbr + 1) % N, i // N // N], J[1, (i // N // N + (i % N)) % N, i % N, i // N // N], J[2, i % N, i % N, (i // N // N + site_nbr) % N]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_neighbors_sum = sum(val for val in site_neighbors)
    
    priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
    priorities[i][1] -= 2 - 2 * (site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0)
    
    neighbor_spin = J[2, i % N, i // N % N, max(0, i // N // N - 1)]
    if h[i % N][i // N % N][max(0, i // N // N - 1)] > 0:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in [neighbor_spin] if val < 0]) + neighbor_spin
      priorities[i][1] = -2 + 2 * neighbor_spin
    else:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in [neighbor_spin] if val > 0]) + neighbor_spin
      priorities[i][1] -= 2 + 2 * neighbor_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(1, N-1):
    for j in range(1, N-1):
      for k in range(1, N-1):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if sum([val for val in interacting_spins if val < 0]) > 0:
          priorities[i*N*N + j*N + k][0] += abs(site_spin) * (sum([abs(val) for val in interacting_spins]) / len(interacting_spins))
          priorities[i*N*N + j*N + k][1] -= 2 - site_spin
        else:
          priorities[i*N*N + j*N + k][0] -= abs(site_spin) * (sum([abs(val) for val in interacting_spins]) / len(interacting_spins))
          priorities[i*N*N + j*N + k][1] = -2 + site_spin
  
  return(priorities)




#score: {'data3D.txt': -0.045344999999999996}
#standard deviation: 0.04849863230030307
#island_id: 1
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    site_neighbors = [J[0, i % N, (site_nbr + 1) % N, i // N // N], J[1, (i // N // N + (i % N)) % N, i % N, i // N // N], J[2, i % N, i % N, (i // N // N + site_nbr) % N]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_neighbors_sum = sum(val for val in site_neighbors)
    
    priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
    priorities[i][1] -= 2 - 2 * (site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0)
    
    neighbor_spin = J[2, i % N, i // N % N, i // N // N]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(neighbor_spin)) * (1 if neighbor_spin < 0 else -1) + neighbor_spin
      priorities[i][1] -= 2 - 2 * neighbor_spin
    else:
      priorities[i][0] -= np.exp(-abs(neighbor_spin)) * (1 if neighbor_spin > 0 else -1) + neighbor_spin
      priorities[i][1] = -2 + 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.051425399999999996}
#standard deviation: 0.0489573630298855
#island_id: 1
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    site_neighbors = [J[0, i % N, (site_nbr + 1) % N, i // N // N], J[1, (i // N // N + (i % N)) % N, i % N, i // N // N], J[2, i % N, i % N, (i // N // N + site_nbr) % N]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_neighbors_sum = sum(val for val in site_neighbors)
    
    priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
    priorities[i][1] -= 2 - 2 * (site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0)
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= sum(4 - 4 * h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = sum(-4 + 4 * h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
  return(priorities)




#score: {'data3D.txt': 0.06512860000000001}
#standard deviation: 0.04750530056783138
#island_id: 0
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        site_nbr_sum = 0
        for d in range(6):
          if d < 3:
            interacting_spins_sum += -J[d, i, j, k] * h[(i+(d%3)-1)%N, (j+(d%2-1))%N, (k+d//3)%N]
            site_nbr_sum += J[d, i, j, k]
          else:
            interacting_spins_sum += -J[d, (i+1)%N if d == 3 else (i+N-1)%N, j, k] * h[i, j, (k+(d-3))%N]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += interacting_spins_sum + site_nbr_sum + np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 4 - 4 * h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= interacting_spins_sum + site_nbr_sum - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -4 + 4 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.24676180000000014}
#standard deviation: 0.04532650020418518
#island_id: 0
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0) - h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0) - h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -4 + 4 * h[i][j][k]

        interacting_spins_sum += sum(val for val in [J[d,i,j,k] for d in range(3)] if val < 0) - sum(val for val in [J[d,i,j,k] for d in range(3)] if val > 0)
        
  return(priorities)




#score: {'data3D.txt': 0.2528942}
#standard deviation: 0.04531833763897348
#island_id: 0
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in range(6)] if val < 0)
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in range(6)] if val > 0)
          priorities[i * N * N + j * N + k][1] = -4 + 4 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4139914}
#standard deviation: 0.042092154685166694
#island_id: 0
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if neighbor_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] += 2
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4523142000000003}
#standard deviation: 0.0462153580356141
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_magnetism = h[i][j][k]
        
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(site_magnetism) * (site_magnetism)
        priorities[i * N * N + j * N + k][1] -= site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.4523142000000003}
#standard deviation: 0.0462153580356141
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4709554000000002}
#standard deviation: 0.04573960002929628
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  # Add a new term based on the site magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4133514000000003}
#standard deviation: 0.04776248818937305
#island_id: 3
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the site magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.1076574}
#standard deviation: 0.04657287649737774
#island_id: 3
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
        
        # Add interaction with site_neighbors
        priority_up += np.sum([val if val > 0 else -val for val in interacting_spins]) + np.exp(h[i][j][k])
        priority_down -= priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
        
  return priorities




#score: {'data3D.txt': -0.0550098}
#standard deviation: 0.04614385272124555
#island_id: 3
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = h[i][j][k]
        
        if site_nbr > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) - 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins) - 2
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors_up = [val if val > 0 else -val for val in site_neighbors]
        site_neighbors_down = [-val if val < 0 else val for val in site_neighbors]
        
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors_up) + np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= np.sum(site_neighbors_down)
  
  return priorities




#score: {'data3D.txt': 0.020043}
#standard deviation: 0.047036236573518506
#island_id: 3
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k])
        priority_up += np.sum([val if val > 0 else -val for val in site_neighbors]) * abs(total_spin)
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': 0.04881460000000003}
#standard deviation: 0.05196393890805431
#island_id: 0
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        
        site_neighbors_sum = sum(J[d, (i+1)%N, j, k]+J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0777934}
#standard deviation: 0.06472499854337581
#island_id: 2
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]
        site_energy = sum(interacting_spins)
        site_neighbors_energy = sum(site_nbr_neighbors)

        # Calculate the energy difference
        for spin in [-1, 1]:
          new_spin_energy = sum(spin * [interacting_spin for interacting_spin in interacting_spins])
          new_spin_neighbors_energy = sum(spin * [site_neighbor for site_neighbor in site_nbr_neighbors] + spin * [site_neighbor for site_neighbor in site_neighbors])

          priorities[i * N * N + j * N + k][0] = -new_spin_energy - new_spin_neighbors_energy
          priorities[i * N * N + j * N + k][1] = new_spin_energy

  return priorities




#score: {'data3D.txt': -0.0777934}
#standard deviation: 0.06472499854337581
#island_id: 2
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        # Calculate the energy difference
        site_energy = sum(interacting_spins)
        site_neighbors_energy = sum(site_nbr_neighbors)

        spin0_energy = site_energy - len([val for val in interacting_spins if val < 0])
        spin1_energy = site_energy + len([val for val in interacting_spins if val < 0])

        priorities[i * N * N + j * N + k][0] = -spin0_energy - sum(val for val in site_neighbors) - np.sum(site_nbr_neighbors)
        priorities[i * N * N + j * N + k][1] = spin1_energy

  return priorities




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(d+1)%3 for d in range(6)]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(d+1)%3 for d in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.sum([-spin*np.exp(-abs(np.sum(interacting_spins))) for spin in interacting_spins]) + total_spin
      priorities[i][1] = -2 + 2 * (total_spin + len([val for val in interacting_spins if val < 0]))
    else:
      priorities[i][0] = np.sum([-spin*np.exp(-abs(np.sum(interacting_spins))) for spin in interacting_spins]) - total_spin
      priorities[i][1] = -2 + 2 * (total_spin - len([val for val in interacting_spins if val > 0]))
    
  return(priorities)




#score: {'data3D.txt': -0.049206599999999996}
#standard deviation: 0.04974960739985794
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(d+2)%3 for d in range(6)]]
    
    total_spin = sum(J[d, i % N, i // N % N, i // N // N] for d in [(d+2)%3 for d in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0200278}
#standard deviation: 0.04635518166462083
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.array([np.roll(h, -1, axis=i) for i in range(3)] + 
                 [np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = sum(J[d, i % N, site_nbr, i // N // N] * 
                interacting_spins[d][i % N, site_nbr, i // N // N] for d in range(6))
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -interacting_spin
      priorities[i][1] -= 2 - 2 * interacting_spin
    else:
      priorities[i][0] -= -interacting_spin
      priorities[i][1] = 2 - 2 * interacting_spin
  
  return(priorities)




#score: {'data3D.txt': 0.03135299999999999}
#standard deviation: 0.04822562877765307
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):        
    interacting_spins[i+3] = np.roll(h, 1, axis=i)    
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    total_spin = sum(J[d,i%N,i//N%N,i//N//N]*interacting_spins[d,site_nbr,i//N%N,i//N//N] 
            for d in [(i // N // N + d) % 3 for d in [-1,0,1]])
    
    if h[i%N][i//N%N][i//N//N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0082766}
#standard deviation: 0.047258708535464655
#island_id: 1
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, site_nbr, i // N // N] 
               for d in [(i // N // N + d) % 3 for d in [-1, 0, 1]]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.34222139999999956}
#standard deviation: 0.04501484268594082
#island_id: 3
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)

        # Calculate priority for down spin
        priority_down = -priority_up

        # Add a term based on the magnetism at the current site and its neighbors
        for d, neighbor in enumerate(site_neighbors):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= h[i][j][k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k]) * abs(h[i][j][k])
            priorities[i * N * N + j * N + k][1] = -h[i][j][k]

        # Add a term based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.0195934}
#standard deviation: 0.05132468642320185
#island_id: 3
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        if total_spin > 0:
          priority_up = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
        else:
          priority_up = -np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
        
        # Calculate priority for down spin
        priority_down = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': 0.3880034}
#standard deviation: 0.04714978290978655
#island_id: 3
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        # Add a term based on the magnetism at the current site
        if h[i][j][k] > 0:
          priority_up += np.exp(-abs(total_spin))
          priority_down -= np.exp(-abs(total_spin))
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': 0.3880034}
#standard deviation: 0.04714978290978655
#island_id: 3
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        priority_up = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priority_up += np.exp(h[i][j][k]) * abs(h[i][j][k])
        
        # Calculate priority for down spin
        priority_down = -priority_up
        
        # Add a term based on the magnetism at the current site
        if h[i][j][k] > 0:
          priority_up += np.exp(-abs(total_spin))
          priority_down -= np.exp(-abs(total_spin))
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': -0.0121094}
#standard deviation: 0.04514786010034141
#island_id: 1
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] * interacting_spins[d] for d in [(i // N // N + k) % 3 for k in range(6)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] = -2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.010442599999999998}
#standard deviation: 0.04781977734410733
#island_id: 1
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[(i // N // N + k) % 6, i % N, (i // N) % N, (i // N // N) % N] 
                          for k in range(6)]
    
    total_spin = sum(J[d, i % N, (i // N) % N, (i // N // N) % N] * interacting_spins[d] 
                      for d in [(i // N // N + k) % 6 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) + total_spin
      priorities[i][1] = -2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0121094}
#standard deviation: 0.04514786010034141
#island_id: 1
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] * interacting_spins[d] for d in [(i // N // N + k) % 3 for k in range(6)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] = -2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.04389819999999999}
#standard deviation: 0.04631438822612256
#island_id: 0
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0019510000000000003}
#standard deviation: 0.047062147411693823
#island_id: 0
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
        site_neighbors_sum = sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0060958}
#standard deviation: 0.047259502138300186
#island_id: 0
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
        site_neighbors_sum = sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.16706619999999997}
#standard deviation: 0.04552272374935402
#island_id: 0
#version_generated: 3
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4404694}
#standard deviation: 0.0436136449249544
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
        # Add a new term based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.34995459999999995}
#standard deviation: 0.0427275590086773
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4404694}
#standard deviation: 0.0436136449249544
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3124974}
#standard deviation: 0.04398079482274053
#island_id: 3
#version_generated: 3
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin)) * (h[i][j][k] > 0)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.050697799999999994}
#standard deviation: 0.04621734474372149
#island_id: 0
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  # Add a term to account for the interaction with the site's own neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.04389819999999999}
#standard deviation: 0.04631438822612256
#island_id: 0
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.002107399999999983}
#standard deviation: 0.04847746966622742
#island_id: 0
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.04389819999999999}
#standard deviation: 0.04631438822612256
#island_id: 0
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.32196220000000003}
#standard deviation: 0.044285587397707625
#island_id: 3
#version_generated: 3
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32196220000000003}
#standard deviation: 0.044285587397707625
#island_id: 3
#version_generated: 3
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32196220000000003}
#standard deviation: 0.044285587397707625
#island_id: 3
#version_generated: 3
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42009500000000005}
#standard deviation: 0.046969192190200584
#island_id: 2
#version_generated: 3
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.0323486}
#standard deviation: 0.049204709104312364
#island_id: 2
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(local_energies[i][j][k]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

        # Add a new term to encourage the spins to align with the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.07811940000000007}
#standard deviation: 0.04680337021668418
#island_id: 2
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  local_energies = np.sum(J[:, :, :], axis=0) + h

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  # Add a new term to encourage the spins to align with the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4123762}
#standard deviation: 0.04391275934805282
#island_id: 2
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]

        local_energy = h[i][j][k] - total_spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_nbr_neighbors) + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': 0.2431897999999999}
#standard deviation: 0.04526186757039529
#island_id: 3
#version_generated: 3
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        if h[i][j][k] > 0:
          priority_up = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][0] = priority_up
        else:
          priority_down = -np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = priority_down
  
  return priorities




#score: {'data3D.txt': -0.0195934}
#standard deviation: 0.05132468642320185
#island_id: 3
#version_generated: 3
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        if total_spin > 0:
          priority_up = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
        else:
          priority_up = -np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
        
        # Calculate priority for down spin
        priority_down = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': -0.0195934}
#standard deviation: 0.05132468642320185
#island_id: 3
#version_generated: 3
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority for up spin
        if total_spin > 0:
          priority_up = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
        else:
          priority_up = -np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
        
        # Calculate priority for down spin
        priority_down = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(val for val in interacting_spins)
        
        priorities[i * N * N + j * N + k] = [priority_up, priority_down]
  
  return priorities




#score: {'data3D.txt': -0.3405214}
#standard deviation: 0.04359544863904947
#island_id: 0
#version_generated: 3
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + sum(-val for val in [J[d,i,j,k] for d in range(6)] if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + sum(val for val in [J[d,i,j,k] for d in range(6)] if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.001310200000000001}
#standard deviation: 0.043540720893894255
#island_id: 0
#version_generated: 3
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*(h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]-2*h[i][j][k]) for d in range(6))
        priorities[i * N * N + j * N + k][0] = interacting_spins_sum
        priorities[i * N * N + j * N + k][1] = -2
  return(priorities)




#score: {'data3D.txt': -0.021658999999999998}
#standard deviation: 0.0465039955165145
#island_id: 0
#version_generated: 3
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + sum(-J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + sum(-J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.1054562}
#standard deviation: 0.04843295986784206
#island_id: 2
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_corr = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) + sum(site_corr)
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.4404694}
#standard deviation: 0.0436136449249544
#island_id: 3
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0816458}
#standard deviation: 0.04500155488824803
#island_id: 3
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_neighbor_spin))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_neighbor_spin))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(h[i][j][k] + total_neighbor_spin))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.002107399999999983}
#standard deviation: 0.04847746966622742
#island_id: 0
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.02513780000000002}
#standard deviation: 0.05032027594479188
#island_id: 0
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins_sum_pos = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
          interacting_spins_sum_neg = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6) if J[d,i,j,k] < 0)
          priorities[i * N * N + j * N + k][0] = interacting_spins_sum_pos - interacting_spins_sum_neg
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          interacting_spins_sum_neg = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6) if J[d,i,j,k] > 0)
          interacting_spins_sum_pos = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
          priorities[i * N * N + j * N + k][0] = interacting_spins_sum_neg - interacting_spins_sum_pos
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.02684099999999999}
#standard deviation: 0.04798852403439806
#island_id: 0
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_sum_pos = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6) if J[d,i,j,k]>0)
        interacting_spins_sum_neg = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6) if J[d,i,j,k]<0)
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum_pos
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum_neg
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.0594706}
#standard deviation: 0.04539587663698103
#island_id: 0
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_sum = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        site_nbr_energy = -2 * h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= site_nbr_energy
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = site_nbr_energy
  return(priorities)




#score: {'data3D.txt': -0.2421374}
#standard deviation: 0.049076485216853094
#island_id: 3
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_energy = -np.sum([val for val in interacting_spins if val < 0]) - total_spin
        neighbor_energy = np.sum(site_neighbors)
        
        site_energy = h[i][j][k]
        local_energy = -site_energy
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(local_energy)) * (interacting_spin_energy + neighbor_energy) + abs(local_energy)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * local_energy
        
  return priorities




#score: {'data3D.txt': -0.2030334}
#standard deviation: 0.04997521990386836
#island_id: 2
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_nbr_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        
        local_energy = h[i][j][k] - total_spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors) + 2 * sum(val for val in site_nbr_neighbors) + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.3538918}
#standard deviation: 0.043051469809519856
#island_id: 2
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]

        local_energy = h[i][j][k] - total_spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_nbr_neighbors) + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return np.flip(priorities, axis=1)




#score: {'data3D.txt': -0.3964214}
#standard deviation: 0.04072070114867867
#island_id: 3
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, spin and neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (abs(h[i][j][k]) + sum(abs(val) for val in interacting_spins) + sum(abs(val) for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3964214}
#standard deviation: 0.04072070114867867
#island_id: 3
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, spin and neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (abs(h[i][j][k]) + sum(abs(val) for val in interacting_spins) + sum(abs(val) for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.37494179999999994}
#standard deviation: 0.04129502842667626
#island_id: 3
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, spin and neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (abs(h[i][j][k]) + sum(abs(val) for val in interacting_spins) + sum(abs(val) for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3964214}
#standard deviation: 0.04072070114867867
#island_id: 3
#version_generated: 3
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, spin and neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (abs(h[i][j][k]) + sum(abs(val) for val in interacting_spins) + sum(abs(val) for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.2298798}
#standard deviation: 0.05130399196904662
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  local_energies = np.sum(J[:, :, :], axis=0) + h
  interacting_spins = J[[0, 1, 2], ...].sum(axis=0)
  site_neighbors = J[[3, 4, 5], ...].sum(axis=0)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = interacting_spins[i, j, k]
        site_corr_neighbors = J[[0, 1, 2], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N].sum(axis=0)

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins[i, j, :] if val < 0]) + total_spin + site_corr_neighbors
        priorities[i * N * N + j * N + k][1] = -total_spin + site_corr_neighbors

        priorities[i * N * N + j * N + k][0] += local_energies[i][j][k]
        priorities[i * N * N + j * N + k][1] -= local_energies[i][j][k]

  return priorities




#score: {'data3D.txt': -0.2747298}
#standard deviation: 0.04411018739429703
#island_id: 2
#version_generated: 3
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_corr_neighbors = J[[0, 1, 2], (i+((k-1)%2-1))%N, (j+(k-1)%2-1)%N, (k+(k-1)%2-1)%N] + J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k]

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += -total_spin - sum(interacting_spins) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0]) + sum(val for val in site_corr_neighbors) + h[i][j][k] * total_spin
        priorities[i * N * N + j * N + k][1] = -total_spin

  return priorities




#score: {'data3D.txt': -0.16706619999999997}
#standard deviation: 0.04552272374935402
#island_id: 0
#version_generated: 3
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.014466599999999996}
#standard deviation: 0.047427421650770775
#island_id: 0
#version_generated: 3
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.16706619999999997}
#standard deviation: 0.04552272374935402
#island_id: 0
#version_generated: 3
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0080922}
#standard deviation: 0.04756782041632767
#island_id: 1
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, site_nbr, i % N, i // N % N] 
               for d in [(d+2)%6 for d in range(3)]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    else:
      priorities[i][0] = 2 - 2 * total_spin
      priorities[i][1] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
    
    # Add the magnetism to the priority
    priorities[i][0] += h[i % N][i // N % N][i // N // N]
    priorities[i][1] -= h[i % N][i // N % N][i // N // N]
  
  return(priorities)




#score: {'data3D.txt': -0.0863242}
#standard deviation: 0.0605183725356193
#island_id: 2
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + \
                 J[[3, 4, 5], (i + 1) % N, j, k] + \
                 J[[3, 4, 5], i, j, (k + 1) % N]

        # Calculate the total magnetization
        total_magnetization = sum(interacting_spins)

        priorities[i * N * N + j * N + k][0] = -total_magnetization - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] = total_magnetization

  return priorities




#score: {'data3D.txt': -0.07986739999999999}
#standard deviation: 0.05282067906833459
#island_id: 2
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], i, j, (k + 1) % N] + J[[3, 4, 5], (i + 1) % N, j, k]
        site_nbr_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]

        spin0_energy = sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + site_neighbors[0] + site_neighbors[1] + site_neighbors[2]
        spin1_energy = sum(interacting_spins) + len([val for val in interacting_spins if val < 0]) - site_nbr_neighbors.sum()

        priorities[i * N * N + j * N + k][0] = -spin0_energy
        priorities[i * N * N + j * N + k][1] = spin1_energy

  return priorities




#score: {'data3D.txt': -0.3677682000000001}
#standard deviation: 0.05044341928101227
#island_id: 2
#version_generated: 3
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_nbr_neighbors = J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N] + J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], i, j, (k+1)%N]

        local_energy = h[i][j][k]
        
        # Prioritize spins based on local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin + local_energy
        priorities[i * N * N + j * N + k][1] -= local_energy
        
  return priorities




#score: {'data3D.txt': -0.0900058}
#standard deviation: 0.062439033355426
#island_id: 2
#version_generated: 3
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]
        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        
        priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - np.sum(site_neighbors) - np.sum(site_nbr_neighbors)
        priorities[i * N * N + j * N + k][1] = np.sum(interacting_spins) + np.sum(site_neighbors) + np.sum(site_nbr_neighbors)

  return priorities




#score: {'data3D.txt': -0.2720174}
#standard deviation: 0.036569149528530194
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + sum(val for val in site_nbr_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_nbr_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2720174}
#standard deviation: 0.036569149528530194
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        
        site_nbr_neighbors_sum = sum(site_nbr_neighbors)
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + site_nbr_neighbors_sum
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
        
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_nbr_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.24564539999999999}
#standard deviation: 0.037207968754555794
#island_id: 2
#version_generated: 3
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        site_nbr_neighbors_sum = sum(val for val in site_nbr_neighbors)
        
        if np.sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) + site_nbr_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_nbr_neighbors_sum
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
        
        else:
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3979262}
#standard deviation: 0.04868226569871209
#island_id: 0
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        avg_spin = np.mean([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (avg_spin - total_spin) / len([J[f, i, j, k] for f in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= (avg_spin - total_spin) / len([J[f, i, j, k] for f in range(6)])
        
  return priorities




#score: {'data3D.txt': -0.38006619999999997}
#standard deviation: 0.051496574425489695
#island_id: 0
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  
  return priorities




#score: {'data3D.txt': -0.3773458}
#standard deviation: 0.05124406211806398
#island_id: 0
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        avg_spin = np.mean([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (avg_spin - total_spin) / len([J[f, i, j, k] for f in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= (avg_spin - total_spin) / len([J[f, i, j, k] for f in range(6)])
        
  return(priorities)




#score: {'data3D.txt': -0.2998306}
#standard deviation: 0.054969349128764486
#island_id: 0
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        avg_spin = np.mean([val for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        avg_site_spin = np.mean([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (avg_site_spin - total_spin) / len(site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= (avg_site_spin - total_spin) / len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 0
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.32683619999999997}
#standard deviation: 0.04461834700613639
#island_id: 2
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = J[[0, 1, 2], :, :, :]
  site_nbr_neighbors = J[[3, 4, 5], :, :, :]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(interacting_spins[:, i, j, k])
        local_energy = h[i][j][k] - total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:, i, j, k] if val < 0]) + sum(val for val in site_nbr_neighbors[:, i, (j+1)%N, k] + site_nbr_neighbors[:, (i+1)%N, j, k] + site_nbr_neighbors[:, i, j, (k+1)%N])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return np.flip(priorities, axis=1)




#score: {'data3D.txt': -0.30527060000000006}
#standard deviation: 0.04650526610653895
#island_id: 2
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_nbr_neighbors = J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        local_energy = h[i][j][k] - total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in site_neighbors) + sum(val for val in site_nbr_neighbors) + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return np.flip(priorities, axis=1)




#score: {'data3D.txt': 0.2948446}
#standard deviation: 0.05276240679536899
#island_id: 2
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k] + J[[0, 1, 2], i, j, (k+1)%N]
        site_corr = J[[3, 4, 5], (i+(k-1)%2-1)%N, (j+(k-1)%2-1)%N, (k+(k-1)%2-1)%N]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) - site_corr.sum() + 2*sum([spin for spin in interacting_spins if spin<0])
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.0020038}
#standard deviation: 0.04856142281235178
#island_id: 2
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):  
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N**3):
    spin1 = -1
    if sum(J[[0,1,2],i//N**(2),(i//100)%10,(i%100)//10]) > 0:
      spin1 = 1
    for l in range(6):
      priorities[i][0] += -J[l,i//N**(2),(i//100)%10,(i%100)//10]*interacting_spins[l][i//N**(2),(i//100)%10,(i%100)//10]
    if spin1 == 1:
      for l in range(6):
        priorities[i][0] += -J[l,i//N**(2),(i//100)%10,(i%100)//10]
    else:
      for l in range(6):
        priorities[i][0] += J[l,i//N**(2),(i//100)%10,(i%100)//10]

  return priorities




#score: {'data3D.txt': -0.2242578}
#standard deviation: 0.05765519628931984
#island_id: 2
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, k]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        
        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, k]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins) - site_corr.sum() + len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.0026818000000000002}
#standard deviation: 0.04701549604928145
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum_pos = sum(J[d, (i+(d%3)-1)%N, (j+(d%2-1))%N, (k+d//3)%N] * h[(i+(d%3)-1)%N, (j+(d%2-1))%N, (k+d//3)%N] for d in range(6) if J[d, i, j, k]>0)
        interacting_spins_sum_neg = sum(J[d, (i+(d%3)-1)%N, (j+(d%2-1))%N, (k+d//3)%N] * h[(i+(d%3)-1)%N, (j+(d%2-1))%N, (k+d//3)%N] for d in range(6) if J[d, i, j, k]<0)
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum_pos
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum_neg
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.00045059999999997214}
#standard deviation: 0.04860625761812979
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_sum_pos = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6) if J[d,i,j,k]>0)
        interacting_spins_sum_neg = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6) if J[d,i,j,k]<0)
        site_neighbors = [J[0,i,site_nbr,k], J[1,i,j,site_nbr], J[2,i,site_nbr,k]]
        interacting_spins_sum_pos_neighbors = sum(-val*h[i,site_nbr,k] for val in site_neighbors if val>0)
        interacting_spins_sum_neg_neighbors = sum(-val*h[i,site_nbr,k] for val in site_neighbors if val<0)
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum_pos + interacting_spins_sum_pos_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum_neg + interacting_spins_sum_neg_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3412709999999996}
#standard deviation: 0.04534112172189831
#island_id: 0
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum_pos = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] 
                         for d in range(6) if J[d,i,j,k]>0)
        interacting_spins_sum_neg = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] 
                         for d in range(6) if J[d,i,j,k]<0)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum_pos 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum_neg
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]

  # Add a new term based on the local energy
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0017645999999999996}
#standard deviation: 0.04567651723632177
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_nbr_neighbors = J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N] + J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], i, j, (k+1)%N]

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] = total_spin - abs(local_energy)
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': -0.036492199999999995}
#standard deviation: 0.0459689906258556
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, k]
        site_nbr_neighbors = J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N] + J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], i, j, (k+1)%N]
        
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] = total_spin - abs(local_energy) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.0382358}
#standard deviation: 0.04825081842165996
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[[0, 1, 2], i, j, k])
        site_neighbors = np.sum(J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N])
        site_nbr_neighbors = np.sum(J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N]) + np.sum(J[[3, 4, 5], i, (j+1)%N, k]) + np.sum(J[[3, 4, 5], i, j, (k+1)%N])
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] = total_spin + site_neighbors - abs(local_energy)
        priorities[i * N * N + j * N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.35108619999999996}
#standard deviation: 0.049790299151139875
#island_id: 2
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_neighbors = J[[3, 4, 5], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_nbr_neighbors = J[[3, 4, 5], (i+1)%N, (j+1)%N, (k+1)%N] + J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], i, j, (k+1)%N]

        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] = total_spin - abs(local_energy) if total_spin > 0 else -total_spin
        priorities[i * N * N + j * N + k][1] = total_spin

  return priorities




#score: {'data3D.txt': 0.031854600000000004}
#standard deviation: 0.04714983540628747
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.sum([spin * abs(spin) for spin in interacting_spins]) - len([val for val in interacting_spins if val < 0])
      priorities[i][1] -= 2 + 2 * h[i % N][i // N % N][i // N // N]
    else:
      priorities[i][0] -= np.sum([spin * abs(spin) for spin in interacting_spins]) - len([val for val in interacting_spins if val > 0])
      priorities[i][1] = -2 - 2 * h[i % N][i // N % N][i // N // N]
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i % N, j, k] for d in [(i//N)%6]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.011670200000000002}
#standard deviation: 0.04735211074450642
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i // N % N, i // N // N] for d in [(d+1)%6 for d in range(6)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(d+1)%6 for d in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.sum([-spin*np.exp(-abs(np.sum(interacting_spins))) for spin in interacting_spins]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    else:
      priorities[i][0] -= np.sum([-spin*np.exp(-abs(np.sum(interacting_spins))) for spin in interacting_spins]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0392158}
#standard deviation: 0.04816863243190531
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    for d in range(6):
      site_nbrs = [(d+1)%3, (d+4)%6]
      for axis in site_nbrs:
        interacting_spins.append(J[axis, i % N, i // N % N, i // N // N])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.38006619999999997}
#standard deviation: 0.051496574425489695
#island_id: 0
#version_generated: 3
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.36637260000000005}
#standard deviation: 0.05095091921879329
#island_id: 0
#version_generated: 3
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + site_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + site_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.30742820000000004}
#standard deviation: 0.05519898735266799
#island_id: 0
#version_generated: 3
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.025556600000000117}
#standard deviation: 0.04769615158941024
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = []
        
        # Get all nearest neighbors
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+d)%N, j, k])
          site_neighbors.append(J[3-d, i, (j+d)%N, k])
          site_neighbors.append(J[4-d, i, j, (k+d)%N])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins + site_neighbors if val < 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins + site_neighbors if val > 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.16294579999999992}
#standard deviation: 0.047176242986910276
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(val for val in interacting_spins)
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin + neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.10255219999999997}
#standard deviation: 0.0466008977934975
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(val for val in interacting_spins)
        
        total_neighbor_spin = sum(val for val in site_neighbors)
        total_spin = sum(val for val in interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (h[i][j][k] > 0) - total_spin
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] + total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1871105999999999}
#standard deviation: 0.046224341289411594
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in interacting_spins) - np.exp(h[i][j][k]) * abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(val for val in interacting_spins) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 2
#version_generated: 3
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], i, j, (k + 1) % N] + J[[3, 4, 5], (i + 1) % N, j, k]
        site_corr_neighbors = J[[0, 1, 2], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N] + J[[0, 1, 2], i, j, k]

        spin0_energy = sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + site_neighbors.sum() + site_corr_neighbors.sum()
        spin1_energy = sum(interacting_spins) + len([val for val in interacting_spins if val < 0]) - site_neighbors.sum() - site_corr_neighbors.sum()

        priorities[i * N * N + j * N + k][0] = -spin0_energy
        priorities[i * N * N + j * N + k][1] = spin1_energy

  return priorities




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 2
#version_generated: 3
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = J[[3, 4, 5], i, (j+1)%N, k] + J[[3, 4, 5], (i+1)%N, j, k] + J[[3, 4, 5], i, j, (k+1)%N]
        site_corr_neighbors = J[[0, 1, 2], (i+(k-1)%2-1)%N, (j+(k-1)%2-1)%N, (k+(k-1)%2-1)%N] + J[[0, 1, 2], i, (j+1)%N, k] + J[[0, 1, 2], (i+1)%N, j, k]

        spin0_energy = sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) + site_neighbors.sum() + site_corr_neighbors.sum()
        spin1_energy = sum(interacting_spins) + len([val for val in interacting_spins if val < 0]) - site_neighbors.sum() - site_corr_neighbors.sum()

        priorities[i * N * N + j * N + k][0] = -spin0_energy
        priorities[i * N * N + j * N + k][1] = spin1_energy

  return priorities




#score: {'data3D.txt': 0.09930619999999998}
#standard deviation: 0.05444408105166254
#island_id: 2
#version_generated: 3
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], i, j, (k + 1) % N] + J[[3, 4, 5], (i + 1) % N, j, k]
        site_corr_neighbors = J[[0, 1, 2], (i + (k - 1) % 2 - 1) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]

        # Add a new term based on the local energy and spatial correlations
        priorities[i * N * N + j * N + k][0] = -sum(interacting_spins) - site_neighbors.sum() + sum([val for val in site_corr_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]

  return priorities




#score: {'data3D.txt': -0.35975300000000027}
#standard deviation: 0.04547887675613812
#island_id: 0
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          total_neighbor_spin = sum(val for val in site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.00021259999999999246}
#standard deviation: 0.04776071734427782
#island_id: 0
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, i, j, k] * h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.04389819999999999}
#standard deviation: 0.04631438822612256
#island_id: 0
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.04508499999999998}
#standard deviation: 0.0462876002294351
#island_id: 0
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i * N * N + j * N + k][0] += sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += sum(-J[d+3,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.20125180000000037}
#standard deviation: 0.0518636427255163
#island_id: 0
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * h[(i+(d%3)-1)%N, (j+(d%2-1))%N, (k+d//3)%N] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - sum(J[d, i, j, k] for d in range(6))
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum(J[d, i, j, k] for d in range(6))
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.014180600000000109}
#standard deviation: 0.047085829541805894
#island_id: 3
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = []
        
        # Get all nearest neighbors
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+d)%N, j, k])
          site_neighbors.append(J[3-d, i, (j+d)%N, k])
          site_neighbors.append(J[4-d, i, j, (k+d)%N])
        
        total_spin = sum(interacting_spin for interacting_spin in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.06318700000000009}
#standard deviation: 0.04790521089610191
#island_id: 3
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = []
        
        # Get all nearest neighbors
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+d)%N, j, k])
          site_neighbors.append(J[3-d, i, (j+d)%N, k])
          site_neighbors.append(J[4-d, i, j, (k+d)%N])
        
        for d in [0, 1, 2]:
          interacting_spins.append(J[d+3, (i+d)%N, (j+d)%N, (k+d)%N])
        
        # Calculate priority for up spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins + site_neighbors if val < 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins + site_neighbors if val > 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum(interacting_spins)
        
        # Add a term based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.025556600000000117}
#standard deviation: 0.04769615158941024
#island_id: 3
#version_generated: 3
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = []

        # Get all nearest neighbors
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+d)%N, j, k])
          site_neighbors.append(J[3-d, i, (j+d)%N, k])
          site_neighbors.append(J[4-d, i, j, (k+d)%N])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins + site_neighbors if val < 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs(interacting_spins))) * len([val for val in interacting_spins + site_neighbors if val > 0]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum(interacting_spins)

        # Add a term based on the site magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.03765779999999999}
#standard deviation: 0.05927095729916972
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_corr_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        site_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += -total_spin - sum(interacting_spins) - np.sum(site_nbr_neighbors) - np.sum(site_corr)
        priorities[i * N * N + j * N + k][1] += total_spin - site_energy

  return priorities




#score: {'data3D.txt': 0.1115438}
#standard deviation: 0.04588420034783215
#island_id: 2
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)

        site_nbr_neighbors = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        site_corr = J[[3, 4, 5], (i + ((k - 1) % 2 - 1)) % N, (j + (k - 1) % 2 - 1) % N, (k + (k - 1) % 2 - 1) % N]
        site_corr_neighbors = J[[3, 4, 5], i, (j + 1) % N, k] + J[[3, 4, 5], (i + 1) % N, j, k] + J[[3, 4, 5], i, j, (k + 1) % N]

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -total_spin

        # Add a new term based on the spatial correlations
        site_corr_sum = sum(site_corr) + sum(site_corr_neighbors)
        priorities[i * N * N + j * N + k][0] += site_corr_sum
        priorities[i * N * N + j * N + k][1] -= site_corr_sum

  return priorities




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.017946200000000002}
#standard deviation: 0.045944379695018196
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(interacting_spins)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    # Add the magnetism to the priority
    priorities[i][0] += h[i % N][i // N % N][i // N // N]
    priorities[i][1] -= h[i % N][i // N % N][i // N // N]

  return(priorities)




#score: {'data3D.txt': -0.023339}
#standard deviation: 0.04540344479221813
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = []
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    for k in range(6):
      if k < 3:
        interacting_spins.append(J[k, site_nbr, i % N, i // N % N])
      else:
        interacting_spins.append(J[k-3, (site_nbr + 1) % N, i % N, i // N % N])

    total_spin = sum(interacting_spins)

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

    # Add the magnetism to the priority
    priorities[i][0] += h[i % N][i // N % N][i // N // N]
    priorities[i][1] -= h[i % N][i // N % N][i // N // N]

  return(priorities)




#score: {'data3D.txt': -0.017946200000000002}
#standard deviation: 0.045944379695018196
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    # Add the magnetism to the priority
    priorities[i][0] += h[i % N][i // N % N][i // N // N]
    priorities[i][1] -= h[i % N][i // N % N][i // N // N]
  
  return(priorities)




#score: {'data3D.txt': -0.017946200000000002}
#standard deviation: 0.045944379695018196
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N % N] for d in [(i // N // N + k) % 3 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    # Add the magnetism to the priority
    priorities[i][0] += h[i % N][i // N % N][i // N // N]
    priorities[i][1] -= h[i % N][i // N % N][i // N // N]
  
  return(priorities)




#score: {'data3D.txt': -0.044145000000000004}
#standard deviation: 0.04422302448951225
#island_id: 2
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5455738000000001}
#standard deviation: 0.040013044792417386
#island_id: 2
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0031582000000000003}
#standard deviation: 0.04695991793817361
#island_id: 2
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        return(priorities)




#score: {'data3D.txt': 0.0071741999999999995}
#standard deviation: 0.047897307798664426
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[0, i % N, i // N % N, i // N // N],
               J[1, i % N, (i + N) % N, i // N // N],
               J[2, (i + N) % N, i % N, i // N // N]]
    total_spin = sum(interacting_spins)

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.008986199999999998}
#standard deviation: 0.04615618538787624
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[(d+1)%3,i%N,i//N%N,i//N//N] 
        for d in [(i // N // N + i % N + i // N) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0096018}
#standard deviation: 0.04551294449670335
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d,i%N,i//N%N,i//N//N] 
        if d==0 else J[(d+1)%3,i%N,i//N%N,i//N//N] 
        for d in [(i // N // N + 2) % 3]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.0087862}
#standard deviation: 0.04849173547688307
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i%N, i//N%N, i//N//N] 
              for d in [(i // N // N + d) % 3 for d in range(6)]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.16706619999999997}
#standard deviation: 0.04552272374935402
#island_id: 0
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.16706619999999997}
#standard deviation: 0.04552272374935402
#island_id: 0
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum + len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0]) - sum(J[3+d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.38986620000000005}
#standard deviation: 0.04384465825571001
#island_id: 0
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum - len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum - len([val for val in [J[d,i,j,k] for d in [0, 1, 2]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49345500000000003}
#standard deviation: 0.044801820219718756
#island_id: 1
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = np.zeros((6, N, N, N))
        for axis in range(3):
          interacting_spins[axis] = np.roll(h, -1, axis=axis)
          interacting_spins[3+axis] = np.roll(h, 1, axis=axis)
          
        total_spin += sum(J[d, i, j, k]*interacting_spins[d, site_nbr, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14217500000000002}
#standard deviation: 0.052519584680383764
#island_id: 1
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.044145000000000004}
#standard deviation: 0.04422302448951225
#island_id: 2
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        interacting_spins.sort()

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors.sort()

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.27887660000000003}
#standard deviation: 0.046523251954694644
#island_id: 2
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.044145000000000004}
#standard deviation: 0.04422302448951225
#island_id: 2
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the interaction between spins and their neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        # Add a new term based on the local energy and nearest neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4932502}
#standard deviation: 0.0401243048532931
#island_id: 0
#version_generated: 3
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N+j*N+k][1] += 1
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the interaction with the next sites
        if i > 0:
          site_neighbors = [J[0, (i-1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4938426}
#standard deviation: 0.042117802236584
#island_id: 0
#version_generated: 3
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the interaction with the next sites
        if i > 0:
          site_neighbors = [J[0, (i-1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1160258}
#standard deviation: 0.047570566681089686
#island_id: 0
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Normalize priorities to avoid overflows
        max_priority = np.max(priorities, axis=1).max()
        if max_priority > 0:
          priorities[:, 0] /= max_priority
          priorities[:, 1] /= -max_priority
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 0
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 3
#version_generated: 3
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5275562000000001}
#standard deviation: 0.04091841396681939
#island_id: 3
#version_generated: 3
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the site's magnetization
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.26756620000000014}
#standard deviation: 0.04303537634969631
#island_id: 3
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.25246660000000004}
#standard deviation: 0.03985470416952057
#island_id: 3
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.26756620000000014}
#standard deviation: 0.04303537634969631
#island_id: 3
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.26756620000000014}
#standard deviation: 0.04303537634969631
#island_id: 3
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.25982700000000014}
#standard deviation: 0.045936905762142925
#island_id: 3
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        block_nbrs = [J[0, i, j, min(k+1, N-1)], J[1, min(i+1, N-1), j, k], J[2, i, j, min(k+1, N-1)]]
        total_block_spin = sum(val for val in block_nbrs)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val < 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_block_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val > 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_block_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.26756620000000014}
#standard deviation: 0.04303537634969631
#island_id: 3
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.035633}
#standard deviation: 0.04845434130188955
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])))
    else:
      priorities[i][1] += np.exp(-abs(sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3])))

  return(priorities)




#score: {'data3D.txt': -0.0190262}
#standard deviation: 0.04690347187106728
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 3) % 6]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 3) % 6])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_nbr = (i // N % N + ((i // N // N + 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 2) % 3])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    site_nbr = (i // N % N + ((i // N // N + 2) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + 4) % 6]]
    
    total_spin = sum(J[d, site_nbr, i % N, i // N // N] for d in [(i // N // N + 4) % 6])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.256901}
#standard deviation: 0.0516783451650689
#island_id: 1
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          interacting_spins.append(J[d, i, j, k])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        for d in [3, 4, 5]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          interacting_spins.append(J[d, i, j, k])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        for d in [(i//N//N+3)%6]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          interacting_spins.append(J[d, i, j, k])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)

  return priorities




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        
        site_center_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_center_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.25246660000000004}
#standard deviation: 0.03985470416952057
#island_id: 3
#version_generated: 3
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.12240100000000026}
#standard deviation: 0.046535101149562365
#island_id: 3
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        
        site_center_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_center_neighbors))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product
          priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))*len([val for val in interacting_spins if val > 0]) - total_spin + spin_product - center_spin_product
          priorities[i*N*N+j*N+k][1] += 2-2*total_spin
        
        # Add terms based on the number of nearest neighbors with the same and opposite spins
        if k > 0:
          neighbor_spin = J[2,i,j,k-1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*1
            priorities[i*N*N+j*N+k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2,i,j,k+1]
          if neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*1
            priorities[i*N*N+j*N+k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*1
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1700778}
#standard deviation: 0.044273220654928634
#island_id: 3
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))

        site_center_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        center_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_center_neighbors))

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, j, k] < h[i, j, k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        
        site_center_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_center_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2320206}
#standard deviation: 0.0375358881024547
#island_id: 3
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        
        site_center_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_center_neighbors))
        
        neighbor_interactions = [J[d,i,(j+1)%N,k] + J[d,(i+1)%N,j,k] + J[d,i,j,(k+1)%N] for d in [0,1,2]]
        neighbor_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,neighbor_interactions))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product - neighbor_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        spin_product = sum(val1*val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        
        site_center_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        center_spin_product = sum(val1*val2 for val1, val2 in zip(interacting_spins, site_center_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15584580000000026}
#standard deviation: 0.05338130779926622
#island_id: 3
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        center_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) - center_spin_product
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) - center_spin_product
          priorities[i * N * N + j * N + k][1] += 2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        
        site_center_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_center_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - spin_product + center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0257442}
#standard deviation: 0.04840772135062753
#island_id: 0
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, i, j, k] * h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N])
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0929626}
#standard deviation: 0.04627695151195679
#island_id: 0
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
 
  return priorities




#score: {'data3D.txt': -0.39221820000000013}
#standard deviation: 0.04580872262746474
#island_id: 0
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
        # Add a new term to the priority based on the interactions with the next nearest neighbors
        next_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_next_neighbor_spin = sum(val for val in next_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin - total_next_neighbor_spin)) * len([val for val in interacting_spins if val < total_spin]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.058559799999999995}
#standard deviation: 0.047012907418707894
#island_id: 2
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
        # Added a new term to the priority based on the difference between the local spin and the nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin - total_neighbor_spin)) * len([val for val in interacting_spins if val < total_spin]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.006652599999999993}
#standard deviation: 0.04830589687853855
#island_id: 0
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        site_energy = h[i][j][k]*(2*h[i][j][k]-1) - interacting_spins_sum
        priorities[i * N * N + j * N + k][0] += site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.07551580000000001}
#standard deviation: 0.04620329241904737
#island_id: 0
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          interacting_spins_sum = sum(J[l,i,j,k]*h[(i+(l%3)-1)%N,(j+(l%2-1))%N,(k+l//3)%N] for l in range(6))
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
  
  return(priorities)




#score: {'data3D.txt': -0.026050199999999996}
#standard deviation: 0.046949975079439606
#island_id: 1
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 2) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 * np.exp(-abs(total_spin))
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 * np.exp(abs(total_spin))
    
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + 1) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 * np.exp(-abs(total_spin))
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = 2 * np.exp(abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.0057546}
#standard deviation: 0.04701914906546056
#island_id: 1
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin_0 = [J[d, i % N, i // N % N, i // N // N] 
                for d in [(i // N // N + 2) % 3]]
    interacting_spin_1 = [J[d, site_nbr, i // N % N, i // N // N] 
                for d in [(i // N // N + 2) % 3]]
    interacting_spin_2 = [J[d, i % N, site_nbr, i // N // N] 
                for d in [(i // N // N + 2) % 3]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -np.sum([abs(J[d, i % N, i // N % N, i // N // N]) 
                      for d in [(i // N // N + 2) % 3]])
      priorities[i][0] -= 2 - 2 * np.sum([abs(J[d, i % N, i // N % N, i // N // N]) 
                         for d in [(i // N // N + 2) % 3]])\
                 + 2 * np.sum([J[d, i % N, i // N % N, i // N // N] 
                       for d in [(i // N // N + 2) % 3]])
    else:
      priorities[i][0] += -np.sum([abs(J[d, i % N, i // N % N, i // N // N]) 
                      for d in [(i // N // N + 2) % 3]])
      priorities[i][1] = 2 - 2 * np.sum([abs(J[d, i % N, i // N % N, i // N // N]) 
                         for d in [(i // N // N + 2) % 3]])\
                 - 2 * np.sum([J[d, i % N, i // N % N, i // N // N] 
                       for d in [(i // N // N + 2) % 3]])
  
  return priorities




#score: {'data3D.txt': 0.03135299999999999}
#standard deviation: 0.04822562877765307
#island_id: 1
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    total_spin = sum([J[d, i % N, i // N % N, i // N // N] 
              * interacting_spins[d][site_nbr, i // N % N, i // N // N] 
              for d in [(i // N // N + 2) % 3]])
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += -total_spin
      priorities[i][0] -= 2 - 2 * total_spin
    else:
      priorities[i][1] -= -total_spin
      priorities[i][0] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.25982700000000014}
#standard deviation: 0.045936905762142925
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        block_nbrs = [J[0, i, j, min(k+1, N-1)], J[1, min(i+1, N-1), j, k], J[2, i, j, min(k+1, N-1)]]
        total_block_spin = sum(val for val in block_nbrs)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val < 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_block_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val > 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_block_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.25982700000000014}
#standard deviation: 0.045936905762142925
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        block_nbrs = [J[0, i, j, min(k+1, N-1)], J[1, min(i+1, N-1), j, k], J[2, i, j, min(k+1, N-1)]]
        total_block_spin = sum(val for val in block_nbrs)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val < 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_block_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val > 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_block_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        block_nbrs = [J[0, i, j, min(k+1, N-1)], J[1, min(i+1, N-1), j, k], J[2, i, j, min(k+1, N-1)]]
        total_block_spin = sum(val for val in block_nbrs)

        # Calculate the probability of the spin being -1
        prob_minus_one = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin / (2 * abs(total_spin))
        priorities[i * N * N + j * N + k][0] += prob_minus_one

        # Calculate the probability of the spin being 1
        prob_plus_one = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin / (2 * abs(total_spin))
        priorities[i * N * N + j * N + k][1] += prob_plus_one

  return(priorities)




#score: {'data3D.txt': -0.25982700000000014}
#standard deviation: 0.045936905762142925
#island_id: 3
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbors_spin = sum(val for val in site_neighbors)

        block_nbrs = [J[0, i, j, min(k+1, N-1)], J[1, min(i+1, N-1), j, k], J[2, i, j, min(k+1, N-1)]]
        total_block_spin = sum(val for val in block_nbrs)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val < 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_block_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbors_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbors_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_block_spin)) * len([val for val in block_nbrs if val > 0]) + total_block_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_block_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        
        # Added a new term to the priority based on the interaction between the site and its neighbors
        interaction_energy = np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        
        priorities[i * N * N + j * N + k][0] += interaction_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) - site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-site_energy)
        
  return(priorities)




#score: {'data3D.txt': -0.004763}
#standard deviation: 0.04760842815090622
#island_id: 0
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = 0
        for d in range(6):
          interacting_spins_sum += -J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -4 + 4 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 3
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 3
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 3
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 3
#version_generated: 3
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.26697579999999993}
#standard deviation: 0.04495152694136208
#island_id: 2
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        
        # Calculate the priority based on the difference between the local energy and the nearest neighbors' spins
        if site_energy > neighbor_energy:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_energy < neighbor_energy:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Calculate the priority based on the site's own spin
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0031674}
#standard deviation: 0.046670895612147836
#island_id: 2
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) - site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-site_energy)
        
        # Added a new term to the priority based on the difference between the site's spin and its nearest neighbors' spins
        site_spin = h[i, j, k]
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if neighbor_spins[d] > site_spin:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin - neighbor_spins[d])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spins[d] < site_spin:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin - neighbor_spins[d])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)

        # Calculate the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) - site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-site_energy)

        # Calculate the priority based on the difference between the local spin and the nearest neighbors' spins
        site_spin = h[i, j, k]
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin - sum(val for val in neighbor_spins))) * len([val for val in interacting_spins if val < site_spin]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-site_spin)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)

        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) - site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-site_energy)

  # Calculate the priority based on the difference between the site's spin and the average of its neighbors' spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)

        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) - site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-site_energy)

  return(priorities)




#score: {'data3D.txt': -0.09636980000000006}
#standard deviation: 0.04871526750373027
#island_id: 0
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum_pos = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] 
             for d in range(6) if J[d,i,j,k]>0)
        interacting_spins_sum_neg = sum(-J[d,i,j,k]*h[(i+(d%3)-1)%N,(j+(d%2-1))%N,(k+d//3)%N] 
             for d in range(6) if J[d,i,j,k]<0)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += interacting_spins_sum_pos 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spins_sum_neg
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]

  # Add a new term based on the local energy
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k]>0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  # Normalize priorities to avoid overflows
  max_priority = np.max(priorities, axis=1).max()
  if max_priority > 0:
    priorities[:, 0] /= max_priority
    priorities[:, 1] /= -max_priority

  return(priorities)




#score: {'data3D.txt': 0.0545886}
#standard deviation: 0.044430195926194155
#island_id: 3
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_center_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        
        for d in range(3):
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins[d]) 
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] += 2
        
        site_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_center_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - site_spin_product - center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28857820000000006}
#standard deviation: 0.04139249261351628
#island_id: 3
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        center_neighbors = [J[d, i, (j + 1) % N, k] for d in [0, 1, 2]] + \
                  [J[d, (i + 1) % N, j, k] for d in [0, 1, 2]] + \
                  [J[d, i, j, (k + 1) % N] for d in [0, 1, 2]]
        neighbor_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - neighbor_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_center_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        center_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_center_neighbors))

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - center_spin_product
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.25246660000000004}
#standard deviation: 0.03985470416952057
#island_id: 3
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        center_site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]

        site_center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        center_site_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,center_site_neighbors))

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - site_center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.241529}
#standard deviation: 0.03988269648607025
#island_id: 3
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        center_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        neighbor_interactions = [J[d, i, (j + 1) % N, k] for d in [0, 1, 2]] + [J[d, (i + 1) % N, j, k] for d in [0, 1, 2]] + [J[d, i, j, (k + 1) % N] for d in [0, 1, 2]]

        site_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        center_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, center_neighbors))
        neighbor_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, neighbor_interactions))

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_spin_product - center_spin_product - neighbor_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.025209799999999997}
#standard deviation: 0.0466400208400468
#island_id: 2
#version_generated: 3
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
        # Added a new term to the priority based on the difference between the spin and the local energy
        spin_energy_diff = h[i, j, k] - total_spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_energy_diff)) * len([val for val in interacting_spins if val < spin_energy_diff]) + spin_energy_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_energy_diff
        
  return(priorities)




#score: {'data3D.txt': -0.14661219999999997}
#standard deviation: 0.0417991278755909
#island_id: 2
#version_generated: 3
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
        # Added a new term to the priority based on the total spin of the neighboring sites
        total_neighbor_spin = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.010224599999999999}
#standard deviation: 0.04763601909101977
#island_id: 1
#version_generated: 3
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[(i // N // N + k) % 6, i % N, (i // N) % N, (i // N // N) % N] 
               for k in range(6)]
    
    total_spin = sum(J[d, i % N, (i // N) % N, (i // N // N) % N] * interacting_spins[d] 
             for d in [(i // N // N + k) % 6 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) + total_spin
      priorities[i][1] = -2 - 2 * total_spin - len([val for val in interacting_spins if val == 0])
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin - len([val for val in interacting_spins if val == 0])
  
  return(priorities)




#score: {'data3D.txt': 0.0003545999999999992}
#standard deviation: 0.046098851816937916
#island_id: 1
#version_generated: 3
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[(i // N // N + k) % 6, (i // N) % N, (i % N) % N, (i // N // N) % N] 
               for k in range(6)]
    
    total_spin = sum(interacting_spins)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 2 * total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0111062}
#standard deviation: 0.04532273029683891
#island_id: 1
#version_generated: 3
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[(i // N // N + k) % 6, (i // N) % N, (i % N) % N, ((i // N // N) + (k-1)) % N] 
               for k in range(6)]
    
    total_spin = sum(J[d, (i // N) % N, (i % N) % N, ((i // N // N) + (d-1)) % N] * interacting_spins[d] 
             for d in [(i // N // N + k) % 6 for k in range(6)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) + total_spin
      priorities[i][1] = -2 - 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins]) + total_spin
      priorities[i][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0545886}
#standard deviation: 0.044430195926194155
#island_id: 3
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_center_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        for d in range(3):
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] += 2

        site_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        center_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_center_neighbors))

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_spin_product - center_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0561418}
#standard deviation: 0.04464826640262755
#island_id: 3
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_center_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        for d in range(3):
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] += 2

        site_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_neighbors))
        center_spin_product = sum(val1 * val2 for val1, val2 in zip(interacting_spins, site_center_neighbors))

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_spin_product - center_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0561418}
#standard deviation: 0.04464826640262755
#island_id: 3
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        center_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        
        for d in range(3):
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(interacting_spins[d]) 
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * abs(interacting_spins[d])
            priorities[i * N * N + j * N + k][1] += 2
        
        site_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,site_neighbors))
        center_spin_product = sum(val1*val2 for val1,val2 in zip(interacting_spins,center_neighbors))
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*len([val for val in interacting_spins if val < 0]) + total_spin - site_spin_product - center_spin_product
        priorities[i*N*N+j*N+k][1] -= 2-2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27887660000000003}
#standard deviation: 0.046523251954694644
#island_id: 2
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0953021999999999}
#standard deviation: 0.04671871482778609
#island_id: 2
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3990010000000001}
#standard deviation: 0.04554041764191453
#island_id: 0
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_neighbor_spin

          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[f, i, j, k] for f in [3, 4, 5]] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][site_nbr] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2 * total_neighbor_spin

  return priorities




#score: {'data3D.txt': -0.4764026}
#standard deviation: 0.0408056755028023
#island_id: 2
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.004811}
#standard deviation: 0.047996701542918546
#island_id: 1
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin_x = [J[0, i % N, i // N % N, i // N // N] 
                for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    interacting_spin_y = [J[1, i % N, i // N % N, i // N // N] 
                for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    interacting_spin_z = [J[2, i % N, i // N % N, i // N // N] 
                for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    
    total_spin_x = sum(interacting_spin_x)
    total_spin_y = sum(interacting_spin_y)
    total_spin_z = sum(interacting_spin_z)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin_x - total_spin_y - total_spin_z
      priorities[i][1] -= 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
    else:
      priorities[i][0] -= -total_spin_x - total_spin_y - total_spin_z
      priorities[i][1] = 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][1] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][0] += 2
  
    else:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][0] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.012415800000000001}
#standard deviation: 0.045392165297108274
#island_id: 1
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
             for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
    if h[i % N][i // N % N][i // N // N] > 0:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][1] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][0] += 2
    
    else:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][0] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][1] += 2
    
    # Add additional logic here to prioritize spins based on site interactions and magnetism
    if h[i % N][i // N % N][i // N // N] > 0:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][1] += -2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][0] += -2
    
    else:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][0] -= 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.0196374}
#standard deviation: 0.0463642155249067
#island_id: 1
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
              for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
    # Add additional logic here to prioritize spins based on site interactions and magnetism
    if h[i % N][i // N % N][i // N // N] > 0:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][1] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][0] += 2
    
    else:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][0] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][1] += 2
    
    # Add priority based on site interactions with neighboring sites
    interacting_spins = [J[(i // N // N + 1) % 3, i % N, i // N % N, i // N // N], 
               J[(i // N // N + 2) % 3, i % N, i // N % N, i // N // N]]
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][1] += np.sign(interacting_spins[0]) + np.sign(interacting_spins[1])
    else:
      priorities[i][0] -= np.sign(interacting_spins[0]) + np.sign(interacting_spins[1])
    
  return(priorities)




#score: {'data3D.txt': 0.026156999999999996}
#standard deviation: 0.04797613522367136
#island_id: 1
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
              for d in [(i // N // N + 2) % 3, (i // N // N + 1) % 3]]
    
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= -total_spin
      priorities[i][1] = 2 - 2 * total_spin
    
    if h[i % N][i // N % N][i // N // N] > 0:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][1] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][0] += 2
    else:
      for d in range(6):
        if J[d, i % N, i // N % N, i // N // N] < 0:
          priorities[i][0] += 2
        elif J[d, i % N, i // N % N, i // N // N] > 0:
          priorities[i][1] += 2
    
    # Add additional logic here to prioritize spins based on site interactions and magnetism
    for d in range(6):
      if abs(J[d, i % N, i // N % N, i // N // N]) > 0.5:
        if h[i % N][i // N % N][i // N // N] > 0:
          priorities[i][1] += 2
        else:
          priorities[i][0] += 2
    
  return(priorities)




#score: {'data3D.txt': -0.0280878}
#standard deviation: 0.04627512778113098
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] 
             for d in [(i // N // N + k) % 6 for k in range(3)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
      
      neighbor_spin = J[3, i % N, site_nbr, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
        
      neighbor_spin = J[4, i % N, site_nbr, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
        
    else:
      priorities[i][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
      
      neighbor_spin = J[3, i % N, site_nbr, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(abs(total_spin)) * 1
        priorities[i][1] -= 1
        
      neighbor_spin = J[4, i % N, site_nbr, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(abs(total_spin)) * 1
        priorities[i][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.026494999999999998}
#standard deviation: 0.04665922818692997
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)]]

    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] for d in [(i // N // N + k) % 6 for k in range(3)])

    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin

      neighbor_spin = J[2, i % N, (i // N) % N, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1

      neighbor_spin = J[2, i % N, (i // N) % N, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1

    else:
      priorities[i][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

      neighbor_spin = J[2, i % N, (i // N) % N, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(abs(total_spin)) * 1
        priorities[i][1] -= 1

      neighbor_spin = J[2, i % N, (i // N) % N, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(abs(total_spin)) * 1
        priorities[i][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.021946600000000004}
#standard deviation: 0.04555150742225771
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] 
             for d in [(i // N // N + k) % 6 for k in range(3)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
      
      neighbor_spin = J[2, i % N, (i // N) % N, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
      
      neighbor_spin = J[2, i % N, (i // N) % N, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
      
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
      
      neighbor_spin = J[2, i % N, (i // N) % N, max(0, i // N // N-1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
      
      neighbor_spin = J[2, i % N, (i // N) % N, min(N-1, i // N // N+1)]
      if neighbor_spin < 0:
        priorities[i][0] -= np.exp(-abs(total_spin)) * 1
        priorities[i][1] -= 1
    
  return(priorities)




#score: {'data3D.txt': -0.0328142}
#standard deviation: 0.046585723975913484
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spins = [J[d, i % N, i // N % N, i // N // N] 
               for d in [(i // N // N + k) % 6 for k in range(3)]]
    
    total_spin = sum(J[d, site_nbr, i // N % N, i // N // N] 
             for d in [(i // N // N + k) % 6 for k in range(3)])
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.541549}
#standard deviation: 0.03961815239255864
#island_id: 3
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin (improved)
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin (improved)
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(3))
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N**2 + j * N + k][1] -= 1 if neighbor_spin < 0 else 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N**2 + j * N + k][1] -= 1 if neighbor_spin < 0 else 1

  return priorities




#score: {'data3D.txt': -0.20334940000000049}
#standard deviation: 0.04955981476599765
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spin_x = J[0, i, j, k] * h[i, j, k]
        interacting_spin_y = J[1, i, j, k] * h[i, j, k]
        interacting_spin_z = J[2, i, j, k] * h[i, j, k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -interacting_spin_x - interacting_spin_y - interacting_spin_z
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * (interacting_spin_x + interacting_spin_y + interacting_spin_z)
        else:
          priorities[i*N*N+j*N+k][0] -= -interacting_spin_x - interacting_spin_y - interacting_spin_z
          priorities[i*N*N+j*N+k][1] = 2 - 2 * (interacting_spin_x + interacting_spin_y + interacting_spin_z)

  return(priorities)




#score: {'data3D.txt': 0.013805799999999998}
#standard deviation: 0.04712888038517359
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.array([np.roll(h, -1, axis=i) for i in range(3)] + 
                 [np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = sum(J[d, i % N, site_nbr, i // N // N] * 
                interacting_spins[d][i % N, site_nbr, i // N // N] for d in range(6))
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] = -interacting_spin + np.exp(-abs(interacting_spin)) * len([val for val in J[range(3), i % N, site_nbr, i // N // N] if val < 0]) + interacting_spin
      priorities[i][1] = 2 - 2 * interacting_spin
    else:
      priorities[i][0] = -interacting_spin - np.exp(-abs(interacting_spin)) * len([val for val in J[range(3), i % N, site_nbr, i // N // N] if val > 0]) + interacting_spin
      priorities[i][1] = -2 + 2 * interacting_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0012569999999999997}
#standard deviation: 0.04700912667769951
#island_id: 1
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = sum(J[d, i % N, site_nbr, i // N // N] * interacting_spins[d][i % N, site_nbr, i // N // N] for d in range(6))
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += -interacting_spin
      priorities[i][1] -= 2 - 2 * interacting_spin
    else:
      priorities[i][0] -= -interacting_spin
      priorities[i][1] = 2 - 2 * interacting_spin
    
    site_neighbors = [J[0, i % N, (i // N) % N, k] for k in range(N)] + \
             [J[1, (i // N) % N, i % N, k] for k in range(N)] + \
             [J[2, i % N, i % N, k] for k in range(N)]
    
    priorities[i][0] += -sum(val * np.sign(val) for val in site_neighbors)
    priorities[i][1] -= 2 - 2 * sum(val for val in site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5634558000000001}
#standard deviation: 0.04059319310377049
#island_id: 0
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 0
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30935540000000006}
#standard deviation: 0.044827020097704465
#island_id: 0
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.13806020000000002}
#standard deviation: 0.04371871013605044
#island_id: 1
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [(d+2)%6 for d in range(3)]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = 2 - 2 * total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin < 0) + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3156914}
#standard deviation: 0.041557939386355526
#island_id: 1
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [(d+2)%6 for d in range(3)]]
        
        total_spin = sum(interacting_spins)
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = 2 - 2 * total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.24710500000000013}
#standard deviation: 0.043522835098371064
#island_id: 3
#version_generated: 3
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0: priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1; priorities[i * N * N + j * N + k][1] -= 1
          if neighbor_spin > 0: priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1; priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0: priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1; priorities[i * N * N + j * N + k][1] -= 1
          if neighbor_spin > 0: priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1; priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.36236820000000003}
#standard deviation: 0.041515258746152604
#island_id: 3
#version_generated: 3
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N**2 + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N**2 + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N**2 + j * N + k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N**2 + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N**2 + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N**2 + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N**2 + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N**2 + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N**2 + j * N + k][1] += 2
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N**2 + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N**2 + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.1044718}
#standard deviation: 0.04448858645495494
#island_id: 3
#version_generated: 3
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N**2 + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N**2 + j * N + k][0] += np.exp(h[i, j, k])
        priorities[i * N**2 + j * N + k][1] -= h[i, j, k]
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N**2 + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N**2 + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin (improved)
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * 2
            priorities[i * N**2 + j * N + k][1] -= 2
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N**2 + j * N + k][0] += np.exp(-np.abs(total_spin)) * 2
            priorities[i * N**2 + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.341605}
#standard deviation: 0.04448141291595851
#island_id: 1
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbrs = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        sites = [(site_nbr, j, k) for site_nbr in [i, site_nbr] if site_nbr != i]
        
        for site in sites:
          if h[site[0]][site[1]][site[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, site[0], site[1], site[2]] for d in [0, 1, 2]] if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, site[0], site[1], site[2]] for d in [0, 1, 2]] if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4489414000000001}
#standard deviation: 0.04182378804030071
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.30935540000000006}
#standard deviation: 0.044827020097704465
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.30935540000000006}
#standard deviation: 0.044827020097704465
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.49265500000000007}
#standard deviation: 0.04466221910071196
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(local_energy)
        priorities[i * N * N + j * N + k][1] -= local_energy
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1062706}
#standard deviation: 0.044450110636982676
#island_id: 2
#version_generated: 3
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin)
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
        # Added a new term to the priority based on the total spin of the neighboring sites
        total_neighbor_spin = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin)
        
        # Added a new term to the priority based on the total spin of the neighboring sites
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.5465845999999999}
#standard deviation: 0.04076274724353107
#island_id: 3
#version_generated: 3
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.015918200000000157}
#standard deviation: 0.04941220890387315
#island_id: 1
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2473394000000001}
#standard deviation: 0.043555970975745685
#island_id: 1
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        total_spin = 0
        
        # Add the spins of the nearest neighbors
        for d in [0, 1, 2]:
          if d == 0:
            interacting_spins.append(J[0, i, j, k])
            total_spin += J[0, i, j, k]
          elif d == 1:
            interacting_spins.append(J[1, i, (j+1)%N, k])
            total_spin += J[1, i, (j+1)%N, k]
          elif d == 2:
            interacting_spins.append(J[2, i, j, (k+1)%N])
            total_spin += J[2, i, j, (k+1)%N]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.025603400000000005}
#standard deviation: 0.048844333432241656
#island_id: 1
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][1] += 1
            elif J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        site_opposite_neighbors = [val for val in site_neighbors if val > 0]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len(site_opposite_neighbors)
        priorities[i*N*N+j*N+k][1] -= len(site_opposite_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.021561399999999998}
#standard deviation: 0.04508777295498193
#island_id: 1
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[(i // N % 2), i % N, (i // N) % N, (i // N // N)].item()
               for _ in range(6)]
    total_spin = sum(interacting_spins)
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  return priorities




#score: {'data3D.txt': -0.0368994}
#standard deviation: 0.04711911034431784
#island_id: 1
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  
  for i in range(N**3):
    site_nbr = (i // N % N + ((i // N // N - 1) % 2 - 1)) % N
    interacting_spin = [J[d, i % N, i // N % N, i // N // N] 
        for d in [(i // N // N + 2) % 6]]
    total_spin = sum(interacting_spin)
    
    if h[i % N][i // N % N][i // N // N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spin if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2722282000000003}
#standard deviation: 0.043754471825860265
#island_id: 3
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.5465845999999999}
#standard deviation: 0.04076274724353107
#island_id: 3
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5465845999999999}
#standard deviation: 0.04076274724353107
#island_id: 3
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5007898000000002}
#standard deviation: 0.044983840831569734
#island_id: 3
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0033046000000000004}
#standard deviation: 0.04692481879389626
#island_id: 3
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0953021999999999}
#standard deviation: 0.04671871482778609
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.23853939999999996}
#standard deviation: 0.04592094301775607
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)

        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]

        # Calculate the priority based on the interactions with next nearest neighbors
        next_neighbors = [J[0, i, (j + 1) % N, (k + 1) % N], J[1, (i + 1) % N, j, (k + 1) % N], J[2, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in next_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.33884980000000003}
#standard deviation: 0.04729784307936252
#island_id: 2
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.1103686}
#standard deviation: 0.04666355423711314
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the difference between the local energy and the nearest neighbors' spins
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        priority_diff = np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        
        # Calculate the priority based on the difference between the local spin and the nearest neighbors' spins
        priority_spin = np.exp(-abs(total_spin - total_neighbor_spin)) * len([val for val in interacting_spins if val < total_spin]) + total_spin
        
        priorities[i * N * N + j * N + k][0] += priority_diff + priority_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the difference between local energy and neighbor energies
        local_energy_diff = h[i, j, k] - sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) - sum(J[d, (i + 1) % N, j, k] for d in [2])
        
        # Calculate the difference between local spin and neighbor spins
        local_spin_diff = total_spin - total_neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(local_energy_diff)) * len([val for val in interacting_spins if val < h[i, j, k]]) + h[i, j, k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(local_spin_diff)) * len([val for val in interacting_spins if val < total_spin]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if all(val < 0 for val in interacting_spins):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif all(val > 0 for val in interacting_spins):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif total_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.058559799999999995}
#standard deviation: 0.047012907418707894
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])
        
        # Added a new term to the priority based on the difference between the local energy and the nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_energy - neighbor_energy)) * len([val for val in interacting_spins if val < site_energy]) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_energy
        
        # Added a new term to the priority based on the difference between the local spin and the nearest neighbors' spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin - total_neighbor_spin)) * len([val for val in interacting_spins if val < total_spin]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.16152459999999996}
#standard deviation: 0.057138634520261335
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        x, y, z = i, j, k
        while x < N and y < N:
          for k in range(z+1):
            if J[2, x, y, k] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif J[2, x, y, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          x += 1
          if x == N:
            break
          y += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5178886}
#standard deviation: 0.04292070491080034
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2225086}
#standard deviation: 0.07102056044583147
#island_id: 3
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        x, y, z = i, j, k
        while x < N and y < N:
          for l in range(6):
            if J[l, x, y, z] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif J[l, x, y, z] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          x += 1
          if x == N:
            break
          y += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0921898}
#standard deviation: 0.06733052038979054
#island_id: 3
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        x, y, z = i, j, k
        while x < N and y < N:
          for k in range(z+1):
            if J[2, x, y, k] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif J[2, x, y, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          x += 1
          if x == N:
            break
          y += 1
        
        for d in [0, 1, 2]:
          for l in range(N):
            neighbor_spin = J[d, i, l, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3669334000000002}
#standard deviation: 0.04944818949607761
#island_id: 1
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.530275}
#standard deviation: 0.038085669942906346
#island_id: 1
#version_generated: 2
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with same spin in different directions
        if i > 0:
          neighbor_spin = J[0, i - 1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[0, i + 1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if j > 0:
          neighbor_spin = J[1, i, j - 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if j < N - 1:
          neighbor_spin = J[1, i, j + 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0029906000000000004}
#standard deviation: 0.0470125850346479
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        if i > 0:
          neighbor_spin = J[0, i - 1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[0, i + 1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if j > 0:
          neighbor_spin = J[1, i, j - 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if j < N - 1:
          neighbor_spin = J[1, i, j + 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.49937739999999997}
#standard deviation: 0.038964112837840924
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        if i > 0:
          neighbor_spin = J[0, i - 1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[0, i + 1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if j > 0:
          neighbor_spin = J[1, i, j - 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if j < N - 1:
          neighbor_spin = J[1, i, j + 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.4081882000000003}
#standard deviation: 0.04825598803008804
#island_id: 1
#version_generated: 3
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3669334000000002}
#standard deviation: 0.04944818949607761
#island_id: 1
#version_generated: 3
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1181662}
#standard deviation: 0.0478303370002763
#island_id: 1
#version_generated: 3
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * site_nbr - site_opposite - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3669334000000002}
#standard deviation: 0.04944818949607761
#island_id: 1
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.30935540000000006}
#standard deviation: 0.044827020097704465
#island_id: 0
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.380241}
#standard deviation: 0.043929690631735616
#island_id: 0
#version_generated: 3
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.35615459999999993}
#standard deviation: 0.04477231531694559
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) - np.exp(-np.sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(total_spin) - np.exp(np.sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43919220000000003}
#standard deviation: 0.04547222865838005
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(total_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4896490000000001}
#standard deviation: 0.04204478325547654
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.380241}
#standard deviation: 0.043929690631735616
#island_id: 0
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.1553965999999999}
#standard deviation: 0.048575862611383455
#island_id: 0
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.0025830000000000007}
#standard deviation: 0.0440719655903841
#island_id: 0
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - np.exp(total_spin) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (-np.exp(total_spin) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.4489414000000001}
#standard deviation: 0.04182378804030071
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4489414000000001}
#standard deviation: 0.04182378804030071
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4489414000000001}
#standard deviation: 0.04182378804030071
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4489414000000001}
#standard deviation: 0.04182378804030071
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0031582000000000003}
#standard deviation: 0.04695991793817361
#island_id: 2
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5091918000000001}
#standard deviation: 0.0430959920730455
#island_id: 1
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.40821420000000025}
#standard deviation: 0.047696921476757796
#island_id: 1
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins += [J[d, i, (j+1)%N, k] for d in [1]]
        interacting_spins += [J[d, i, j, (k+1)%N] for d in [2]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.430971}
#standard deviation: 0.04289325167202878
#island_id: 1
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        spin_0 = np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        spin_1 = 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += spin_0 * np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] += spin_1 * np.exp(-h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.27887660000000003}
#standard deviation: 0.046523251954694644
#island_id: 2
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0792526}
#standard deviation: 0.04393562829003359
#island_id: 2
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        local_energy = h[i][j][k] + total_spin
        neighbor_energy = total_neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(local_energy)) * len([val for val in interacting_spins if val < 0]) + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * local_energy
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_energy)) * len([val for val in site_neighbors if val < 0]) + neighbor_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.32413579999999986}
#standard deviation: 0.046266889222855684
#island_id: 2
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.10711019999999992}
#standard deviation: 0.04454917705143384
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2533234}
#standard deviation: 0.04423256099797976
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        
        # Calculate the priority based on the magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0798878}
#standard deviation: 0.05120738082698627
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the spin interaction and local energy
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10258900000000003}
#standard deviation: 0.11189813116848747
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)

        # Calculate the priority based on the spin interaction and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]

  # Add a new term based on the site's own spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (interacting_spin_sum + neighbor_spin_sum) + total_spin - h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.044145000000000004}
#standard deviation: 0.04422302448951225
#island_id: 2
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.34791140000000004}
#standard deviation: 0.05238766219292478
#island_id: 0
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        priorities[i * N * N + j * N + k][0] = np.sum(J[:, i, j, k]) - total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.45493780000000006}
#standard deviation: 0.043777707696497775
#island_id: 0
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4489414000000001}
#standard deviation: 0.04182378804030071
#island_id: 0
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2572622}
#standard deviation: 0.04414390027127191
#island_id: 0
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5091918000000001}
#standard deviation: 0.0430959920730455
#island_id: 1
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5091918000000001}
#standard deviation: 0.0430959920730455
#island_id: 1
#version_generated: 3
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * site_nbr - site_opposite + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.435905}
#standard deviation: 0.04098628520615158
#island_id: 2
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.457281}
#standard deviation: 0.039236347931478024
#island_id: 2
#version_generated: 3
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the total spin interaction
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority for assigning spins to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the local energy and nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the interaction between neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.18483859999999996}
#standard deviation: 0.04564585665797062
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.27380019999999994}
#standard deviation: 0.04702557984714278
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.380241}
#standard deviation: 0.043929690631735616
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': 0.0007350000000000001}
#standard deviation: 0.04339301573986302
#island_id: 0
#version_generated: 3
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin
        priorities[i * N * N + j * N + k][1] -= sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        spin_difference = abs(total_spin - 1) + abs(neighbor_spin_sum - 1)
        priorities[i * N * N + j * N + k][0] += np.exp(-spin_difference)
        priorities[i * N * N + j * N + k][1] -= spin_difference
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.32413579999999986}
#standard deviation: 0.046266889222855684
#island_id: 2
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5179238}
#standard deviation: 0.04255380868453493
#island_id: 2
#version_generated: 3
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        probabilities = np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4081882000000003}
#standard deviation: 0.04825598803008804
#island_id: 1
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5179238}
#standard deviation: 0.04255380868453493
#island_id: 2
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        probabilities = np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.5179238}
#standard deviation: 0.04255380868453493
#island_id: 2
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        probabilities = np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.5179238}
#standard deviation: 0.04255380868453493
#island_id: 2
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        probabilities = np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-h[i][j][k])
  return(priorities)




#score: {'data3D.txt': -0.4542430000000002}
#standard deviation: 0.04095115274323789
#island_id: 2
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        probabilities = np.exp(-abs(total_spin)) * (interacting_spin_sum + neighbor_spin_sum) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k]) + probabilities
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-h[i][j][k]) - probabilities
        
  return(priorities)




#score: {'data3D.txt': -0.0057914}
#standard deviation: 0.04771915303146107
#island_id: 3
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  n = N**3
  priorities = np.zeros((n, 2))

  for i in range(n):
    interacting_spins = [J[d, (i//N)%N, (i%N//N), i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)

    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)

    priorities[i][0] += np.exp(h[(i // N) % N][(i % N) // N][i % N])
    priorities[i][1] -= h[(i // N) % N][(i % N) // N][i % N]

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 3
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0031938000000000005}
#standard deviation: 0.04695123855192747
#island_id: 3
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        for d in [0, 1, 2]:
          site_neighbors[d] = J[d, i, j, (k + 1) % N]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        return(priorities)




#score: {'data3D.txt': -0.4346006}
#standard deviation: 0.042180805583108535
#island_id: 3
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.40821420000000025}
#standard deviation: 0.047696921476757796
#island_id: 1
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins += [J[d, i, (j+1)%N, k] for d in [1]]
        interacting_spins += [J[d, i, j, (k+1)%N] for d in [2]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2688234000000002}
#standard deviation: 0.048862282104297994
#island_id: 1
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = []
        if i > 0:
          interacting_spins.append(J[0, (i-1)%N, j, k])
        else:
          interacting_spins.append(0)
        if i < N - 1:
          interacting_spins.append(J[0, (i+1)%N, j, k])
        else:
          interacting_spins.append(0)
        
        if j > 0:
          interacting_spins.append(J[1, i, (j-1)%N, k])
        else:
          interacting_spins.append(0)
        if j < N - 1:
          interacting_spins.append(J[1, i, (j+1)%N, k])
        else:
          interacting_spins.append(0)
        
        if k > 0:
          interacting_spins.append(J[2, i, j, (k-1)%N])
        else:
          interacting_spins.append(0)
        if k < N - 1:
          interacting_spins.append(J[2, i, j, (k+1)%N])
        else:
          interacting_spins.append(0)
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2954990000000002}
#standard deviation: 0.04967559399745513
#island_id: 1
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i+1)%N, (j+1)%N, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j+1)%N, (k+1)%N])
          else:
            interacting_spins.append(J[d, (i+1)%N, j, (k+1)%N])
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3669334000000002}
#standard deviation: 0.04944818949607761
#island_id: 1
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * np.abs(site_nbr) - np.abs(site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42273059999999996}
#standard deviation: 0.045552697654913925
#island_id: 1
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)

        site_energy = np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][0] += site_energy
        
        site_magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= site_magnetism
        else:
          priorities[i * N * N + j * N + k][1] += site_magnetism

  return(priorities)




#score: {'data3D.txt': -0.40568940000000014}
#standard deviation: 0.04615290378340241
#island_id: 1
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in range(6):
          if d < 3:
            left_nbr = J[d, i-1 if i == 0 else i, j, k]
          elif d < 5:
            right_nbr = J[d, (i+1)%N if i == N-1 else i, j, k]
            
          site_neighbors = [left_nbr] + [right_nbr] if d >= 3 and d <= 4 else []
          site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
          site_opposite_sum = sum(val for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        spin_difference = abs(total_spin - 1) + abs(neighbor_spin_sum - 1)
        priorities[i * N * N + j * N + k][0] += np.exp(-spin_difference) * (interacting_spin_sum + neighbor_spin_sum) / 2
        priorities[i * N * N + j * N + k][1] -= spin_difference
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_energy = h[i, j, k]
        neighbor_energy = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [2])

        total_spin = site_energy - neighbor_energy
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0)

        spin_difference = abs(total_spin) + abs(neighbor_spin_sum)
        priorities[i * N * N + j * N + k][0] += np.exp(-spin_difference)
        priorities[i * N * N + j * N + k][1] -= spin_difference

  return(priorities)




#score: {'data3D.txt': 0.22378220000000015}
#standard deviation: 0.04596036774395958
#island_id: 2
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        neighbor_energy = sum(J[d, (i + 1) % N, j, k] for d in [0, 3]) + sum(J[d, i, (j + 1) % N, k] for d in [1, 4]) + sum(J[d, i, j, (k + 1) % N] for d in [2, 5])
        priorities[i * N * N + j * N + k][0] += -total_spin * np.exp(-abs(total_spin)) - abs(neighbor_energy)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
        neighbor_spin_sum = sum(val for val in site_neighbors if val < 0)
        
        spin_difference = abs(total_spin - 1) + abs(neighbor_spin_sum - 1)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-spin_difference)
        priorities[i * N * N + j * N + k][1] -= spin_difference
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.40821420000000025}
#standard deviation: 0.047696921476757796
#island_id: 1
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins += [J[d, i, (j+1)%N, k] for d in [1]]
        interacting_spins += [J[d, i, j, (k+1)%N] for d in [2]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.40998980000000035}
#standard deviation: 0.047701896146379756
#island_id: 1
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0]]
        interacting_spins += [J[d, i, (j+1)%N, k] for d in [1]]
        interacting_spins += [J[d, i, j, (k+1)%N] for d in [2]]
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18277900000000016}
#standard deviation: 0.04996559615375363
#island_id: 1
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+1)%N, j, k])
          interacting_spins.append(J[d, i, (j+1)%N, k])
          interacting_spins.append(J[d, i, j, (k+1)%N])
          
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_opposite = sum(val for val in interacting_spins if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_opposite) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.1159994}
#standard deviation: 0.04906742748137506
#island_id: 0
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1553965999999999}
#standard deviation: 0.048575862611383455
#island_id: 0
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.03040460000000001}
#standard deviation: 0.05188190222842643
#island_id: 0
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin) - np.exp(-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin) - np.exp(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.1381934}
#standard deviation: 0.04570191064321054
#island_id: 3
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += -sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        elif h[i][j][k] < 0:
          priorities[i*N*N + j*N + k][0] = sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

  return(priorities)




#score: {'data3D.txt': 0.004440999999999999}
#standard deviation: 0.04756331736748395
#island_id: 3
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, (i%N//N), i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]
    site_nbr = (i // N) % N

    total_spin = sum(interacting_spins)
    
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

      site_neighbors_sum = sum(val for val in site_neighbors)
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
      priorities[i][1] -= 2 - 2 * total_spin

    elif h[(i // N) % N][(i % N) // N][i % N] < 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

      site_neighbors_sum = sum(val for val in site_neighbors)
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_sum
      priorities[i][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        site_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]] + [J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2 * total_spin
        
        elif h[i][j][k] < 0:
          priorities[i*N*N+k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+k][1] -= h[i][j][k]
        
        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i*N*N+k][0] += -neighbor
            priorities[i*N*N+k][1] -= 2 * neighbor
        
  return(priorities)




#score: {'data3D.txt': -0.0005442000000000005}
#standard deviation: 0.047117162545722124
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  n = N**3
  priorities = np.zeros((n, 2))

  for i in range(n):
    interacting_spins = [J[d, (i//N)%N, (i%N//N), i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N

    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] = -sum(interacting_spins)
      priorities[i][1] = sum(interacting_spins)

      for j in range(3):
        if site_neighbors[j] < 0:
          priorities[i][0] -= J[j, (i//N)%N, (i%N//N), i%N]
        else:
          priorities[i][1] += J[j, (i//N)%N, (i%N//N), i%N]

    elif h[(i // N) % N][(i % N) // N][i % N] < 0:
      priorities[i][0] = sum(interacting_spins)
      priorities[i][1] = -sum(interacting_spins)

      for j in range(3):
        if site_neighbors[j] > 0:
          priorities[i][0] += J[j, (i//N)%N, (i%N//N), i%N]
        else:
          priorities[i][1] -= J[j, (i//N)%N, (i%N//N), i%N]

  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5808926}
#standard deviation: 0.03943609748999006
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36227980000000004}
#standard deviation: 0.042894017204733806
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.sum(np.array(site_neighbors) * np.array([1 if val < 0 else -1 for val in site_neighbors])) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36227980000000004}
#standard deviation: 0.042894017204733806
#island_id: 1
#version_generated: 3
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.sum(np.array(site_neighbors) * np.array([1 if val < 0 else -1 for val in site_neighbors])) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5411282}
#standard deviation: 0.04124450708591388
#island_id: 2
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5634558000000001}
#standard deviation: 0.04059319310377049
#island_id: 2
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5620358000000001}
#standard deviation: 0.03907624903134896
#island_id: 1
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.027006200000000043}
#standard deviation: 0.04541747506808366
#island_id: 0
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  site_interactions = np.sum([J[d] @ h for d in range(6)], axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d][i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += total_spin + site_interactions[i, j, k]
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (h[i, j, k] > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2572622}
#standard deviation: 0.04414390027127191
#island_id: 0
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.30402819999999997}
#standard deviation: 0.05014549037311332
#island_id: 0
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(-val for val in [J[d, i, j, k] for d in range(6)]) - sum(val for val in site_neighbors) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in range(6))
        else:
          priorities[i * N * N + j * N + k][0] -= sum(-val for val in [J[d, i, j, k] for d in range(6)]) - sum(val for val in site_neighbors) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in range(6))
        
  return(priorities)




#score: {'data3D.txt': -0.16803980000000002}
#standard deviation: 0.04292187293164174
#island_id: 2
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.099673}
#standard deviation: 0.05054942839439434
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.0952762}
#standard deviation: 0.041055218347489035
#island_id: 0
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * sum(J[d, site_nbr, l, k] for l in range(N))
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.06197779999999999}
#standard deviation: 0.050803553686331826
#island_id: 0
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5411282}
#standard deviation: 0.04124450708591388
#island_id: 2
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5310809999999999}
#standard deviation: 0.04069244302078704
#island_id: 2
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4861418}
#standard deviation: 0.040835686510208205
#island_id: 2
#version_generated: 3
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4768014}
#standard deviation: 0.04302058435260962
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [h[i][j][k]] if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.457279}
#standard deviation: 0.043408802321649
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1578806000000003}
#standard deviation: 0.04694924859505209
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr_spin = sum(J[d, i, site_nbr, k] for d in [0, 1, 2])
        if site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.10559540000000021}
#standard deviation: 0.05260540142266762
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        for d in [0, 1]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4663138}
#standard deviation: 0.04307242887927265
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4890066000000001}
#standard deviation: 0.042225633878486664
#island_id: 2
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2572622}
#standard deviation: 0.04414390027127191
#island_id: 0
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.3696586000000001}
#standard deviation: 0.045031394005071605
#island_id: 0
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) - len([val for val in J[0, :, j, k] if val < 0]) - len([val for val in J[1, i, :, k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k]) - len([val for val in J[0, :, j, k] if val > 0]) - len([val for val in J[1, i, :, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) - len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0813518}
#standard deviation: 0.04973254182886694
#island_id: 0
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k]) + sum([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2572622}
#standard deviation: 0.04414390027127191
#island_id: 0
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + np.sum(J[:, i, j, k]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += total_spin + np.sum(J[:, i, j, k]) + len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0057202}
#standard deviation: 0.04709742489733383
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]
    site_magnetism = h[(i // N) % N][(i % N) // N][i % N]
    
    if site_magnetism > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)

  return(priorities)




#score: {'data3D.txt': -0.018007000000000002}
#standard deviation: 0.046450242528968566
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  n = N**3
  priorities = np.zeros((n, 2))

  for i in range(n):
    interacting_spins = [J[d, (i//N)%N, (i%N//N), i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]
    
    total_spin = sum(interacting_spins) + site_neighbors[0] + site_neighbors[1] + site_neighbors[2]
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    else:
      priorities[i][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4880898000000001}
#standard deviation: 0.04392888862650637
#island_id: 3
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i // N) % N
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4880898000000001}
#standard deviation: 0.04392888862650637
#island_id: 3
#version_generated: 3
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i // N) % N
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4741154}
#standard deviation: 0.042984976943578786
#island_id: 2
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4887958000000001}
#standard deviation: 0.043099404431615994
#island_id: 2
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-total_spin) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.5434834000000001}
#standard deviation: 0.040891219160597306
#island_id: 1
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins += site_neighbors

        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for spin in interacting_spins if spin < 0)
          priorities[i * N * N + j * N + k][1] = -sum(1 for spin in interacting_spins if spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for spin in interacting_spins if spin > 0)
          priorities[i * N * N + j * N + k][1] = -sum(1 for spin in interacting_spins if spin < 0)

  return priorities




#score: {'data3D.txt': 0.064675}
#standard deviation: 0.04651759769162633
#island_id: 1
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[0:i+3, i, j, k] if val > 0])) + 1
          priorities[i * N * N + j * N + k][1] -= (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[0:i+3, i, j, k] if val > 0])) + 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[0:i+3, i, j, k] if val > 0])) - 1
          priorities[i * N * N + j * N + k][1] += (len([val for val in J[0:i+3, i, j, k] if val < 0]) - len([val for val in J[0:i+3, i, j, k] if val > 0])) - 1
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) + 2 * len([val for val in interacting_spins if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in interacting_spins if val > 0]) - 2 * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) + 2 * len([val for val in interacting_spins if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])

  return priorities




#score: {'data3D.txt': -0.2828250000000002}
#standard deviation: 0.04601496772790348
#island_id: 1
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.17437139999999998}
#standard deviation: 0.04490780892049846
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += -sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        elif h[i][j][k] < 0:
          priorities[i*N*N + j*N + k][0] = sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        else:
          priorities[i*N*N + j*N + k][0] = -sum(interacting_spins)
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += -sum(site_neighbors)
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.1381934}
#standard deviation: 0.04570191064321054
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += -sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        elif h[i][j][k] < 0:
          priorities[i*N*N + j*N + k][0] = sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.1381934}
#standard deviation: 0.04570191064321054
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += -sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        elif h[i][j][k] < 0:
          priorities[i*N*N + j*N + k][0] = sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.0385598}
#standard deviation: 0.047529989101197996
#island_id: 3
#version_generated: 3
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += -sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        elif h[i][j][k] < 0:
          priorities[i*N*N + j*N + k][0] = sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(interacting_spins)

          priorities[i*N*N + j*N + k][0] += sum(site_neighbors) + np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(site_neighbors)

        # Add a term that takes into account the magnetization
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] = 0

  return(priorities)




#score: {'data3D.txt': 0.1115794}
#standard deviation: 0.04642185881284807
#island_id: 2
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]) - len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]))
          priorities[i * N * N + j * N + k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4861418}
#standard deviation: 0.040835686510208205
#island_id: 2
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4709582}
#standard deviation: 0.03958362758464666
#island_id: 2
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.000805400000000001}
#standard deviation: 0.04591853406675783
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i,j,k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin
        priorities[i * N * N + j * N + k][1] -= sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [3, 4, 5]:
          site_neighbors += [J[d, i, (j + 1) % N, k], J[d, (i + 1) % N, j, k], J[d, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += sum(-val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(val for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.000805400000000001}
#standard deviation: 0.04591853406675783
#island_id: 0
#version_generated: 3
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = total_spin
        priorities[i * N * N + j * N + k][1] -= sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0056334}
#standard deviation: 0.04780987141208393
#island_id: 3
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  n = N**3
  priorities = np.zeros((n, 2))

  for i in range(n):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)

    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)

    priorities[i][0] += h[(i // N) % N][(i % N) // N][i % N]
    priorities[i][1] -= h[(i // N) % N][(i % N) // N][i % N]

  return(priorities)




#score: {'data3D.txt': -0.0057914}
#standard deviation: 0.04771915303146107
#island_id: 3
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]
    
    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
      
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)
    
    priorities[i][0] += np.exp(h[(i // N) % N][(i % N) // N][i % N])
    priorities[i][1] -= h[(i // N) % N][(i % N) // N][i % N]
  
  return(priorities)




#score: {'data3D.txt': -0.005489399999999999}
#standard deviation: 0.046450905347904685
#island_id: 3
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  n = N**3
  priorities = np.zeros((n, 2))

  for i in range(n):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N))%N, i%N], J[1, ((i//N))%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins) + h[(i // N) % N][(i % N) // N][i % N]
    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins) - h[(i // N) % N][(i % N) // N][i % N]

  return(priorities)




#score: {'data3D.txt': -0.1066126}
#standard deviation: 0.045220252556127986
#island_id: 2
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1298166}
#standard deviation: 0.045591135151913036
#island_id: 2
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.36871860000000006}
#standard deviation: 0.043627784427357756
#island_id: 2
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[0, (i-1)%N, j, k], J[1, i, (j-1)%N, k], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34201339999999975}
#standard deviation: 0.04434204438724041
#island_id: 2
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -3
          priorities[i * N * N + j * N + k][1] = 2
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0056334}
#standard deviation: 0.04780987141208393
#island_id: 3
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)

    else:
      priorities[i][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
      priorities[i][1] = -2 + 2 * sum(interacting_spins)

    # Add a term that takes into account the magnetization
    priorities[i][0] += h[(i // N) % N][(i % N) // N][i % N]
    priorities[i][1] -= h[(i // N) % N][(i % N) // N][i % N]

  return(priorities)




#score: {'data3D.txt': -0.0057914}
#standard deviation: 0.04771915303146107
#island_id: 3
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += np.sum(interacting_spins)
      priorities[i][1] -= 2 - 2 * np.sum(interacting_spins)

      priorities[i][0] += np.exp(h[(i // N) % N][(i % N) // N][i % N])
    else:
      priorities[i][0] -= np.sum(interacting_spins)
      priorities[i][1] = -2 + 2 * np.sum(interacting_spins)

      priorities[i][0] -= np.exp(h[(i // N) % N][(i % N) // N][i % N])

  return(priorities)




#score: {'data3D.txt': -0.0056334}
#standard deviation: 0.04780987141208393
#island_id: 3
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]
    
    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] += sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
      priorities[i][1] -= 2 - 2 * sum(interacting_spins)
      
    else:
      priorities[i][0] = -sum(interacting_spins) - np.exp(abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
      priorities[i][1] = -2 + 2 * sum(interacting_spins)
    
    priorities[i][0] += h[(i // N) % N][(i % N) // N][i % N]
    priorities[i][1] -= h[(i // N) % N][(i % N) // N][i % N]
  
  return(priorities)




#score: {'data3D.txt': -0.0031346000000000004}
#standard deviation: 0.04764530955760493
#island_id: 3
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d, (i//N)%N, ((i%N)//N)%N, i%N] for d in [0, 1, 2]]
    site_neighbors = [J[0, (i//N)%N, ((i%N)//N)%N, i%N], J[1, ((i//N)%N)%N, (i//N)%N, i%N], J[2, (i//N)%N, (i//N)%N, ((i%N))%N]]

    site_nbr = (i // N) % N
    if h[(i // N) % N][(i % N) // N][i % N] > 0:
      priorities[i][0] = -sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(site_neighbors)
      priorities[i][1] = -2 + 2 * (sum(interacting_spins) + sum(site_neighbors))

    elif h[(i // N) % N][(i % N) // N][i % N] < 0:
      priorities[i][0] = sum(interacting_spins) + np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(site_neighbors)
      priorities[i][1] = -2 + 2 * (sum(interacting_spins) - sum(site_neighbors))

    # Add a term that takes into account the magnetization
    priorities[i][0] += h[(i // N) % N][(i % N) // N][i % N]
    priorities[i][1] = 0

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return priorities




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 1
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4 - J[0, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 4 - J[0, i, j, k]
          priorities[i * N * N + j * N + k][1] += 3
        
  return priorities




#score: {'data3D.txt': 0.03801939999999999}
#standard deviation: 0.049445024660121274
#island_id: 0
#version_generated: 3
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] + interacting_spins[d, i, j, k]) for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.06197779999999999}
#standard deviation: 0.050803553686331826
#island_id: 0
#version_generated: 3
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.06197779999999999}
#standard deviation: 0.050803553686331826
#island_id: 0
#version_generated: 3
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.23822579999999988}
#standard deviation: 0.045685125964147255
#island_id: 0
#version_generated: 3
#generate time22:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (2*h[i][j][k] - 1) for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5634558000000001}
#standard deviation: 0.04059319310377049
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.535497}
#standard deviation: 0.03802907191873081
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
      
  return(priorities)




#score: {'data3D.txt': -0.5411282}
#standard deviation: 0.04124450708591388
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5634558000000001}
#standard deviation: 0.04059319310377049
#island_id: 3
#version_generated: 2
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4663138}
#standard deviation: 0.04307242887927265
#island_id: 2
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0004934000000000004}
#standard deviation: 0.047258658851473984
#island_id: 2
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d,(i//N)%N,(i%N)//N,i%N] * interacting_spins[d,(i//N)%N,(i%N)//N,i%N] for d in range(6))
    
    priorities[i][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[0,(i//N)%N,(i%N)//N,i%N], J[1,(i//N)%N,(i%N)//N,i%N], J[2,(i//N)%N,(i%N)//N,i%N]] if val < 0]) + total_spin
    priorities[i][1] -= 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.47128060000000005}
#standard deviation: 0.04202645671050559
#island_id: 2
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.16829780000000003}
#standard deviation: 0.04524871970741272
#island_id: 2
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if i > 0: site_neighbors.append(J[0, i-1, j, k]) 
        if i < N-1: site_neighbors.append(J[0, i+1, j, k]) 
        if j > 0: site_neighbors.append(J[1, i, j-1, k]) 
        if j < N-1: site_neighbors.append(J[1, i, j+1, k]) 
        if k > 0: site_neighbors.append(J[2, i, j, k-1]) 
        if k < N-1: site_neighbors.append(J[2, i, j, k+1]) 

        site_nbr_spin = sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) 
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2415242000000004}
#standard deviation: 0.04760965421382516
#island_id: 1
#version_generated: 3
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(site_nbrs) * np.array([1 if val < 0 else -1 for val in site_nbrs])) + len([val for val in site_nbrs if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= (len([val for val in site_nbrs if val < 0]) - len([val for val in site_nbrs if val > 0])) 
        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.array(site_nbrs) * np.array([1 if val < 0 else -1 for val in site_nbrs])) - len([val for val in site_nbrs if val < 0]) 
          priorities[i * N * N + j * N + k][1] += (len([val for val in site_nbrs if val < 0]) - len([val for val in site_nbrs if val > 0])) 
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time22:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for s in interacting_spins if s < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for s in site_neighbors if s < 0) + sum(1 for s in interacting_spins if s > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for s in interacting_spins if s > 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for s in site_neighbors if s > 0) + sum(1 for s in interacting_spins if s < 0)
        
  return priorities




#score: {'data3D.txt': -0.535497}
#standard deviation: 0.03802907191873081
#island_id: 3
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2), dtype=float)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.535497}
#standard deviation: 0.03802907191873081
#island_id: 3
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.535497}
#standard deviation: 0.03802907191873081
#island_id: 3
#version_generated: 3
#generate time22:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2), dtype=float)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
        for direction in [(i+1)%N, i-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, direction, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(j+1)%N, j-1]:
          if 0 <= direction < N:
            neighbor_spin = J[1, i, direction, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        for direction in [(k+1)%N, k-1]:
          if 0 <= direction < N:
            neighbor_spin = J[2, i, j, direction]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.5248342}
#standard deviation: 0.0428278235538534
#island_id: 1
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5248342}
#standard deviation: 0.0428278235538534
#island_id: 1
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5411282}
#standard deviation: 0.04124450708591388
#island_id: 3
#version_generated: 3
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4286814}
#standard deviation: 0.04541643022123162
#island_id: 3
#version_generated: 3
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -sum(val for val in [total_spin] + site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4717206000000001}
#standard deviation: 0.043542468184980046
#island_id: 3
#version_generated: 3
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.06630500000000034}
#standard deviation: 0.0483470294330479
#island_id: 3
#version_generated: 3
#generate time22:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += J[d, i, j, k]*interacting_spins[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2*J[d, i, j, k]*interacting_spins[d, i, j, k]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5411282}
#standard deviation: 0.04124450708591388
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -8.099999999999996e-05}
#standard deviation: 0.046309652978617756
#island_id: 0
#version_generated: 3
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0151618}
#standard deviation: 0.04609889825971983
#island_id: 0
#version_generated: 3
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': -0.4717206000000001}
#standard deviation: 0.043542468184980046
#island_id: 3
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time22:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': -0.45482780000000006}
#standard deviation: 0.0446894455902062
#island_id: 2
#version_generated: 3
#generate time22:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a small value to the priority of each site to encourage the algorithm to explore more states
        priorities[i * N * N + j * N + k][0] += 0.01
        priorities[i * N * N + j * N + k][1] -= 0.01
        
  return(priorities)




#score: {'data3D.txt': -0.08644020000000005}
#standard deviation: 0.044695549039697455
#island_id: 2
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        spin_energy = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += spin_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += -spin_energy
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3759262}
#standard deviation: 0.04505859600076328
#island_id: 2
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(abs(h[i][j][k])) * 1
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        
        if total_spin > 0:
          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          for d in [3, 4, 5]:
            site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0738694}
#standard deviation: 0.0452884782658901
#island_id: 1
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - sum(J[d, i, site_nbr, k] for d in [0, 1])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - sum(J[d, i, site_nbr, k] for d in [0, 1])

  return priorities




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 1
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins = np.array([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([spin for spin in interacting_spins if spin < 0])
          priorities[i * N * N + j * N + k][1] -= len([spin for spin in interacting_spins if spin > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([spin for spin in interacting_spins if spin > 0])
          priorities[i * N * N + j * N + k][1] += len([spin for spin in interacting_spins if spin < 0])
  
  return priorities




#score: {'data3D.txt': 0.2689954}
#standard deviation: 0.04938620879192895
#island_id: 1
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
        
  return priorities




#score: {'data3D.txt': 0.0010961999999999994}
#standard deviation: 0.047289314496617524
#island_id: 1
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])

  return priorities




#score: {'data3D.txt': -0.3094446000000004}
#standard deviation: 0.048988996017881405
#island_id: 1
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -8.099999999999996e-05}
#standard deviation: 0.046309652978617756
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': -8.099999999999996e-05}
#standard deviation: 0.046309652978617756
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2*total_spin

  return(priorities)




#score: {'data3D.txt': -8.099999999999996e-05}
#standard deviation: 0.046309652978617756
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': -8.099999999999996e-05}
#standard deviation: 0.046309652978617756
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        
  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
  
  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.24011740000000037}
#standard deviation: 0.0454952210373793
#island_id: 1
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_values = np.array(site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.abs(site_nbr_values)) + len([val for val in site_nbr_values if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= (len([val for val in site_nbr_values if val > 0]) - len([val for val in site_nbr_values if val < 0])) 

        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.abs(site_nbr_values)) - len([val for val in site_nbr_values if val < 0]) 
          priorities[i * N * N + j * N + k][1] += (len([val for val in site_nbr_values if val > 0]) - len([val for val in site_nbr_values if val < 0])) 

  return priorities




#score: {'data3D.txt': -0.2415242000000004}
#standard deviation: 0.04760965421382516
#island_id: 1
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(site_nbrs) * np.array([1 if val < 0 else -1 for val in site_nbrs])) + len([val for val in site_nbrs if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= (len([val for val in site_nbrs if val < 0]) - len([val for val in site_nbrs if val > 0])) 
        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.array(site_nbrs) * np.array([1 if val < 0 else -1 for val in site_nbrs])) - len([val for val in site_nbrs if val < 0]) 
          priorities[i * N * N + j * N + k][1] += (len([val for val in site_nbrs if val < 0]) - len([val for val in site_nbrs if val > 0])) 
        
  return priorities




#score: {'data3D.txt': -0.38711579999999995}
#standard deviation: 0.04382035954165598
#island_id: 2
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[0, (i-1)%N, j, k], J[1, i, (j-1)%N, k], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36871860000000006}
#standard deviation: 0.043627784427357756
#island_id: 2
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbrs_up = [J[0, i, j, k], J[1, i, (N-1-j)%N, k], J[2, i, j, (N-1-k)%N]]
        site_nbrs_down = [J[0, (N-1-i)%N, j, k], J[1, i, j, k], J[2, i, j, 0]]
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[0, (i-1)%N, j, k], J[1, i, (j-1)%N, k], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.10919500000000014}
#standard deviation: 0.04621856699422863
#island_id: 2
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbrs_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_nbrs_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + sum(val for val in site_neighbors)
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_nbrs_sum
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][1] += -np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          for d in range(6):
            if J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][1] += -np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin))
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin))
  
  return priorities




#score: {'data3D.txt': 0.0010961999999999994}
#standard deviation: 0.047289314496617524
#island_id: 1
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])

  return priorities




#score: {'data3D.txt': 0.1116726}
#standard deviation: 0.044420256294172816
#island_id: 0
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0004010000000000005}
#standard deviation: 0.04412830337776425
#island_id: 0
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0151618}
#standard deviation: 0.04609889825971983
#island_id: 0
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, i//N**(2), (i//N**(1))%N, (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    if h[i//N**(2)][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, i//N**(2), (i//N**(1))%N, (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, i//N**(2), (i//N**(1))%N, (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.030824999999999735}
#standard deviation: 0.04720213358525227
#island_id: 3
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          for d in range(2):
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1

          for d in range(2):
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        for d in range(2):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5448462}
#standard deviation: 0.039865845852809896
#island_id: 3
#version_generated: 2
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin += J[d, i + d, j, k]
          else:
            neighbor_spin += J[1 - d, i - d, j, k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 2
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2601526}
#standard deviation: 0.04115011972327663
#island_id: 2
#version_generated: 2
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Calculate the total spin of all neighbors in each dimension
        site_neighbors_0 = [J[0, i, j, k] for j in range(N)]
        site_neighbors_1 = [J[1, i, j, k] for j in range(N)]
        site_neighbors_2 = [J[2, i, j, k] for j in range(N)]
        
        # Add a new term based on the total spin of all neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in site_neighbors_0]) + sum([1 if val < 0 else -1 for val in site_neighbors_1]) + sum([1 if val < 0 else -1 for val in site_neighbors_2]))
        priorities[i * N * N + j * N + k][1] += (sum([1 if val > 0 else -1 for val in site_neighbors_0]) + sum([1 if val > 0 else -1 for val in site_neighbors_1]) + sum([1 if val > 0 else -1 for val in site_neighbors_2]))
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2828250000000002}
#standard deviation: 0.04601496772790348
#island_id: 1
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.29791700000000015}
#standard deviation: 0.0449773146263758
#island_id: 1
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if all(J[d, i, j, k] < 0 for d in [0, 1, 2]):
          priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 1
        elif all(J[d, i, j, k] > 0 for d in [0, 1, 2]):
          priorities[i * N * N + j * N + k][0] -= np.sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] += len(site_neighbors) - 1
        
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.453213}
#standard deviation: 0.04369410888209073
#island_id: 3
#version_generated: 3
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.539769}
#standard deviation: 0.04047590343648923
#island_id: 3
#version_generated: 3
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        
  return(priorities)




#score: {'data3D.txt': 0.023756199999999998}
#standard deviation: 0.04580084062066983
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        
  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
  
  return(priorities)




#score: {'data3D.txt': -0.0008046000000000002}
#standard deviation: 0.04925099896286369
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0533078}
#standard deviation: 0.05145929205848055
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.tanh(-total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.0019398000000000004}
#standard deviation: 0.048387071165343326
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin) if total_spin > 0 else -np.tanh(-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin) if -total_spin > 0 else np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -8.099999999999996e-05}
#standard deviation: 0.046309652978617756
#island_id: 0
#version_generated: 3
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i * N * N + j * N + k][0] > 0:
          priorities[i * N * N + j * N + k][1] = 2
        elif priorities[i * N * N + j * N + k][0] < 0:
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.3134417999999997}
#standard deviation: 0.045844839761526035
#island_id: 1
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
   for j in range(N):
    for k in range(N):
      total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
      site_neighbors = [J[3+d,i,(j+1)%N,k] for d in [0,1]] + [J[5,i,j,(k+1)%N]]
      
      if h[i][j][k]>0:
        priorities[i * N * N + j * N + k][0] += total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
      else:
        priorities[i * N * N + j * N + k][0] -= total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
      
      if all(J[d,i,j,k]<0 for d in [0,1,2]):
        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 1
      elif all(J[d,i,j,k]>0 for d in [0,1,2]):
        priorities[i * N * N + j * N + k][0] -= np.sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] += len(site_neighbors) - 1
  
  return(priorities)




#score: {'data3D.txt': 0.2121374}
#standard deviation: 0.04457974922809683
#island_id: 1
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]] + site_neighbors
        else:
          interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]] + site_neighbors
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.26986860000000035}
#standard deviation: 0.04693299707071774
#island_id: 1
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [-1, 0, 1]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5331422}
#standard deviation: 0.039356721143408276
#island_id: 3
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_neighbors_z = [J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_z if val < 0])
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors_z if val < 0]) > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.1096506}
#standard deviation: 0.04529908033989211
#island_id: 3
#version_generated: 3
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': -0.0266718}
#standard deviation: 0.045685451565678985
#island_id: 0
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.019352200000000003}
#standard deviation: 0.046291028884223345
#island_id: 0
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * d for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
      else:
        priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
        priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.34408140000000004}
#standard deviation: 0.05529966992704387
#island_id: 3
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:] if val < 0]) - len([val for val in J[1, i, :, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:] if val > 0]) - len([val for val in J[1, i, :, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.4081686}
#standard deviation: 0.0465184661617298
#island_id: 2
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49612380000000006}
#standard deviation: 0.04344809493591175
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            interacting_spins.append(J[d, i + d, j, k])
          else:
            interacting_spins.append(J[1 - d, i - d, j, k])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif all(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return priorities




#score: {'data3D.txt': -0.0022098000000000005}
#standard deviation: 0.04698493145637226
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.2820498}
#standard deviation: 0.042346742495261665
#island_id: 1
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array([J[0, i, j, k], J[1, i, j, k]]) * np.array([1 if val < 0 else -1 for val in [J[0, i, j, k], J[1, i, j, k]]])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array([J[0, i, j, k], J[1, i, j, k]]) * np.array([1 if val > 0 else -1 for val in [J[0, i, j, k], J[1, i, j, k]]])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[1 - (i % 2), i // 2, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1 - (i % 2), i // 2, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1 - (i % 2), i // 2, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36227980000000004}
#standard deviation: 0.042894017204733806
#island_id: 1
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.sum(np.array(site_neighbors) * np.array([1 if val < 0 else -1 for val in site_neighbors])) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4677634}
#standard deviation: 0.04118022608534344
#island_id: 1
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.39645579999999997}
#standard deviation: 0.03932694605941326
#island_id: 1
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins = np.array([J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1, 2]:
          neighbor_spin = J[3 - d, site_nbr, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1, 2]:
          if (i + (d - 1) % 3 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, site_nbr, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.31657899999999994}
#standard deviation: 0.04467301734828307
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and interactions with neighboring sites
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == -J[d, (i + 1) % N, j, k]])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == J[d, (i + 1) % N, j, k]])
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.018124200000000004}
#standard deviation: 0.04664907860140434
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.47616900000000006}
#standard deviation: 0.04119190841658104
#island_id: 2
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.539769}
#standard deviation: 0.04047590343648923
#island_id: 3
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.539769}
#standard deviation: 0.04047590343648923
#island_id: 3
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5330114000000001}
#standard deviation: 0.040887107870819145
#island_id: 3
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the interaction with other sites
        neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_interactions = [J[0, i, j, k] for n in neighbors if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in neighbors if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in neighbors if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_interactions if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.03025860000000033}
#standard deviation: 0.045445390151697455
#island_id: 3
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_val = [val for val in site_neighbors if val != 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins_val if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0092214}
#standard deviation: 0.0471909396181089
#island_id: 3
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the number of 1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.061601400000000035}
#standard deviation: 0.0511879184773126
#island_id: 2
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d-1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - h[i][j][k]
        priorities[i * N * N + j * N + k][1] = np.sum(interacting_spins) + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.23114180000000034}
#standard deviation: 0.05059612092601564
#island_id: 2
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          site_neighbors.sort()
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.17460579999999992}
#standard deviation: 0.04606145467047258
#island_id: 2
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 2 - total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47624620000000006}
#standard deviation: 0.03941946911819083
#island_id: 2
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.21640099999999998}
#standard deviation: 0.04501561105883159
#island_id: 2
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, (j+1)%N, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, (j-1)%N, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, (j+1)%N, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, (j-1)%N, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.0151618}
#standard deviation: 0.04609889825971983
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.0151618}
#standard deviation: 0.04609889825971983
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.0151618}
#standard deviation: 0.04609889825971983
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin) if total_spin > 0 else -np.tanh(-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin) if -total_spin > 0 else np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.0151618}
#standard deviation: 0.04609889825971983
#island_id: 0
#version_generated: 3
#generate time23:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': -0.04269300000000018}
#standard deviation: 0.0526675508354053
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= (np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins)) / abs(sum(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += (np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - sum(interacting_spins)) / abs(sum(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 3
        
  return priorities




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the priority based on the magnetism and interaction
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.11479660000000001}
#standard deviation: 0.04727684875750498
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 1 - np.exp(-sum([J[d, i, j, k] for d in [0, 1, 2]]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += 1 - np.exp(-sum([J[d, i, j, k] for d in [0, 1, 2]]))
  
  return(priorities)




#score: {'data3D.txt': 0.0533078}
#standard deviation: 0.05145929205848055
#island_id: 0
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.tanh(-total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0533078}
#standard deviation: 0.05145929205848055
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.tanh(-total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0533078}
#standard deviation: 0.05145929205848055
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.tanh(-total_spin)

  return(priorities)




#score: {'data3D.txt': -0.018124200000000004}
#standard deviation: 0.04664907860140434
#island_id: 3
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of -1 and 1 neighbors
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.018124200000000004}
#standard deviation: 0.04664907860140434
#island_id: 3
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Add a new term based on the number of -1 and 1 neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + sum(np.sign(val) for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0092214}
#standard deviation: 0.0471909396181089
#island_id: 3
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Add a new term based on the total spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the number of 1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.199123}
#standard deviation: 0.04334046736019353
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(val for val in interacting_spins)
        
        site_neighbors_count = [val for val in site_neighbors if val < 0].count(1) + [val for val in site_neighbors if val > 0].count(1)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * site_neighbors_count
        priorities[i * N * N + j * N + k][1] -= site_neighbors_count
        
  return(priorities)




#score: {'data3D.txt': -0.12422980000000014}
#standard deviation: 0.04568185582876423
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = J[[0, 1, 2], (i + ((k - 1) % 2 - 1)) % N, j, k]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(np.array(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.sum(np.array(interacting_spins))

  return(priorities)




#score: {'data3D.txt': 0.23241579999999992}
#standard deviation: 0.04497456737268299
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= -np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(val for val in interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.16132540000000017}
#standard deviation: 0.04542522729541373
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.array(interacting_spins) * np.array([1 if val < 0 else -1 for val in interacting_spins])) - np.sum(np.array(site_neighbors) * np.array([1 if val < 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.array(interacting_spins) * np.array([1 if val > 0 else -1 for val in interacting_spins])) - np.sum(np.array(site_neighbors) * np.array([1 if val > 0 else -1 for val in site_neighbors]))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.17466299999999993}
#standard deviation: 0.04662883304351505
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        bond_neighbors = [J[0, (i+1)%N, j, k] + J[0, i, (j+1)%N, k] + J[0, i, j, (k+1)%N], 
                  J[1, i, (j+1)%N, k] + J[1, (i+1)%N, j, (k+1)%N] + J[1, i, j, (k+1)%N], 
                  J[2, i, j, (k+1)%N] + J[2, (i+1)%N, j, k] + J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors) - bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] -= 2 - total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors) + bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20955419999999997}
#standard deviation: 0.05189025286467584
#island_id: 2
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, site_nbr, (k + 1) % N, k], J[1, site_nbr, (k + 1) % N, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, site_nbr, (k + 1) % N, k], J[1, site_nbr, (k + 1) % N, k]] if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, site_nbr, (k + 1) % N, k], J[1, site_nbr, (k + 1) % N, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, site_nbr, (k + 1) % N, k], J[1, site_nbr, (k + 1) % N, k]] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.014867000000000097}
#standard deviation: 0.04596536033797626
#island_id: 2
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.43320700000000006}
#standard deviation: 0.04495974278173753
#island_id: 2
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2, i, j, k], J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2, i, j, k], J[0, i, j, k], J[1, i, j, k]] if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4081686}
#standard deviation: 0.0465184661617298
#island_id: 2
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4081686}
#standard deviation: 0.0465184661617298
#island_id: 2
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4081686}
#standard deviation: 0.0465184661617298
#island_id: 2
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4081686}
#standard deviation: 0.0465184661617298
#island_id: 2
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.17466299999999993}
#standard deviation: 0.04662883304351505
#island_id: 2
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        bond_neighbors = [J[0, (i+1)%N, j, k] + J[0, i, (j+1)%N, k] + J[0, i, j, (k+1)%N], 
             J[1, i, (j+1)%N, k] + J[1, (i+1)%N, j, (k+1)%N] + J[1, i, j, (k+1)%N], 
             J[2, i, j, (k+1)%N] + J[2, (i+1)%N, j, k] + J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors) - bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] -= 2 - total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors) + bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17466299999999993}
#standard deviation: 0.04662883304351505
#island_id: 2
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        bond_neighbors = [J[0, (i+1)%N, j, k] + J[0, i, (j+1)%N, k] + J[0, i, j, (k+1)%N], 
                 J[1, i, (j+1)%N, k] + J[1, (i+1)%N, j, (k+1)%N] + J[1, i, j, (k+1)%N], 
                 J[2, i, j, (k+1)%N] + J[2, (i+1)%N, j, k] + J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors) - bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] -= 2 - total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors) + bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17466299999999993}
#standard deviation: 0.04662883304351505
#island_id: 2
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        bond_neighbors = [sum([J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k], J[0,i,j,(k+1)%N]]), 
                  sum([J[1,i,(j+1)%N,k], J[1,(i+1)%N,j,(k+1)%N], J[1,i,j,(k+1)%N]]), 
                  sum([J[2,i,j,(k+1)%N], J[2,(i+1)%N,j,k], J[2,i,(j+1)%N,k]])]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors) - bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] -= 2 - total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors) + bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] = -2 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.17162139999999992}
#standard deviation: 0.04704959066814504
#island_id: 2
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        bond_neighbors = [J[0, (i+1)%N, j, k] + J[0, i, (j+1)%N, k] + J[0, i, j, (k+1)%N], 
             J[1, i, (j+1)%N, k] + J[1, (i+1)%N, j, (k+1)%N] + J[1, i, j, (k+1)%N], 
             J[2, i, j, (k+1)%N] + J[2, (i+1)%N, j, k] + J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors) - bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] -= 2 - total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors) + bond_neighbors[d] / len(bond_neighbors))
            priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
        if site_neighbors.count(min(site_neighbors)) == 3:
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbors[d] / len(site_neighbors) - bond_neighbors[d] / len(bond_neighbors))
              priorities[i * N * N + j * N + k][1] -= 2 - total_spin
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-1 + site_neighbors[d] / len(site_neighbors) + bond_neighbors[d] / len(bond_neighbors))
              priorities[i * N * N + j * N + k][1] = -2 + total_spin
        
  return(priorities)




