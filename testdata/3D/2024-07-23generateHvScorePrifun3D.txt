#score: {'data3D.txt': -0.40740259999999995}
#standard deviation: 0.045946901889463675
#island_id: 0
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
  
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 2
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
  
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] *= np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] /= np.exp(neighbor_interactions)
        
  return(priorities)




#score: {'data3D.txt': -0.3451962000000004}
#standard deviation: 0.04847846476075742
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
  
  return(priorities)




#score: {'data3D.txt': -0.4729714000000001}
#standard deviation: 0.0415614747337002
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1
          elif site_neighbors[d] > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4417658}
#standard deviation: 0.0458808316223671
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5047486000000001}
#standard deviation: 0.04196969046871802
#island_id: 2
#version_generated: 2
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4485114000000001}
#standard deviation: 0.04620860212168292
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if sum(site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-sum(site_neighbors))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(sum(site_neighbors))
        
  return(priorities)




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        spin_direction = np.sign(total_spin)
        priorities[i*N*N+j*N+k][0] += np.exp(np.abs(neighbor_interactions))
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions * spin_direction
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0054962}
#standard deviation: 0.0470404088583422
#island_id: 0
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
        
        # Calculate global interaction term
        global_interaction_term = 0
        for d in range(3):
          for p in range(N):
            if i != p:
              global_interaction_term += J[d,i,p,k]
            if j != p:
              global_interaction_term += J[d,(i+1)%N,p,k]
            if k != p:
              global_interaction_term += J[d,i,(p+1)%N,k]
        
        # Apply the global interaction term
        priorities[i*N*N+j*N+k][0] *= np.exp(global_interaction_term)
        priorities[i*N*N+j*N+k][1] /= np.exp(-global_interaction_term)
  
  return(priorities)




#score: {'data3D.txt': -0.0028385999999999997}
#standard deviation: 0.04802368988363972
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the number of nearest neighbors that are aligned with the site's spin
        aligned_neighbors = len([val for val in interacting_spins if val == h[i][j][k]])
        
        # Calculate the number of nearest neighbors that are anti-aligned with the site's spin
        anti_aligned_neighbors = len([val for val in interacting_spins if val != h[i][j][k]])
        
        # Calculate the priority for aligning with the site's spin
        priorities[i*N*N+j*N+k][0] += (aligned_neighbors - anti_aligned_neighbors) + total_spin
        
        # Calculate the priority for anti-aligning with the site's spin
        priorities[i*N*N+j*N+k][1] -= (aligned_neighbors - anti_aligned_neighbors) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3331246000000001}
#standard deviation: 0.049684819762579394
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          correction_factor = np.exp(-hamming_distance)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * correction_factor + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          correction_factor = np.exp(hamming_distance)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * correction_factor + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            correction_factor *= np.exp(-1)
          elif J[d,i,(j+1)%N,k] > 0:
            correction_factor *= np.exp(1)
          if J[d,(i+1)%N,j,k] < 0:
            correction_factor *= np.exp(-1)
          elif J[d,(i+1)%N,j,k] > 0:
            correction_factor *= np.exp(1)
        
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
  
  return(priorities)




#score: {'data3D.txt': 0.06680019999999999}
#standard deviation: 0.04595268653691534
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate site magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Update priorities based on total spin and magnetism
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        interacting_spins = [J[d,i,j,k] for d in range(3)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2292738}
#standard deviation: 0.04437445158601964
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Calculate the total interaction and magnetism at this site
        total_interaction = abs(total_spin) + len([val for val in interacting_spins + site_neighbors if val < 0]) / max(len(interacting_spins) + len(site_neighbors), 1)
        priorities[i*N*N+j*N+k][0] += np.exp(-total_interaction)
        priorities[i*N*N+j*N+k][1] /= np.exp(total_interaction)
        
  return(priorities)




#score: {'data3D.txt': -0.38830340000000013}
#standard deviation: 0.04935837343794871
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Add new terms to account for the magnetism of nearest neighbors
        for d in range(3):
          if h[(i+(d-1)%2)%N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3762461999999999}
#standard deviation: 0.046344009165802655
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        correction_factor = np.exp(neighbor_interactions)
        
        # Apply a correction factor based on the interactions with nearest neighbors
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
        
        # Calculate magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        
        # Apply a correction factor based on the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] *= site_magnetism
        priorities[i*N*N+j*N+k][1] /= site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.0027874000000000006}
#standard deviation: 0.04714104582251013
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,(j+1)%N,k] for d in [0,1,2]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.0026250000000000006}
#standard deviation: 0.047152420669569026
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term to account for the magnetism of the neighboring sites
        neighbor_magnetisms = [h[(i+1)%N,j,k], h[i,(j+1)%N,k], h[(i+1)%N,(j+1)%N,k]]
        neighbor_interactions_3 = sum(val for val in neighbor_magnetisms if val > 0) - sum(val for val in neighbor_magnetisms if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_3)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_3
        
  return(priorities)




#score: {'data3D.txt': -0.0024118000000000004}
#standard deviation: 0.0470862882457303
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        site_neighbors_3 = [J[0,(i+1)%N,j,k], J[1,i,(j-1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_3 = sum(val for val in site_neighbors_3 if val > 0) - sum(val for val in site_neighbors_3 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_3)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_3
        
        site_neighbors_4 = [J[0,(i-1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i-1)%N,j,k]]
        neighbor_interactions_4 = sum(val for val in site_neighbors_4 if val > 0) - sum(val for val in site_neighbors_4 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_4)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_4
        
  return(priorities)




#score: {'data3D.txt': -0.0054962}
#standard deviation: 0.0470404088583422
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1279966}
#standard deviation: 0.04731491042409359
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4602142000000001}
#standard deviation: 0.04591407277033916
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4978050000000001}
#standard deviation: 0.041850553341622625
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3248442000000003}
#standard deviation: 0.04740781630026845
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0) - sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0) - sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1203474}
#standard deviation: 0.04623292239562626
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a penalty term based on the number of neighbors with opposite spin
        neighbor_spin_count = sum(1 for val in site_neighbors if (val > 0 and total_spin < 0) or (val < 0 and total_spin > 0))
        priorities[i*N*N+j*N+k][0] -= np.exp(-neighbor_spin_count)
        priorities[i*N*N+j*N+k][1] += neighbor_spin_count
  
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3226678}
#standard deviation: 0.053510233069572775
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          if h[(i+1)%N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

          if h[i][(j+1)%N][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

          if h[i][j][(k+1)%N] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          if h[(i+1)%N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

          if h[i][(j+1)%N][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

          if h[i][j][(k+1)%N] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.44783820000000013}
#standard deviation: 0.04591300666216491
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
        for site_n in site_nbrs:
          if h[site_n[0]][site_n[1]][site_n[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3905534}
#standard deviation: 0.049425536197799616
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.38109659999999995}
#standard deviation: 0.050978749969374494
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.32182499999999997}
#standard deviation: 0.053180989601548406
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  # Add a new term to account for the magnetism of the site itself
  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.3048578}
#standard deviation: 0.0457991194146787
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          spin_momentum = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + spin_momentum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          spin_momentum = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + spin_momentum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
 
  return(priorities)




#score: {'data3D.txt': -0.34557060000000034}
#standard deviation: 0.04831780516165856
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          spin_magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism_coeff + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          spin_magnetism_coeff = np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism_coeff + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
  return(priorities)




#score: {'data3D.txt': -0.36841980000000024}
#standard deviation: 0.046227664963309587
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2701854000000002}
#standard deviation: 0.04644936325548498
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions

        # additional terms to improve the priority
        if i > 0 and J[0,i-1,j,k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
        if j > 0 and J[1,i,j-1,k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4685342000000001}
#standard deviation: 0.04236474230253266
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4193362000000001}
#standard deviation: 0.04832699090115171
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbrs = [(i + 1) % N, (i + N // 2) % N, i - 1]
        neighbor_spins = []
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            neighbor_spins.append(1)
          else:
            neighbor_spins.append(-1)

        priority_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          for spin in neighbor_spins:
            priorities[i * N * N + j * N + k][0] += priority_coeff * (spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= priority_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          for spin in neighbor_spins:
            priorities[i * N * N + j * N + k][0] -= priority_coeff * (spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.17992019999999997}
#standard deviation: 0.05503476421281371
#island_id: 1
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        # Calculate the total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Adjust the priority based on the current spin configuration
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Calculate the priority for the site's nearest neighbors
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Calculate the priority for the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 2
        else:
          priorities[i*N*N+j*N+k][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          interaction_energy = sum(val for val in interacting_spins)

          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - interaction_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          interaction_energy = sum(val for val in interacting_spins)

          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - interaction_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2867942}
#standard deviation: 0.05354074566496063
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1, (j+1)%N, j-1, (k+1)%N, k-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1, (j+1)%N, j-1, (k+1)%N, k-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.1142546}
#standard deviation: 0.059417206420699385
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.26736180000000004}
#standard deviation: 0.05206144850808514
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.34742700000000004}
#standard deviation: 0.1568399253729739
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  # Calculate the energy of the system
  energy = np.sum([J[0,i,j,k]*h[i][j][k] for i in range(N) for j in range(N) for k in range(N)])

  # Adjust priorities based on energy
  if energy > 0:
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  else:
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.37213419999999997}
#standard deviation: 0.047611363668351274
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.4498594000000001}
#standard deviation: 0.041413986425361184
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_diff = np.sum(np.abs(J[:, i, j, k] - h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - spin_diff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          spin_diff = np.sum(np.abs(J[:, i, j, k] - h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff + spin_diff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 2
#generate time01:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3271978}
#standard deviation: 0.05222550598280499
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  # Add a new term to account for the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k]]
      
      if sum(site_neighbors) > 0:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(site_neighbors)))
      else:
        priorities[i*N*N+j*N+k][0] += np.exp(abs(sum(site_neighbors)))
  
  # Add a new term to account for the magnetism of the site itself
  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.13806300000000002}
#standard deviation: 0.05851635934505837
#island_id: 1
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        total_magnetism = 0
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_magnetism += 1
          else:
            total_magnetism -= 1
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the total magnetism of the site's neighbors
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_magnetism))
        priorities[i*N*N+j*N+k][1] -= total_magnetism
  
  return priorities




#score: {'data3D.txt': -0.2519342}
#standard deviation: 0.05623690843529719
#island_id: 1
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.291071}
#standard deviation: 0.05519913295514704
#island_id: 1
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45927260000000014}
#standard deviation: 0.045598797892488344
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.sum(interacting_spins) > 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (np.sum(interacting_spins) < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 2
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032206}
#standard deviation: 0.046944338270338844
#island_id: 0
#version_generated: 2
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*neighbor_magnetism_coeff
        
        return(priorities)




#score: {'data3D.txt': -0.3320593999999998}
#standard deviation: 0.0471302462505767
#island_id: 3
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.369719}
#standard deviation: 0.044226698260213824
#island_id: 3
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.4735522000000001}
#standard deviation: 0.04310466233668928
#island_id: 3
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4600786000000001}
#standard deviation: 0.042392909100933386
#island_id: 3
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority based on the magnetism and interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k] - 2*total_spin + 2*len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 2*h[i][j][k] + 2*total_spin - 2*len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.11762059999999988}
#standard deviation: 0.04652693516276351
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4735522000000001}
#standard deviation: 0.04310466233668928
#island_id: 3
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.202993}
#standard deviation: 0.04394274810477834
#island_id: 3
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
        # Add new term to account for the interactions between neighboring sites
        if i > 0 and j < N-1:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if i < N-1 and j < N-1:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i+1,j,k], J[1,(i+2)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': 0.44966380000000017}
#standard deviation: 0.04216105180803724
#island_id: 3
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42001459999999996}
#standard deviation: 0.04032370700766486
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_one_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0 and val != J[2,i,j,k]]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + spin_one_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          spin_one_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0 and val != J[2,i,j,k]]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - spin_one_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.4603306}
#standard deviation: 0.04146706962928536
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance
        
        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

        # Add the site's own energy
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k]
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.016854199999999986}
#standard deviation: 0.04643350409305763
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field and its interaction with neighboring sites
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0420902}
#standard deviation: 0.04888815627490978
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          spin_momentum = np.sum(np.sign(J[:, i, j, k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor + spin_momentum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor + 2 * spin_momentum
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          spin_momentum = -np.sum(np.sign(J[:, i, j, k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor - spin_momentum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor - 2 * spin_momentum

  return(priorities)




#score: {'data3D.txt': -0.2915442}
#standard deviation: 0.04593693640590325
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          total_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][0] += total_magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          total_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) - neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][0] -= total_magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.41112620000000005}
#standard deviation: 0.04537325152069224
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          interaction_coeff = np.exp(-abs(sum(J[d,i-1,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor + interaction_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          interaction_coeff = np.exp(-abs(sum(J[d,i-1,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor + interaction_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.4574122}
#standard deviation: 0.04037831956830299
#island_id: 2
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          neighbor_magnetism_coeff_neighbor = np.exp(-abs(total_spin) * (len([val for val in [J[0,(i+2)%N,(j+1)%N,k], J[1,(i+3)%N,j,k]] if val < 0]) > len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor + neighbor_magnetism_coeff_neighbor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor + 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          neighbor_magnetism_coeff_neighbor = np.exp(-abs(total_spin) * (len([val for val in [J[0,(i+2)%N,(j+1)%N,k], J[1,(i+3)%N,j,k]] if val > 0]) > len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor - neighbor_magnetism_coeff_neighbor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor - 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.1124721999999998}
#standard deviation: 0.04857199879724944
#island_id: 3
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          spin_interaction = sum(val * (val > 0) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + spin_interaction
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism - 2*spin_interaction
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          spin_interaction = sum(val * (val < 0) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + spin_interaction
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism + 2*spin_interaction
 
  return(priorities)




#score: {'data3D.txt': -0.3952034}
#standard deviation: 0.039632099470504965
#island_id: 3
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.11302140000000031}
#standard deviation: 0.05066004877652607
#island_id: 3
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          spin_flip_energy = total_spin - (2 * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - 1
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism + spin_flip_energy
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          spin_flip_energy = total_spin + (2 * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - 1
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism + spin_flip_energy
  
  return(priorities)




#score: {'data3D.txt': -0.3801018}
#standard deviation: 0.04297974588989562
#island_id: 2
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.45693060000000013}
#standard deviation: 0.044703267259116525
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4978050000000001}
#standard deviation: 0.041850553341622625
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbrs = [(i+((k-1)%2 - 1)) % N]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4685342000000001}
#standard deviation: 0.04236474230253266
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4685342000000001}
#standard deviation: 0.04236474230253266
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.522069}
#standard deviation: 0.04021413680535739
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5165330000000001}
#standard deviation: 0.041863485175030524
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)

  return(priorities)




#score: {'data3D.txt': -0.26515819999999996}
#standard deviation: 0.05373697249343324
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        # Calculate the total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Adjust the priority based on the current spin configuration
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (interacting_spins[d] > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (interacting_spins[d] < 0)

        # Calculate the priority for the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 2
        else:
          priorities[i*N*N+j*N+k][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 3
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = 2 * (total_spin > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - spin_magnetism
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = 2 * (total_spin < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - spin_magnetism

  return(priorities)




#score: {'data3D.txt': -0.09202940000000003}
#standard deviation: 0.047167006006741626
#island_id: 0
#version_generated: 3
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d,i,j,k] for d in [0,1,2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47611100000000023}
#standard deviation: 0.04507564795984635
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4887886000000001}
#standard deviation: 0.04195160437980889
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      priorities[i*N*N+j*N+site_nbr][0] += np.sum(h[i][j])
      priorities[i*N*N+j*N+site_nbr][1] -= np.sum(h[i][j])

  return(priorities)




#score: {'data3D.txt': -0.49035540000000016}
#standard deviation: 0.0423780137670467
#island_id: 0
#version_generated: 3
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])

  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 2
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.1665762}
#standard deviation: 0.04490993245998039
#island_id: 2
#version_generated: 2
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3327646000000001}
#standard deviation: 0.05184213408840342
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
        for site_n in site_nbrs:
          if h[site_n[0]][site_n[1]][site_n[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': 0.0359422}
#standard deviation: 0.04608822299850581
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] < 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4303966}
#standard deviation: 0.04767132752965875
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.26736180000000004}
#standard deviation: 0.05206144850808514
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.3814374}
#standard deviation: 0.04635285278426777
#island_id: 0
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])

        # Add new term based on the interactions with neighboring sites
        x = (i+1)%N
        y = (j+1)%N
        z = (k+1)%N
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in [J[0, i, j, k], J[1, x, j, k], J[2, i, y, k]]])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in [J[0, i, j, k], J[1, x, j, k], J[2, i, y, k]]])

  return(priorities)




#score: {'data3D.txt': 0.1633721999999999}
#standard deviation: 0.04829963878912554
#island_id: 0
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the Hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the priority based on the total spin and interaction with nearest neighbors
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        
        # Calculate the priority based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.295939}
#standard deviation: 0.04635413680568326
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': -0.4754686}
#standard deviation: 0.042276684520430416
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': -0.14262819999999998}
#standard deviation: 0.0494331617920602
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3807346}
#standard deviation: 0.05089820903371749
#island_id: 1
#version_generated: 3
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms to account for interactions with more distant neighbors
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4928182000000001}
#standard deviation: 0.04188012355234879
#island_id: 0
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*N+j*N+site_nbr][0] += h[i][j][k]
        priorities[i*N*N+j*N+site_nbr][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47943380000000013}
#standard deviation: 0.042432067326021256
#island_id: 0
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[i][j])
      if total_spin > 0:
        priorities[i*N*N+j*N+(N-1)%N][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+(N-1)%N][0] -= np.exp(abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4633830000000001}
#standard deviation: 0.04219841028996235
#island_id: 0
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][site_nbr][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N*N+j*N+site_nbr][0] += np.exp(h[i][j][0]) * (total_spin > 0) + total_spin
      priorities[i*N*N+j*N+site_nbr][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.14262819999999998}
#standard deviation: 0.0494331617920602
#island_id: 0
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.40609340000000005}
#standard deviation: 0.044437328862567786
#island_id: 0
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3566366000000001}
#standard deviation: 0.04640450646693702
#island_id: 0
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.00021579999999999877}
#standard deviation: 0.049124103557825864
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))

  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k]]
      if sum(site_neighbors) > 0:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(site_neighbors)))
      else:
        priorities[i*N*N+j*N+k][0] += np.exp(abs(sum(site_neighbors)))

  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2

  return priorities




#score: {'data3D.txt': -0.4010994}
#standard deviation: 0.050085273680394324
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  # Add new term to account for the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,j,k], J[4,i,j,k]]
      
      if sum(site_neighbors) < 0:
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3216474}
#standard deviation: 0.05305951783836713
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  # Add a new term to account for the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,(j+1)%N,k], J[4,i,j,(k+1)%N]]
      if sum(site_neighbors) < 0:
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
  # Add a new term to account for the magnetism of the site itself
  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.08440340000000003}
#standard deviation: 0.0479370498512372
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += total_spin
          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][1] -= total_spin
          for d in range(6):
            if J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.13852699999999998}
#standard deviation: 0.0471857943771216
#island_id: 2
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          product_nn_spins = np.prod([1 if val > 0 else -1 for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += total_spin + hamming_distance * (product_nn_spins > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          product_nn_spins = np.prod([1 if val < 0 else -1 for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= total_spin - hamming_distance * (product_nn_spins > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4698538}
#standard deviation: 0.043346520339699705
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': -0.4754686}
#standard deviation: 0.042276684520430416
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': 0.005487400000000038}
#standard deviation: 0.04593803741171362
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.012072199999999998}
#standard deviation: 0.046347625906404316
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.26736180000000004}
#standard deviation: 0.05206144850808514
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44190340000000006}
#standard deviation: 0.042192223791120566
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i * N * N + j * N + k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i * N * N + j * N + k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add new term to account for the interaction with nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i * N * N + j * N + k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.3299309999999999}
#standard deviation: 0.05167073290558206
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.24798780000000012}
#standard deviation: 0.04196199388923268
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5062838000000001}
#standard deviation: 0.03923239755049391
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3299309999999999}
#standard deviation: 0.05167073290558206
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.49326660000000017}
#standard deviation: 0.042151469777933014
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5158454}
#standard deviation: 0.040918444482164765
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47943380000000013}
#standard deviation: 0.042432067326021256
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[i][j])
      if total_spin > 0:
        priorities[i*N*N+j*N+(N-1)%N][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+(N-1)%N][0] -= np.exp(abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4762682000000001}
#standard deviation: 0.04253938256204479
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interaction energies
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0, 1, 2]]
        total_spin = sum(J[d,i,j,k] for d in [0, 1, 2])
        
        # Calculate magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  # Calculate sum of magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[i][j])
      if total_spin > 0:
        priorities[i*N*N+j*N+(N-1)%N][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+(N-1)%N][0] -= np.exp(abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0666858}
#standard deviation: 0.04554373412841771
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]

        if h[i][j][k] > 0:
          total_spin += sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin += sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.045197799999999996}
#standard deviation: 0.04634179059078317
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          total_spin = sum([spin for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin = sum([-spin for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1665762}
#standard deviation: 0.04490993245998039
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(3):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum([h[i][j][k] for _ in range(3)])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': 0.020803}
#standard deviation: 0.04722892790441045
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.5092390000000001}
#standard deviation: 0.04229245652595744
#island_id: 0
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time03:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time03:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 2
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2968166}
#standard deviation: 0.05064356231980527
#island_id: 0
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.26278660000000026}
#standard deviation: 0.048691633166695086
#island_id: 0
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.29275419999999985}
#standard deviation: 0.04583936585905174
#island_id: 0
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.197047}
#standard deviation: 0.043548427193183456
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: total spin as priority
        priorities[i*N*N+j*N+k][0] += abs(total_spin)
        priorities[i*N*N+j*N+k][1] -= abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.10297900000000001}
#standard deviation: 0.04602823740922523
#island_id: 0
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0419438}
#standard deviation: 0.04699386514812332
#island_id: 0
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the interactions between sites with opposite spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val < 0]) > len([val for val in interacting_sites if val > 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.04459620000000008}
#standard deviation: 0.0460634400100557
#island_id: 0
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the interactions between sites with opposite spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val < 0]) > len([val for val in interacting_sites if val > 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4963170000000001}
#standard deviation: 0.04316967397375153
#island_id: 2
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time03:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time03:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44362739999999995}
#standard deviation: 0.03977777280391651
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        neighbor_magnetism = np.sum([np.exp(J[d,i,j,k]) for d in range(6)])
        priorities[i*N*N+j*N+k][0] += (site_magnetism + neighbor_magnetism) / 2
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0399698}
#standard deviation: 0.04229016159770497
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_priority = total_spin + magnetism_coeff * (hamming_distance > 0.5) - np.sum(np.abs(np.array(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += spin_priority
          priorities[i*N*N+j*N+k][1] -= spin_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_priority = total_spin - magnetism_coeff * (hamming_distance > 0.5) + np.sum(np.abs(np.array(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= spin_priority
          priorities[i*N*N+j*N+k][1] += spin_priority

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3488982000000003}
#standard deviation: 0.04956468497589791
#island_id: 3
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 2
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 2
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
        
        # Add new term to account for the magnetism of the site itself
        priority += h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] = max(priority, -priority)
        priorities[i*N*N+j*N+k][1] = min(-priority, priority)
  
  return(priorities)




#score: {'data3D.txt': -0.49638780000000005}
#standard deviation: 0.04327271994178319
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
    
  return(priorities)




#score: {'data3D.txt': -0.48983620000000005}
#standard deviation: 0.04385528211698108
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4459802000000001}
#standard deviation: 0.046929387466277464
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself and its interactions with neighboring sites
        if h[i][j][k] > 0:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4980958000000001}
#standard deviation: 0.041922611349485384
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47006340000000013}
#standard deviation: 0.041506850765144786
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.369719}
#standard deviation: 0.044226698260213824
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_magnetism = total_spin + np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_magnetism
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_magnetism = total_spin - np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_magnetism
          
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3681498}
#standard deviation: 0.04157801245802883
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself and its neighbors
        for d in [0, 1, 2]:
          site_nbr = (i + ((d-1)%3 - 1)) % N
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4516142000000001}
#standard deviation: 0.04241684097572567
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      total_spin = sum(h[site_nbr][i][j] for _ in range(3))
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+0][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+0][0] -= np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+0][1] = -2 + 2*total_spin

      site_nbr = (i + ((1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][i][j] for _ in range(3))
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+1][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+1][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+1][0] -= np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+1][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5026058000000001}
#standard deviation: 0.04182517144447827
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.39928179999999996}
#standard deviation: 0.04025387619546719
#island_id: 1
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of interacting spins with the same sign as the site's magnetism
        same_sign_spins = sum(1 for val in interacting_spins if np.sign(val) == np.sign(h[i][j][k]))
        priorities[i*N*N+j*N+k][0] += 2 * same_sign_spins
        
  return(priorities)




#score: {'data3D.txt': -0.49402660000000015}
#standard deviation: 0.04117793064786039
#island_id: 1
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i+1)%N if k == 0 else i, (i+N-1)%N if k == 2 else i]
        for x, y, z in itertools.product(site_nbrs, [j], [k]):
          interacting_spins.append(J[0,x,y,z])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4980958000000001}
#standard deviation: 0.041922611349485384
#island_id: 2
#version_generated: 3
#generate time04:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.38553980000000027}
#standard deviation: 0.04990493218069733
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.09690340000000004}
#standard deviation: 0.10488410131397426
#island_id: 1
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  h_flipped = np.sign(h) * 2 - 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h_flipped[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h_flipped[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h_flipped[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h_flipped[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h_flipped[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.002457}
#standard deviation: 0.050273260397551305
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the sum of interactions for each site
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))

  # Initialize a variable to store the priority values
  priority_total = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_total[i*N*N+j*N+k][0] += total_spin_sum[i]*h[i][j][k]
          priority_total[i*N*N+j*N+k][1] -= total_spin_sum[i]*h[i][j][k]
        else:
          priority_total[i*N*N+j*N+k][0] -= total_spin_sum[i]*h[i][j][k]
          priority_total[i*N*N+j*N+k][1] += total_spin_sum[i]*h[i][j][k]

  return priority_total




#score: {'data3D.txt': -0.26090140000000006}
#standard deviation: 0.09190871600691639
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.026562199999999998}
#standard deviation: 0.046786962833250886
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.026562199999999998}
#standard deviation: 0.046786962833250886
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0005418000000000004}
#standard deviation: 0.04608222751517118
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        if J[0][i//N][(j+k)%N][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = total_spin * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_product + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = total_spin * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_product + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.48695220000000006}
#standard deviation: 0.04384030833787555
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
          for d in [0,1,2]:
            if J[d,i,j,k] == J[0,i,j,k]:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
          for d in [0,1,2]:
            if J[d,i,j,k] == J[0,i,j,k]:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
  return(priorities)




#score: {'data3D.txt': -0.44698940000000004}
#standard deviation: 0.04191031099431261
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
  
  # Add a bias term to the priority based on the sign of h[i][j][k]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -2
  
  return(priorities)




#score: {'data3D.txt': -0.4648546}
#standard deviation: 0.044091238345503526
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff

  for i in range(N):
    for j in range(N):
      if h[0][j][k] > 0:
        priorities[j*N*N+i*N+k][0] += total_spin
        priorities[j*N*N+i*N+k][1] -= -total_spin
      else:
        priorities[j*N*N+i*N+k][0] -= total_spin
        priorities[j*N*N+i*N+k][1] = -total_spin

  for j in range(N):
    if h[i][0][k] > 0:
      priorities[i*N*N+j*N+k][0] += total_spin
      priorities[i*N*N+j*N+k][1] -= -total_spin
    else:
      priorities[i*N*N+j*N+k][0] -= total_spin
      priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.49638780000000005}
#standard deviation: 0.04327271994178319
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2039366}
#standard deviation: 0.09123520603604732
#island_id: 1
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin sum
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  
  # Calculate average magnetism of each site
  avg_magnetism = np.mean(h)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate priority based on magnetism and interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * avg_magnetism
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.23444220000000002}
#standard deviation: 0.09366173828816121
#island_id: 1
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09476940000000006}
#standard deviation: 0.047344527705321986
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.09476940000000006}
#standard deviation: 0.047344527705321986
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5158454}
#standard deviation: 0.040918444482164765
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_difference + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_difference - site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2627838000000003}
#standard deviation: 0.04761396620278551
#island_id: 0
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0, 1, 2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
        # Calculate the product of all neighboring spins
        nn_spin_product = 1
        for d in [0, 1]:
          if i > 0:
            nn_spin_product *= J[d, (i-1)%N, j, k]
          if j > 0:
            nn_spin_product *= J[d, i, (j-1)%N, k]
          if k > 0:
            nn_spin_product *= J[d, i, j, (k-1)%N]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in interacting_spins]) * nn_spin_product
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in interacting_spins]) * nn_spin_product
  
  return(priorities)




#score: {'data3D.txt': 0.3989234000000001}
#standard deviation: 0.04194681313806808
#island_id: 3
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2,3,4,5]])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * 2 - sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * 2 - sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.1709601999999998}
#standard deviation: 0.045954931573880066
#island_id: 3
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - 2*hamming_distance
          priorities[i*N*N+j*N+k][1] = 2
  return(priorities)




#score: {'data3D.txt': 0.056285800000000004}
#standard deviation: 0.04642650663532634
#island_id: 3
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i//N,(j+k)%N,k] for d in [0,1,2,3,4,5]) + h[i][j][k]
        if J[0][i//N][(j+k)%N][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 + 2*total_spin
          priorities[i*N*N+j*N+k][1] = total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time04:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          spin_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5120933999999999}
#standard deviation: 0.0406236881196181
#island_id: 0
#version_generated: 3
#generate time04:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.4840410000000001}
#standard deviation: 0.04265389875497902
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        
  return(priorities)




#score: {'data3D.txt': -0.4838794000000001}
#standard deviation: 0.043369078104566625
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])

  return(priorities)




#score: {'data3D.txt': -0.4572906}
#standard deviation: 0.04088797270151701
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        # Add new term based on the site's magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.4876802000000001}
#standard deviation: 0.04231517278660221
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      priorities[i*N*N+j*N+site_nbr][0] += np.sum(h[i][j])
      priorities[i*N*N+j*N+site_nbr][1] -= np.sum(h[i][j])

  return(priorities)




#score: {'data3D.txt': -0.5092390000000001}
#standard deviation: 0.04229245652595744
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
          
  return(priorities)




#score: {'data3D.txt': -0.4876802000000001}
#standard deviation: 0.04231517278660221
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      priorities[i*N*N+j*N+site_nbr][0] += np.sum(h[i][j])
      priorities[i*N*N+j*N+site_nbr][1] -= np.sum(h[i][j])

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin + np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) + total_spin + np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.011223400000000001}
#standard deviation: 0.04679289574753843
#island_id: 3
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0][i//N][(j+k)%N][k], J[1][(i+1)%N][j][k], J[2][i][(j+1)%N][k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.020061799999999998}
#standard deviation: 0.046886582950349455
#island_id: 3
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k]) * (np.sum(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k]) * (np.sum(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0272446}
#standard deviation: 0.04690179752248307
#island_id: 3
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4466738}
#standard deviation: 0.045470982764396026
#island_id: 3
#version_generated: 3
#generate time05:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time05:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.38553980000000027}
#standard deviation: 0.04990493218069733
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43446740000000034}
#standard deviation: 0.045317513361171964
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]

        # Add new term to account for the priority of the site itself based on its magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.18049100000000023}
#standard deviation: 0.05111071589207101
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.38553980000000027}
#standard deviation: 0.04990493218069733
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.421783}
#standard deviation: 0.03910453159161992
#island_id: 3
#version_generated: 3
#generate time05:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][1] -= 2
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.45087380000000016}
#standard deviation: 0.0471720268120843
#island_id: 3
#version_generated: 3
#generate time05:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.1217046}
#standard deviation: 0.048340353937885064
#island_id: 3
#version_generated: 3
#generate time05:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.45805420000000013}
#standard deviation: 0.04425182914140385
#island_id: 3
#version_generated: 3
#generate time05:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          spin_coeff = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Apply priority to sites with the same energy level
        if np.isclose(priorities[i*N*N+j*N+k,0], priorities[i*N*N+j*N+k,1]):
          if h[i//N%N][i//N//N]%N > 0:
            priorities[i*N*N+j*N+k] += [1, -1]
          else:
            priorities[i*N*N+j*N+k] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.45805420000000013}
#standard deviation: 0.04425182914140385
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          spin_coeff = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff

  return(priorities)




#score: {'data3D.txt': -0.44080020000000003}
#standard deviation: 0.046289995030891935
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44362739999999995}
#standard deviation: 0.03977777280391651
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        neighbor_magnetism = np.sum([np.exp(J[d,i,j,k]) for d in range(6)])
        priorities[i*N*N+j*N+k][0] += (site_magnetism + neighbor_magnetism) / 2
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.044450199999999995}
#standard deviation: 0.04793494758482583
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        neighbor_magnetism = np.sum([np.exp(J[d,i,j,k]) for d in range(6)])
        priorities[i*N*N+j*N+k][0] += (site_magnetism + neighbor_magnetism) / 2
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add term to account for the site's neighbors' magnetization in the z direction
        for d in range(3):
          if i > 0:
            top_neighbor_magnetism = np.exp(J[d,i-1,j,k])
          else:
            top_neighbor_magnetism = 0
          if j > 0:
            left_neighbor_magnetism = np.exp(J[d,i,(j-1)%N,k])
          else:
            left_neighbor_magnetism = 0
          if i < N - 1:
            bottom_neighbor_magnetism = np.exp(J[d,i+1,j,k])
          else:
            bottom_neighbor_magnetism = 0
          if j < N - 1:
            right_neighbor_magnetism = np.exp(J[d,i,(j+1)%N,k])
          else:
            right_neighbor_magnetism = 0
          priorities[i*N*N+j*N+k][0] += (top_neighbor_magnetism + left_neighbor_magnetism + bottom_neighbor_magnetism + right_neighbor_magnetism) / 4
          priorities[i*N*N+j*N+k][1] -= top_neighbor_magnetism + left_neighbor_magnetism + bottom_neighbor_magnetism + right_neighbor_magnetism

  return(priorities)




#score: {'data3D.txt': -0.4527722}
#standard deviation: 0.04534467098965435
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          spin_coeff = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff

  return(priorities)




#score: {'data3D.txt': -0.4669942000000001}
#standard deviation: 0.043125626793821786
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        spin_magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_magnetism * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= spin_magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= spin_magnetism * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] -= spin_magnetism

  return(priorities)




#score: {'data3D.txt': -0.45809180000000016}
#standard deviation: 0.04445652092505665
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = -np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.1707821999999998}
#standard deviation: 0.04587473512904461
#island_id: 3
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] -= np.sum(np.array(interacting_spins) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] += np.sum(np.array(interacting_spins) < 0)
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - 2*len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = 2
  return(priorities)




#score: {'data3D.txt': -0.1709601999999998}
#standard deviation: 0.045954931573880066
#island_id: 3
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-hamming_distance) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*np.exp(-hamming_distance)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-hamming_distance) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] += 4 - 4*np.exp(-hamming_distance)
  return(priorities)




#score: {'data3D.txt': -0.011442999999999998}
#standard deviation: 0.2519205416614532
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a global term to account for the overall magnetization
  total_magnetism = sum(sum(h[i][j]) for i in range(N) for j in range(N))
  for i in range(N**3):
    priorities[i][0] += np.exp(total_magnetism)
    priorities[i][1] -= total_magnetism

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.39738379999999995}
#standard deviation: 0.04691103684166446
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': 0.007215799999999936}
#standard deviation: 0.05003858381649106
#island_id: 3
#version_generated: 3
#generate time05:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.02121740000000012}
#standard deviation: 0.05068091531572808
#island_id: 3
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.16024260000000026}
#standard deviation: 0.047142476655771925
#island_id: 3
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
          site_neighbors.remove((i, j, k))
          for neighbor in site_neighbors:
            if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[neighbor[0]][neighbor[1]][neighbor[2]]
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[neighbor[0]][neighbor[1]][neighbor[2]]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
          site_neighbors.remove((i, j, k))
          for neighbor in site_neighbors:
            if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[neighbor[0]][neighbor[1]][neighbor[2]]
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin - h[neighbor[0]][neighbor[1]][neighbor[2]]
  return(priorities)




#score: {'data3D.txt': 0.04817259999999998}
#standard deviation: 0.04851957717499196
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_nbr_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == site_nbr and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-site_nbr)+abs(k1-k) <= 1) or (k1 == k and abs(i1-site_nbr)+abs(j1-j) <= 1))]
        site_nbr_neighbors.remove((site_nbr, j, k))
        for neighbor in site_nbr_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44080020000000003}
#standard deviation: 0.046289995030891935
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4309682}
#standard deviation: 0.043428047950143926
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_magnetism_coeff = np.exp(h[i][j].sum())
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
      else:
        site_magnetism_coeff = -np.exp(-h[i][j].sum())
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.44080020000000003}
#standard deviation: 0.046289995030891935
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4410802}
#standard deviation: 0.04618616424818152
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        spin_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_coeff * (h[i][j][k] > 0) + total_spin / len(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.45809180000000016}
#standard deviation: 0.04445652092505665
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = -np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.40385420000000005}
#standard deviation: 0.05048455112566616
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_magnetism = h[site_nbr][i%N][k]
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.45809180000000016}
#standard deviation: 0.04445652092505665
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself and its neighbors
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbor_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbor_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbor_magnetism > 0)
        else:
          spin_coeff = -np.exp(h[i][j][k])
          neighbor_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbor_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbor_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.4563094000000001}
#standard deviation: 0.04596117395846194
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.039879799999999986}
#standard deviation: 0.04906431933656066
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_nbr_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == site_nbr and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-site_nbr)+abs(k1-k) <= 1) or (k1 == k and abs(i1-site_nbr)+abs(j1-j) <= 1))]
        for neighbor in site_nbr_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.144731}
#standard deviation: 0.051863457646015076
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_magnetism = h[site_nbr][i%N][k]
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism
        
  for i in range(N**3):
    total_spin = np.sum([J[d, i // N % N, i % N, k] for d in range(6)])
    if h[i//N % N][i%N][k] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.039879799999999986}
#standard deviation: 0.04906431933656066
#island_id: 3
#version_generated: 3
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_nbr_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == site_nbr and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-site_nbr)+abs(k1-k) <= 1) or (k1 == k and abs(i1-site_nbr)+abs(j1-j) <= 1))]
        for neighbor in site_nbr_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]

  return priorities




#score: {'data3D.txt': -0.08496139999999999}
#standard deviation: 0.055915664978966315
#island_id: 3
#version_generated: 3
#generate time06:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_magnetism = h[site_nbr][i%N][k]
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism

  for i in range(N**3):
    total_spin = sum([J[d, i//N%N, i%N//N, k] for d in range(6) for k in [i%N]])
    if np.sum(h[i//N%N][i%N//N][k]) > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 2
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.415951}
#standard deviation: 0.04029504335523167
#island_id: 2
#version_generated: 2
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0026625999999999998}
#standard deviation: 0.04762088576706653
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        interacting_spins = [J[d, i//N, (j+k)%N, k] for d in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': -0.1826422}
#standard deviation: 0.05867549555956047
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += 2 - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - total_spin

  return(priorities)




#score: {'data3D.txt': -0.22946300000000003}
#standard deviation: 0.04633766233853408
#island_id: 1
#version_generated: 3
#generate time07:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            if sum(val for val in site_neighbors) > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] += 1
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            if sum(val for val in site_neighbors) > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': -0.5101714}
#standard deviation: 0.04031464079016456
#island_id: 1
#version_generated: 3
#generate time07:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term to account for the interaction between the current site and its neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.507355}
#standard deviation: 0.04026938806339128
#island_id: 1
#version_generated: 3
#generate time07:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interactions with neighboring sites
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2109014}
#standard deviation: 0.04852962392230131
#island_id: 1
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the influence of neighboring sites
        for d in [0,1,2]:
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.507355}
#standard deviation: 0.04026938806339128
#island_id: 1
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interactions with neighboring sites
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0175486}
#standard deviation: 0.04848962649928333
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = h[i//N][j].sum()
      if site_magnetism_coeff > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.014714600000000001}
#standard deviation: 0.047303870738450146
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return priorities




#score: {'data3D.txt': -0.0256474}
#standard deviation: 0.046746264377381
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = np.exp(h[i//N][j].sum())
      for k in range(N):
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        neighboring_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in neighboring_spins if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance - sum(val for val in neighboring_spins if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.1701173999999998}
#standard deviation: 0.04472834914503328
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff
        if total_spin > 0:
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance
        else:
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin - 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][0] += h[i][j][k] * (h[i][j][k] > 0) + magnetism_coeff * interaction_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k] + 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.3516486}
#standard deviation: 0.04052374511369847
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = np.exp(-h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

        # Add new term to account for the interaction with neighboring sites
        if i > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i-1,j,k])
          priorities[i*N*N+j*N+k][1] -= h[i-1,j,k]
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i+1,j,k])
          priorities[i*N*N+j*N+k][1] -= h[i+1,j,k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i,j-1,k])
          priorities[i*N*N+j*N+k][1] -= h[i,j-1,k]
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i,j+1,k])
          priorities[i*N*N+j*N+k][1] -= h[i,j+1,k]

  return(priorities)




#score: {'data3D.txt': -0.42013700000000015}
#standard deviation: 0.04663108910372992
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = np.exp(-h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= -spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Normalize the priority values
        priorities[i*N*N+j*N+k][0] /= (abs(total_spin) + 1)
        priorities[i*N*N+j*N+k][1] /= (abs(total_spin) + 1)

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.11971620000000012}
#standard deviation: 0.04929151384934328
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_magnetism = h[i][j][k]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (hamming_distance > 0.5) + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (hamming_distance > 0.5) - site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*abs(total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4466738}
#standard deviation: 0.045470982764396026
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.018287400000000002}
#standard deviation: 0.04800993815076208
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.030703400000000002}
#standard deviation: 0.04673837040847701
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.030703400000000002}
#standard deviation: 0.04673837040847701
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  # Apply some magic here
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over each site in the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.411985}
#standard deviation: 0.039166755992805946
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.411985}
#standard deviation: 0.039166755992805946
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3563918000000003}
#standard deviation: 0.04876254682397136
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the priority of the site itself based on its magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  # Apply a learning rate to the priorities
  learning_rate = 0.5
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] *= (1 - learning_rate)
          priorities[i*N*N+j*N+k][1] *= (1 - learning_rate)
        else:
          priorities[i*N*N+j*N+k][0] /= (1 + learning_rate)
          priorities[i*N*N+j*N+k][1] /= (1 + learning_rate)

  return priorities




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 2
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.08905860000000004}
#standard deviation: 0.046902233273480705
#island_id: 2
#version_generated: 2
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate magnetism coefficients for each site
  magnetisms = np.exp(-np.abs(h).reshape(-1, 1, 1))
  
  # Iterate over all sites in the lattice
  for i in range(N):
    for j in range(N):
      for k in range(N):
        # Initialize total spin and interacting spins
        total_spin = J[0,i,j,k] + J[1,(i+1)%N,j,k] + J[2,i,(j+1)%N,k]
        
        # Check if site is interacting with at least one neighbor
        has_neighbor_interaction = any(val < 0 for val in J[:,i,j,k])
        
        # Calculate hamming distance and magnetism coefficient for this site
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + 1
        
        # Assign priorities
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over each site in the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Calculate magnetism coefficient based on site's own magnetism and neighboring spins
        magnetism_coeff = np.exp(-abs(total_spin)) * (np.sum(np.sign(h[i][j][k] + total_spin)) > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4725082}
#standard deviation: 0.03946942630391275
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        magnetism_coeff = np.exp(-abs(total_spin) * (h[i][j][k] > 0))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site's neighbors
        for d in range(3):
          neighbor_spins = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(neighbor_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in neighbor_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over each site in the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        magnetism_coeff = np.exp(-abs(total_spin) * (h[i][j][k] > 0))
        
        for d in range(3):
          if d == i % N or d == j % N or d == k % N:
            neighbor_spins = [J[d,i,j,k], J[(d+1)%6,i,j,k]]
            magnetism_coeff += np.exp(-abs(total_spin) * (sum(neighbor_spins) > 0))
        
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48520100000000005}
#standard deviation: 0.040631307621094355
#island_id: 0
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site's neighbors
        for d in range(3):
          neighbor_spins = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(neighbor_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in neighbor_spins if val < 0)
        
        # Add a new term to account for the interactions with the sites diagonally
        for d in range(3):
          diagonal_spins = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(diagonal_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in diagonal_spins if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.005399000000000001}
#standard deviation: 0.04731031387551767
#island_id: 3
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d][i//N][(j+k)%N][k] for d in [0, 1, 2, 3, 4, 5]) + h[i//N][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': -0.0027634000000000005}
#standard deviation: 0.047561519534598556
#island_id: 3
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        interacting_spins = [J[d, i//N, (j+k)%N, k] for d in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0175486}
#standard deviation: 0.04848962649928333
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  # Add new term to account for the magnetism of neighboring sites
  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = h[i//N][j].sum()
      if site_magnetism_coeff > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.006602600000000001}
#standard deviation: 0.047501848734970306
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  # Calculate the magnetism of each site
  site_magnetisms = [np.sum(h[i//N], axis=0) for i in range(N)]
  
  for i in range(N):
    for j in range(N):
      if np.sum(site_magnetisms[i]) > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(np.sum(h[i//N], axis=0).max())
          priorities[i*N*N+j*N+k][1] -= np.sum(h[i//N], axis=0).max()
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.sum(h[i//N], axis=0).min())
          priorities[i*N*N+j*N+k][1] = -np.sum(h[i//N], axis=0).min()

  return(priorities)




#score: {'data3D.txt': -0.0009021999999999992}
#standard deviation: 0.047756838203130654
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i//N][(j+k)%N][k] for k in range(N)]
          site_magnetism_coeff = sum(site_neighbors)
          if site_magnetism_coeff > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
            priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
            priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0175486}
#standard deviation: 0.04848962649928333
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = h[i//N][j].sum()
      if site_magnetism_coeff > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.014877000000000001}
#standard deviation: 0.047233880541407994
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]

  return priorities




#score: {'data3D.txt': -0.011223400000000001}
#standard deviation: 0.04679289574753843
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0][i//N][(j+k)%N][k], J[1][(i+1)%N][j][k], J[2][i][(j+1)%N][k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0087062}
#standard deviation: 0.04615158460508155
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0][i//N][(j+k)%N][k], J[1][(i+1)%N][j][k], J[2][i][(j+1)%N][k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism

  return(priorities)




#score: {'data3D.txt': -0.2656334000000001}
#standard deviation: 0.044836857655727834
#island_id: 3
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.06144140000000001}
#standard deviation: 0.04871470010212523
#island_id: 3
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_neighbors_2 = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((abs(i1-i)+abs(j1-j)+abs(k1-k)) <= 1)]
        for neighbor in site_neighbors_2:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] -= h[neighbor[0]][neighbor[1]][neighbor[2]]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] = -h[neighbor[0]][neighbor[1]][neighbor[2]]

  return(priorities)




#score: {'data3D.txt': -0.05935380000000007}
#standard deviation: 0.050837371937974926
#island_id: 3
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] -= h[neighbor[0]][neighbor[1]][neighbor[2]]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] = -h[neighbor[0]][neighbor[1]][neighbor[2]]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.1217046}
#standard deviation: 0.048340353937885064
#island_id: 3
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add a new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.08726779999999999}
#standard deviation: 0.04799577984739909
#island_id: 3
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
        else:
          spin_coeff = -np.exp(-h[i][j][k])

        priorities[i*N*N+j*N+k][0] += spin_coeff * total_spin / len(interacting_spins)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1977262000000001}
#standard deviation: 0.04786816430113025
#island_id: 3
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.11872339999999999}
#standard deviation: 0.04881164300082512
#island_id: 3
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.01029579999999999}
#standard deviation: 0.06959246153399083
#island_id: 2
#version_generated: 3
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_sum)) + total_spin_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_sum)) + total_spin_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_sum
  
  return(priorities)




#score: {'data3D.txt': -0.021903399999999996}
#standard deviation: 0.047261516569403486
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i//N][(j+k)%N][k] for k in range(N)]
          site_magnetism_coeff = sum(site_neighbors)
          if site_magnetism_coeff > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_magnetism_coeff) + total_spin
            priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(site_magnetism_coeff) + total_spin
            priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff + 2*total_spin

        for d in range(6):
          site_nbr_neighbors = [J[d][site_nbr][j][k] for k in range(N)]
          site_nbr_magnetism_coeff = sum(site_nbr_neighbors)
          if site_nbr_magnetism_coeff > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-site_nbr_magnetism_coeff) + total_spin
            priorities[i*N*N+j*N+k][1] -= site_nbr_magnetism_coeff - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(site_nbr_magnetism_coeff) + total_spin
            priorities[i*N*N+j*N+k][1] = -site_nbr_magnetism_coeff + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.013017800000000001}
#standard deviation: 0.04816300533770707
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_magnetism = h[i//N][j][k]
        if site_magnetism > 0:
          spin_coeff = np.exp(site_magnetism)
          neighbors_magnetism = sum(J[d][site_nbr][j][k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = -np.exp(site_magnetism)
          neighbors_magnetism = sum(J[d][site_nbr][j][k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.0007942000000000004}
#standard deviation: 0.04573268859754476
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i//N][(j+k)%N][k] for k in range(N)]
          site_magnetism_coeff = sum(site_neighbors)
          if site_magnetism_coeff > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff) * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*site_magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff) * (hamming_distance < 0.5) - total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0033686000000000007}
#standard deviation: 0.04679175155986363
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i+N//2)%N, (j+int(N/2))%N, k
        if h[site_nbr[0]][site_nbr[1]][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr[0]][site_nbr[1]][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr[0]][site_nbr[1]][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr[0]][site_nbr[1]][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr[0]][site_nbr[1]][k]

  return(priorities)




#score: {'data3D.txt': -0.10562860000000038}
#standard deviation: 0.052762372407237336
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array(interacting_spins) > 0) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= np.sum(np.array(interacting_spins) < 0) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array(interacting_spins) > 0) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += np.sum(np.array(interacting_spins) < 0) - total_spin
  return(priorities)




#score: {'data3D.txt': 0.0062330000000000016}
#standard deviation: 0.06035469352916972
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i//N,j,k] for d in [0,1,3,4])
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(val < 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.1707821999999998}
#standard deviation: 0.04587473512904461
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        total_spin = h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] -= np.sum(np.array(interacting_spins) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] += np.sum(np.array(interacting_spins) < 0)
  return(priorities)




#score: {'data3D.txt': 0.1161106000000001}
#standard deviation: 0.05712351291403571
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] -= np.sum(np.array(interacting_spins) < 0)
          for d in range(6):
            if J[d,i//N,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += 2
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= 2
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] += np.sum(np.array(interacting_spins) < 0)
          for d in range(6):
            if J[d,i//N,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= 2
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += 2
              priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.2166042000000001}
#standard deviation: 0.04801484793644566
#island_id: 0
#version_generated: 3
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  for d in range(6):
    interacting_spins = np.roll(h, 0, axis=d-3) if d%3 == 0 else np.roll(h, 1, axis=(d-3)%3)
    priorities += -J[d].flatten() * interacting_spins.flatten()
  return(np.array([priorities, np.zeros(N**3)]).T)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4276438}
#standard deviation: 0.04693189578058828
#island_id: 1
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4188498}
#standard deviation: 0.047569521754585675
#island_id: 1
#version_generated: 3
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += total_spin + (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= total_spin - (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 2
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.012043000000000002}
#standard deviation: 0.046935314114214685
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d][site_nbr][(j+k)%N][k] for d in [0, 1, 2, 3, 4, 5]) + h[i//N][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([1 if J[d][site_nbr][(j+k)%N][k] < 0 else 0 for d in [0, 1, 2, 3, 4, 5]]) + 1
          priorities[i*N*N+j*N+k][1] -= np.sum([1 if J[d][site_nbr][(j+k)%N][k] > 0 else 0 for d in [0, 1, 2, 3, 4, 5]]) - 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([1 if J[d][site_nbr][(j+k)%N][k] < 0 else 0 for d in [0, 1, 2, 3, 4, 5]]) + 1
          priorities[i*N*N+j*N+k][1] = -np.sum([1 if J[d][site_nbr][(j+k)%N][k] > 0 else 0 for d in [0, 1, 2, 3, 4, 5]]) + 1
  return(priorities)




#score: {'data3D.txt': -0.06635340000000003}
#standard deviation: 0.05824685011603634
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([2*(val>0) for val in interacting_spins]) / max(len(interacting_spins),1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([2*(val<0) for val in interacting_spins]) / max(len(interacting_spins),1)
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)




#score: {'data3D.txt': -0.06871020000000001}
#standard deviation: 0.05128261202356995
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        total_spin = sum(interacting_spins) + h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)




#score: {'data3D.txt': -0.0042034}
#standard deviation: 0.046899040805116685
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][site_nbr//N][(j+k)%N][k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(interacting_spins) + h[i//N][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - 2*len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)




#score: {'data3D.txt': -0.4222546}
#standard deviation: 0.0457440507480481
#island_id: 1
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.021133000000000002}
#standard deviation: 0.04815520024877895
#island_id: 1
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priority_total = 0

        # Add the magnetism term
        priority_total += h[i][j][k]

        # Add the interaction terms from the six neighboring sites
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priority_total += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][0] = priority_total
        priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)




#score: {'data3D.txt': -0.4172518}
#standard deviation: 0.047226729685211105
#island_id: 1
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.38098940000000037}
#standard deviation: 0.04526359163433675
#island_id: 1
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a new term to account for the magnetism of the site itself and its neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if (h[i][j][k] > 0).any():
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(h[(i-1)%N:(i+2)%N,(j-1)%N:(j+2)%N,k]))
          priorities[i*N*N+j*N+k][1] -= np.sum(h[(i-1)%N:(i+2)%N,(j-1)%N:(j+2)%N,k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(h[(i-1)%N:(i+2)%N,(j-1)%N:(j+2)%N,k]))
          priorities[i*N*N+j*N+k][1] = -np.sum(h[(i-1)%N:(i+2)%N,(j-1)%N:(j+2)%N,k])

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  # Add a new term to account for the interactions with the nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.45087380000000016}
#standard deviation: 0.0471720268120843
#island_id: 1
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.21740860000000026}
#standard deviation: 0.04648425761524003
#island_id: 1
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a term to account for the priority of assigning spins based on the site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.41313459999999996}
#standard deviation: 0.039113872767088664
#island_id: 1
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  # Add a new term to account for the interaction between neighboring sites
  interacting_sites = [i-1, i+1, j-1, j+1, k-1, k+1]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_values = [h[i+n][j+m][k+p] if (0 <= i+n < N) and (0 <= j+m < N) and (0 <= k+p < N) else 0 for n, m, p in zip(interacting_sites, interacting_sites, interacting_sites)]
        total_site_spin = sum(site_nbr_values)
        magnetism_coeff = np.exp(-abs(total_site_spin))
        hamming_distance = len([val for val in site_nbr_values if val < 0]) / max(len(site_nbr_values), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_site_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1185334}
#standard deviation: 0.044645160145753766
#island_id: 1
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term to account for the interactions with neighboring sites
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(J[d, i, j, k])
            priorities[i*N*N+j*N+k][1] -= J[d, i, j, k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-J[d, i, j, k])
            priorities[i*N*N+j*N+k][1] += J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.36216139999999997}
#standard deviation: 0.039069746736317607
#island_id: 2
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(np.sum(J[:,i,j,k])))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism_coeff + np.sum(J[:,i,j,k])
        priorities[i*N*N+j*N+k][1] -= 2 - 2*np.sum(J[:,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': 0.17591340000000003}
#standard deviation: 0.05641153623541908
#island_id: 1
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_energy = total_spin + magnetism_coeff * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy

  return(priorities)




#score: {'data3D.txt': -0.4410802}
#standard deviation: 0.04618616424818152
#island_id: 3
#version_generated: 3
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        spin_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_coeff * (h[i][j][k] > 0) + total_spin / len(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4410802}
#standard deviation: 0.04618616424818152
#island_id: 3
#version_generated: 3
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        spin_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_coeff * (h[i][j][k] > 0) + total_spin / len(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.0038394}
#standard deviation: 0.04800669877881628
#island_id: 2
#version_generated: 3
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.4559994}
#standard deviation: 0.042907431053839616
#island_id: 0
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(J[d,i,j,k] for d in [3,4,5]) 
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(J[d,i,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3964698}
#standard deviation: 0.043416329277818966
#island_id: 1
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_energy = total_spin + magnetism_coeff * (hamming_distance > 0.5)
        site_magnetism = h[i][j][k]
        neighbor_magnetism = np.sum(h[max(i-1,0):(i+2)%N,max(j-1,0):(j+2)%N,k])
        priorities[i*N*N+j*N+k][0] += spin_energy + magnetism_coeff * site_magnetism + neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy

  return(priorities)




#score: {'data3D.txt': -0.38487540000000015}
#standard deviation: 0.049377708683575015
#island_id: 1
#version_generated: 3
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        spin_energy = total_spin + magnetism_coeff * (hamming_distance > 0.5) - abs(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_energy
        priorities[i*N*N+j*N+k][1] -= spin_energy

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2346898}
#standard deviation: 0.046805589153006075
#island_id: 3
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, site_nbr, j, k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (sum([J[d, site_nbr, j, k] < 0 for d in range(6)]) / max(len([J[d, site_nbr, j, k] for d in range(6)]), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (sum([J[d, site_nbr, j, k] > 0 for d in range(6)]) / max(len([J[d, site_nbr, j, k] for d in range(6)]), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.40775500000000003}
#standard deviation: 0.04334005739497814
#island_id: 3
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add new term to account for the interactions with the site's neighbors
        if i > 0:
          if h[i-1][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i-1][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i-1][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i-1][j][k])
            priorities[i*N*N+j*N+k][1] += h[i-1][j][k]

        if j > 0:
          if h[i][j-1][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j-1][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j-1][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j-1][k])
            priorities[i*N*N+j*N+k][1] += h[i][j-1][k]

        if k > 0:
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k-1])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k-1]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k-1])
            priorities[i*N*N+j*N+k][1] += h[i][j][k-1]

  return(priorities)




#score: {'data3D.txt': -0.018287400000000002}
#standard deviation: 0.04800993815076208
#island_id: 3
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.018287400000000002}
#standard deviation: 0.04800993815076208
#island_id: 3
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.34187419999999963}
#standard deviation: 0.044984548173345025
#island_id: 1
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add new term to account for the interactions with the nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4507406000000001}
#standard deviation: 0.041590690684815516
#island_id: 1
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term to account for the interactions with the nearest neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= sum(site_neighbors)
        
        # Add a new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3303926000000002}
#standard deviation: 0.049532120338624704
#island_id: 1
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the interactions with the nearest neighbors
  for d in range(3):
    for i in range(N):
      for j in range(N):
        site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(site_neighbors)
        priorities[i*N*N+j*N+k][1] -= sum(site_neighbors)
  
  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.12243540000000012}
#standard deviation: 0.052587364136644096
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i//N,(j+k)%N,k] for d in [0,1,2,3,4,5]) + h[i][j][k]
        if J[0][i//N][(j+k)%N][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 + 2*total_spin
          priorities[i*N*N+j*N+k][1] = total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,(j+k)%N,k] for d in [0,1,2,3,4,5]]
        total_spin = sum(interacting_spins) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.12772660000000013}
#standard deviation: 0.049700408976586924
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i//N,(j+k)%N,k] for d in [0,1,2,3,4,5]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.026780199999999997}
#standard deviation: 0.04880050704613632
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i//N,(j+k)%N,k] for d in [0,1,2,3,4,5]) + h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 + 2*abs(total_spin)
          priorities[i*N*N+j*N+k][1] = abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.0038394}
#standard deviation: 0.04800669877881628
#island_id: 2
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0038394}
#standard deviation: 0.04800669877881628
#island_id: 2
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.11164859999999999}
#standard deviation: 0.04791820528817831
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(J[d,i,j,k] for d in [3,4,5]) 
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(J[d,i,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  # Add interactions along the diagonal
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] = -2

  return(priorities)




#score: {'data3D.txt': 0.45245420000000003}
#standard deviation: 0.04329798958797047
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(J[d,i,j,k] for d in [3,4,5]) 
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(J[d,i,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin
        
  # Apply a simple heuristic to swap spins that are not aligned with the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = max(priorities[i*N*N+j*N+k][0], -priorities[i*N*N+j*N+k][1])
        else:
          priorities[i*N*N+j*N+k][0] = min(priorities[i*N*N+j*N+k][0], -priorities[i*N*N+j*N+k][1])

  return(priorities)




#score: {'data3D.txt': 0.37858939999999996}
#standard deviation: 0.048061553113065335
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(J[d,i,j,k] for d in [3,4,5]) 
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(J[d,i,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  # Calculate the priority based on the site interaction and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= 2 * sum(h[d][i][j] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][1] += 2 * sum(h[d][i][j] for d in [0,1,2])

  return(priorities)




#score: {'data3D.txt': 0.08456859999999995}
#standard deviation: 0.17495073733494246
#island_id: 1
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a term to account for the priority of assigning spins based on the site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  # Add a term to account for the priority of assigning spins based on the site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.311305}
#standard deviation: 0.15221947409907846
#island_id: 1
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a term to account for the priority of assigning spins based on the site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  # Add a term to account for the priority of assigning spins based on the site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.44752179999999997}
#standard deviation: 0.04162196060687195
#island_id: 1
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the priority of assigning spins based on the site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5) + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0066202000000000006}
#standard deviation: 0.0476607422514589
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.013448600000000002}
#standard deviation: 0.047827863824762236
#island_id: 3
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          site_magnetism = np.exp(h[i//N][j][k])
          spin_alignment += total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] += site_magnetism * spin_alignment
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          site_magnetism = -np.exp(h[i//N][j][k])
          spin_alignment += total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= site_magnetism * spin_alignment
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.012356999999999993}
#standard deviation: 0.04290347714346705
#island_id: 2
#version_generated: 3
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0038394}
#standard deviation: 0.04800669877881628
#island_id: 2
#version_generated: 3
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0086758}
#standard deviation: 0.04767302354959249
#island_id: 2
#version_generated: 3
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  total_spin_sum = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  # Calculate interacting spins
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  # Iterate over all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17932980000000034}
#standard deviation: 0.04883832994646725
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interactions with the nearest neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.2817098000000002}
#standard deviation: 0.05012462931493858
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[(d+3)%6,(i+1)%N,j,k]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
            priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
            priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.34187419999999963}
#standard deviation: 0.044984548173345025
#island_id: 1
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interactions with the nearest neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0085578}
#standard deviation: 0.04679720524945907
#island_id: 3
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          if J[d][i//N][(j+k)%N][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(J[d][i//N][(j+k)%N][k])
            priorities[i*N*N+j*N+k][1] -= J[d][i//N][(j+k)%N][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-J[d][i//N][(j+k)%N][k])
            priorities[i*N*N+j*N+k][1] = -J[d][i//N][(j+k)%N][k]

  return(priorities)




#score: {'data3D.txt': -0.09351260000000007}
#standard deviation: 0.04549497028507657
#island_id: 3
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i+N//2)%N, (j+int(N/2))%N, k)
        if h[site_nbr[0]][site_nbr[1]][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr[0]][site_nbr[1]][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr[0]][site_nbr[1]][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr[0]][site_nbr[1]][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr[0]][site_nbr[1]][k]
        
        site_nbr = ((i+((k-1)%2)-1))%N, j
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr[0]][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr[0]][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr[0]][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr[0]][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.0005922000000000001}
#standard deviation: 0.04791316290081464
#island_id: 3
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_nbr = (i+N//2)%N, (j+int(N/2))%N, k
          if h[site_nbr[0]][site_nbr[1]][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr[0]][site_nbr[1]][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr[0]][site_nbr[1]][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr[0]][site_nbr[1]][k])
            priorities[i*N*N+j*N+k][1] = -h[site_nbr[0]][site_nbr[1]][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i//N][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i//N][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': 0.1008666}
#standard deviation: 0.048160526621290174
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(J[d,i,j,k] for d in [3,4,5]) 
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(J[d,i,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin
  
  # Add interactions along the diagonal and neighbor sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] = -2
        
  # Add neighbor site interactions
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += sum(J[d,i,j,k] for d in [3,4,5])
        priorities[i*N*N+j*N+k][1] -= 2
      else:
        priorities[i*N*N+j*N+k][0] -= sum(J[d,i,j,k] for d in [3,4,5])
        priorities[i*N*N+j*N+k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.2518954000000002}
#standard deviation: 0.04597652160440152
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in [3,4,5]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in [3,4,5]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin + sum(val for val in site_neighbors if val > 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.03158299999999995}
#standard deviation: 0.3308813841711252
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (2*h[i][j][k]*np.exp(-abs(total_spin_sum)) + total_spin_sum)**3
          priorities[i*N*N+j*N+k][1] -= 4 - 8*total_spin_sum + 4*(total_spin_sum**2)
        else:
          priorities[i*N*N+j*N+k][0] -= (2*h[i][j][k]*np.exp(-abs(total_spin_sum)) + total_spin_sum)**3
          priorities[i*N*N+j*N+k][1] = -4 + 8*total_spin_sum - 4*(total_spin_sum**2)
  
  return(priorities)




#score: {'data3D.txt': -0.01029579999999999}
#standard deviation: 0.06959246153399083
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_sum)) + total_spin_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_sum)) + total_spin_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_sum

  return(priorities)




#score: {'data3D.txt': -0.011524199999999993}
#standard deviation: 0.06958548680838553
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_sum)) + total_spin_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_sum)) + total_spin_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_sum
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += 1
        priorities[i*N*N+j*N+k][1] -= 1
      else:
        priorities[i*N*N+j*N+k][0] -= 1
        priorities[i*N*N+j*N+k][1] = 1
  
  return(priorities)




#score: {'data3D.txt': -0.31564459999999966}
#standard deviation: 0.11456413003571395
#island_id: 2
#version_generated: 3
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  # Calculate total spin sum for each site
  total_spin_sum = 0
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_sum += sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
  
  # Calculate priorities based on total spin sum
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -abs(total_spin_sum) + total_spin_sum**2
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] = abs(total_spin_sum) - total_spin_sum**2
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin_sum
  
  return(priorities)




#score: {'data3D.txt': -0.33887859999999975}
#standard deviation: 0.044893493760677604
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interactions with the nearest neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.10373899999999998}
#standard deviation: 0.04909773761590242
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interactions with the nearest neighbors
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
        priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3393245999999997}
#standard deviation: 0.04525650400594371
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add new term to account for the interactions with the nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  # Add new term to account for the interactions with the farthest neighbors
  for i in range(N):
    for j in range(N):
      if i < N-2:
        site_neighbors = [J[3,(i+2)%N,j,k]]
      else:
        site_neighbors = []
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
        priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
        priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.34187419999999963}
#standard deviation: 0.044984548173345025
#island_id: 1
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interactions with the nearest neighbors
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)]))
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)])

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0016542}
#standard deviation: 0.20210891613771026
#island_id: 2
#version_generated: 3
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin sum for each site
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.012356999999999993}
#standard deviation: 0.04290347714346705
#island_id: 2
#version_generated: 3
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.03752979999999997}
#standard deviation: 0.04251780417613308
#island_id: 2
#version_generated: 3
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.434161}
#standard deviation: 0.03979404728096905
#island_id: 1
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the interaction between neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_values = [h[(i+n)%N][(j+m)%N][(k+p)%N] if (0 <= n < N) and (0 <= m < N) and (0 <= p < N) else 0 for n, m, p in zip([-1, 0, 1], [-1, 0, 1], [-1, 0, 1])]
        total_site_spin = sum(site_nbr_values)
        magnetism_coeff = np.exp(-abs(total_site_spin))
        hamming_distance = len([val for val in site_nbr_values if val < 0]) / max(len(site_nbr_values), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_site_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41228420000000005}
#standard deviation: 0.03939342267891939
#island_id: 1
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add a new term to account for the interaction between neighboring sites
        interacting_sites = [i-1, i+1, j-1, j+1, k-1, k+1]
        site_nbr_values = []
        for n, m, p in zip(interacting_sites, interacting_sites, interacting_sites):
          if (0 <= i+n < N) and (0 <= j+m < N) and (0 <= k+p < N):
            site_nbr_values.append(h[i+n][j+m][k+p])
          else:
            site_nbr_values.append(0)
        total_site_spin = sum(site_nbr_values)
        magnetism_coeff = np.exp(-abs(total_site_spin))
        hamming_distance = len([val for val in site_nbr_values if val < 0]) / max(len(site_nbr_values), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_site_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_spin
        
        # Add a new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.41313459999999996}
#standard deviation: 0.039113872767088664
#island_id: 1
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  # Add a new term to account for the interaction between neighboring sites
  interacting_sites = [i-1, i+1, j-1, j+1, k-1, k+1]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_values = [h[i+n][j+m][k+p] if (0 <= i+n < N) and (0 <= j+m < N) and (0 <= k+p < N) else 0 for n, m, p in zip(interacting_sites, interacting_sites, interacting_sites)]
        total_site_spin = sum(site_nbr_values)
        magnetism_coeff = np.exp(-abs(total_site_spin))
        hamming_distance = len([val for val in site_nbr_values if val < 0]) / max(len(site_nbr_values), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_site_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3338278}
#standard deviation: 0.03953575074739318
#island_id: 1
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  # Add a new term to account for the interaction between neighboring sites
  interacting_sites = [i-1, i+1, j-1, j+1, k-1, k+1]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_values = [h[i+n][j+m][k+p] if (0 <= i+n < N) and (0 <= j+m < N) and (0 <= k+p < N) else 0 for n, m, p in zip(interacting_sites, interacting_sites, interacting_sites)]
        total_site_spin = sum(site_nbr_values)
        magnetism_coeff = np.exp(-abs(total_site_spin))
        hamming_distance = len([val for val in site_nbr_values if val < 0]) / max(len(site_nbr_values), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_site_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_spin
        
  # Add a new term to account for the interaction between neighboring sites in a more efficient way
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_values = [h[(i+di)%N][(j+dj)%N][k] if (0 <= i+di < N) and (0 <= j+dj < N) else 0 for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]]
        total_site_spin = sum(site_nbr_values)
        magnetism_coeff = np.exp(-abs(total_site_spin))
        hamming_distance = len([val for val in site_nbr_values if val < 0]) / max(len(site_nbr_values), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_site_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.019955399999999998}
#standard deviation: 0.04618133011120403
#island_id: 3
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0049642}
#standard deviation: 0.21218564182894187
#island_id: 2
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin sum for each site
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0.5:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif total_spin < -0.5:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < -0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < -0.5) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0693562}
#standard deviation: 0.06826741332114467
#island_id: 2
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0029425999999999996}
#standard deviation: 0.04752523819235417
#island_id: 2
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += -2*np.exp(-abs(total_spin)) * (total_spin > 1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin > 1.5) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -2*np.exp(-abs(total_spin)) * (total_spin < -1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(-abs(total_spin)) * (total_spin < -1.5) + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1601138}
#standard deviation: 0.040340292135283305
#island_id: 1
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        # Update priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in interacting_spins if val < 0) / len(interacting_spins) > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in interacting_spins if val < 0) / len(interacting_spins) > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Update priority based on site interactions and magnetism
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val for val in site_neighbors if val < 0) / len(site_neighbors) > sum(val for val in interacting_spins if val < 0) / len(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add a new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3175646000000001}
#standard deviation: 0.09211815796486597
#island_id: 1
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a term to account for the priority of assigning spins based on the site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  # Add a new term to account for the priority of assigning spins based on the site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin - 2*magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin + 2*magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0722306}
#standard deviation: 0.04329224484408265
#island_id: 1
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a term to account for the priority of assigning spins based on the site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin

  # Add a new term to account for the interaction with the neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_spins = [J[d,i,(j+1)%N,k] for d in range(6)]
        total_spin_neighbor = sum(site_nbr_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(total_spin_neighbor)
        priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin_neighbor

  # Add a new term to account for the interaction with the neighboring sites in the z-direction
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_spins = [J[d,i,j,(k+1)%N] for d in range(6)]
        total_spin_neighbor = sum(site_nbr_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(total_spin_neighbor)
        priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin_neighbor

  return(priorities)




#score: {'data3D.txt': -0.38956460000000004}
#standard deviation: 0.04373811503528702
#island_id: 3
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.019955399999999998}
#standard deviation: 0.04618133011120403
#island_id: 3
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.019955399999999998}
#standard deviation: 0.04618133011120403
#island_id: 3
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.044106999999999986}
#standard deviation: 0.047856128040199834
#island_id: 0
#version_generated: 2
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            neighbor_magnetism_coeff = np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 0
#version_generated: 2
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the site's priority based on its magnetism and interaction with neighbors
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add the site's magnetism to its priority
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.14463220000000002}
#standard deviation: 0.16227826805570722
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the interactions with the nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)])) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)]) - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)])) * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)]) + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43872500000000003}
#standard deviation: 0.0396638930893073
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.029613399999999953}
#standard deviation: 0.2767694048489464
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a new term to account for the site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5) + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*total_spin
        
  # Add a new term to account for the interactions with the nearest neighbors and the site magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(sum([J[d,i,j,k] for d in range(6)])) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= sum([J[d,i,j,k] for d in range(6)]) - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum([J[d,i,j,k] for d in range(6)])) - np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -sum([J[d,i,j,k] for d in range(6)]) + h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2485122000000002}
#standard deviation: 0.057960719208443125
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the priority of assigning spins based on the site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5) + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': 0.11640700000000001}
#standard deviation: 0.047387146685572874
#island_id: 0
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            neighbor_magnetism_coeff = np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1 + total_spin
        
        # Add new term to account for the interaction with neighboring sites
        if i > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += h[i-1][j][k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += h[i][j-1][k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += h[i][j][k-1]
        
  return(priorities)




#score: {'data3D.txt': 0.044106999999999986}
#standard deviation: 0.047856128040199834
#island_id: 0
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            neighbor_magnetism_coeff = np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.427419}
#standard deviation: 0.03990190771128618
#island_id: 0
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.17300420000000008}
#standard deviation: 0.04693638441933934
#island_id: 3
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance < 0.5) + total_spin) * np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(4*h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 8 - 8*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-4*h[i][j][k]) * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -8 + 8*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5045286}
#standard deviation: 0.04213959541856092
#island_id: 3
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.074185}
#standard deviation: 0.04964564165160926
#island_id: 3
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
          
  return priorities




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 0
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0693562}
#standard deviation: 0.06826741332114467
#island_id: 2
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36216139999999997}
#standard deviation: 0.039069746736317607
#island_id: 2
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism_coeff + total_spin_sum[i,j,k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum[i,j,k]
  
  return(priorities)




#score: {'data3D.txt': -0.10054660000000001}
#standard deviation: 0.0873478969892235
#island_id: 2
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  site_nbr = lambda i, j, k: ((i + ((k-1)%2 - 1)) % N)
  
  total_spin = np.zeros((N**3,))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(h[i][j][k]))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        
        total_spin[i*N*N+j*N+k] += h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism_coeff + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in range(6))
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism_coeff + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
          priorities[i*N*N+j*N+k][1] = 2 - 2*sum(J[d,i,j,k] for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 0
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.198153}
#standard deviation: 0.045940800939905276
#island_id: 0
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 0
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 0
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14511860000000001}
#standard deviation: 0.04789802223516123
#island_id: 3
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        
        # Add new term to account for the interaction with the site above
        if j > 0 and h[i][j-1][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j-1][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j-1][k]
        elif j > 0 and h[i][j-1][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j-1][k]) * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j-1][k]
        
        # Add new term to account for the interaction with the site below
        if j < N-1 and h[i][j+1][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j+1][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j+1][k]
        elif j < N-1 and h[i][j+1][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j+1][k]) * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j+1][k]
        
        # Add new term to account for the interaction with the site left
        if i > 0 and h[i-1][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i-1][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i-1][j][k]
        elif i > 0 and h[i-1][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i-1][j][k]) * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i-1][j][k]
        
        # Add new term to account for the interaction with the site right
        if i < N-1 and h[i+1][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i+1][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i+1][j][k]
        elif i < N-1 and h[i+1][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i+1][j][k]) * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -4 + 4*h[i+1][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.17300420000000008}
#standard deviation: 0.04693638441933934
#island_id: 3
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance < 0.5) + total_spin) * np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(4*h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 8 - 8*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-4*h[i][j][k]) * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -8 + 8*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.11303859999999996}
#standard deviation: 0.05587738997161553
#island_id: 3
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction with the site itself
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 4 + 4*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction with the site itself
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin - np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 4 - 4*h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.198153}
#standard deviation: 0.045940800939905276
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

  return(priorities)




#score: {'data3D.txt': -0.03432220000000032}
#standard deviation: 0.05130081156434078
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
  
  return(priorities)




#score: {'data3D.txt': -0.0484378}
#standard deviation: 0.04373395718614999
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
    
  return(priorities)




#score: {'data3D.txt': -0.18458259999999999}
#standard deviation: 0.046946673335178934
#island_id: 0
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] += 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] -= 1
      else:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] -= 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.06720379999999997}
#standard deviation: 0.04284611657501763
#island_id: 2
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-3] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.012356999999999993}
#standard deviation: 0.04290347714346705
#island_id: 2
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1092946}
#standard deviation: 0.046162531677108
#island_id: 0
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        
        site = h[i][j][k]
        if site > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(site)
          priorities[i*N*N+j*N:k+1, 1] -= site
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-site)
          priorities[i*N*N+j*N:k+1, 1] += site
  
  return(priorities)




#score: {'data3D.txt': -0.083129}
#standard deviation: 0.04574937856408543
#island_id: 0
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4142202}
#standard deviation: 0.05010073644129395
#island_id: 0
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        
        if h[i][j].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.083129}
#standard deviation: 0.04574937856408543
#island_id: 0
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.192087}
#standard deviation: 0.04527336072128951
#island_id: 0
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3167230000000001}
#standard deviation: 0.05019773332532058
#island_id: 0
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
  for i in range(N):
    for j in range(N):
      if h[i].sum() > 0:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] += 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] -= 1
      else:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] -= 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.03411340000000003}
#standard deviation: 0.04965009788953089
#island_id: 2
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)  

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(np.sum(J[:,i,j,k])))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j]*np.ones((N,1))) + J[:,i,j,k].sum()
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + np.sum(J[d,i,j,k])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.sum(J[d,i,j,k] if J[d,i,j,k] < 0 else -J[d,i,j,k])

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
 
  return(priorities)




#score: {'data3D.txt': -0.5045286}
#standard deviation: 0.04213959541856092
#island_id: 3
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
  
  return(priorities)




#score: {'data3D.txt': -0.5045286}
#standard deviation: 0.04213959541856092
#island_id: 3
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47244380000000014}
#standard deviation: 0.0449526164039425
#island_id: 3
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priority_coeff = np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance + total_spin + site_interaction + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priority_coeff = np.exp(-h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance + total_spin + site_interaction + priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.37223500000000037}
#standard deviation: 0.048882169499726576
#island_id: 0
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4815286000000001}
#standard deviation: 0.041999119776966756
#island_id: 1
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.06720379999999997}
#standard deviation: 0.04284611657501763
#island_id: 2
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        interacting_spins = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-3] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': 0.0086758}
#standard deviation: 0.04767302354959249
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  total_spin_sum = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_count = np.zeros((N**2, 2), dtype=int)
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin_count[i*N+j][0] += J[d,i,j,k]*h[site_nbr,j,k]
          total_spin_count[i*N+j][1] -= J[d,i,j,k]*(h[site_nbr,j,k] > 0) - (1-J[d,i,j,k])*(h[site_nbr,j,k] < 0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.008765799999999989}
#standard deviation: 0.04905076299467726
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  total_spin_sum = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  # Calculate interacting spins
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  # Iterate over all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Calculate priority for each site based on the magnetism and interaction with neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [3,4,5])
        else:
          priorities[i*N*N+j*N+k][0] -= sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [3,4,5])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [3,4,5])

  return(priorities)




#score: {'data3D.txt': -0.17130219999999982}
#standard deviation: 0.04602278126276159
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  total_spin_sum = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum_interacting = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
  
  return(priorities)




#score: {'data3D.txt': 0.0086758}
#standard deviation: 0.04767302354959249
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  total_spin_sum = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  # Iterate over all sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40999780000000013}
#standard deviation: 0.0444969045570588
#island_id: 1
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5236882}
#standard deviation: 0.04163072351953543
#island_id: 1
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.23736820000000028}
#standard deviation: 0.045620747788259676
#island_id: 3
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priority_coeff = np.exp(h[i][j][k])
          
          spin_probability = np.exp(total_spin)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance + site_interaction + priority_coeff * spin_probability
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priority_coeff = np.exp(-h[i][j][k])
          
          spin_probability = np.exp(-total_spin)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance + site_interaction + priority_coeff * spin_probability
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return priorities




#score: {'data3D.txt': 0.074185}
#standard deviation: 0.04964564165160926
#island_id: 3
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5044181999999999}
#standard deviation: 0.043059656626127436
#island_id: 3
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          site_interaction = -np.sum([J[d,i,j,k] * (d == 2) for d in [0,1,2]])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance + total_spin + site_interaction
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 3
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_interaction = np.sum([J[d,i,j,k] for d in [0,1,2]])
          
          if site_interaction > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_interaction = np.sum([J[d,i,j,k] for d in [0,1,2]])
          
          if site_interaction < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*total_spin
          
  return priorities




#score: {'data3D.txt': -0.5112190000000001}
#standard deviation: 0.039706500210922646
#island_id: 1
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5112190000000001}
#standard deviation: 0.039706500210922646
#island_id: 1
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.39470500000000003}
#standard deviation: 0.04049212139416754
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4624386000000001}
#standard deviation: 0.04207374371315203
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Check if the current site has same spin as one of its neighbors
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.4692026000000001}
#standard deviation: 0.04219494321882659
#island_id: 1
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add term to account for the interaction between current site and its diagonal neighboring sites
        for d in range(3):
          site_diagonal_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          if any(val == h[i][j][k] for val in site_diagonal_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0484378}
#standard deviation: 0.04373395718614999
#island_id: 0
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag

  return(priorities)




#score: {'data3D.txt': -0.0484378}
#standard deviation: 0.04373395718614999
#island_id: 0
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += priority_plus
          priorities[i*N*N+j*N+k][1] -= 2 - priority_plus
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= priority_minus
          priorities[i*N*N+j*N+k][1] = 2 - priority_minus
  
  return(priorities)




#score: {'data3D.txt': -0.3899710000000001}
#standard deviation: 0.043828842546889145
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Loop through each site in the lattice
  for i in range(N):
    for j in range(N):
      for k in range(N):
        # Calculate total spin and hamming distance at this site
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient based on site's magnetic field
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Set priority for each spin direction based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.214155}
#standard deviation: 0.04381857248929956
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * np.exp(2*h[i][j][k]) + priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) * np.exp(-2*h[i][j][k]) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.38956460000000004}
#standard deviation: 0.04373811503528702
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        if h[i][j][k] == 0:
          site_nbr_hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (site_nbr_hamming_distance > 0.5) * np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3978917999999999}
#standard deviation: 0.040645870795936956
#island_id: 3
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + priority_total + np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + priority_total - np.exp(-2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.37223500000000037}
#standard deviation: 0.048882169499726576
#island_id: 0
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
  return(priorities)




#score: {'data3D.txt': -0.37223500000000037}
#standard deviation: 0.048882169499726576
#island_id: 0
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
  return(priorities)




#score: {'data3D.txt': -0.10388220000000006}
#standard deviation: 0.04845436289086877
#island_id: 2
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10707660000000013}
#standard deviation: 0.21866661147152758
#island_id: 2
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.0112958}
#standard deviation: 0.047220026920365046
#island_id: 1
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add term to account for the interaction between current site and its diagonal neighboring sites
        for d in range(3):
          site_diagonal_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
        
        # Add term to account for the interaction between current site and its non-diagonal neighboring sites
        for d in range(3):
          site_non_diagonal_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in site_non_diagonal_neighbors if val < 0]))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in site_non_diagonal_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.46400939999999996}
#standard deviation: 0.04112723904713274
#island_id: 1
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction between current site and its diagonal neighboring sites
        for d in range(3):
          site_diagonal_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          if any(val == h[i][j][k] for val in site_diagonal_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
        
        # Add term to account for the interaction between current site and its neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in site_neighbors if val < 0]))
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add term to account for the interaction between current site and its same-spin neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in site_neighbors if val < 0]))
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.481509}
#standard deviation: 0.03973738591049995
#island_id: 1
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add term to account for the interaction between current site and its diagonal neighboring sites
        for d in range(3):
          site_diagonal_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          if any(val == h[i][j][k] for val in site_diagonal_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in site_diagonal_neighbors if val < 0]))
        
        # Check if current site has same spin as its diagonal neighboring sites
        if all(val == h[i][j][k] for val in [J[0,i,(j+1)%N,k], J[2,i,(j+1)%N,k]]):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[2,i,(j+1)%N,k]] if val < 0]))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in [J[0,i,(j+1)%N,k], J[2,i,(j+1)%N,k]] if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0484378}
#standard deviation: 0.04373395718614999
#island_id: 0
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
  
  return(priorities)




#score: {'data3D.txt': 0.04953539999999999}
#standard deviation: 0.07539913173797162
#island_id: 0
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag

        if h[i].sum() > 0:
          for d in range(6):
            site_neighbors = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            total_spin_mag = -total_spin
            priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * priority_mag
            priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          for d in range(6):
            site_neighbors = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin))
            hamming_distance = len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1)
            total_spin_mag = -total_spin
            priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * priority_mag
            priorities[i*N*N+j*N+k][1] = -2 - priority_mag

  return(priorities)




#score: {'data3D.txt': -0.3497554}
#standard deviation: 0.0530246219301939
#island_id: 0
#version_generated: 3
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[3+d][i][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        
        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.074185}
#standard deviation: 0.04964564165160926
#island_id: 3
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]

  return priorities




#score: {'data3D.txt': 0.074185}
#standard deviation: 0.04964564165160926
#island_id: 3
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_spin = J[3,i,j,k]
          if site_spin < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k]) * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 4 - 4*h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-2*h[i][j][k]) * (hamming_distance < 0.5)
            priorities[i*N*N+j*N+k][1] = -4 + 4*h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.17130219999999982}
#standard deviation: 0.04602278126276159
#island_id: 2
#version_generated: 3
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  total_spin_sum = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum_interacting = sum(sum(J[d,i,j,k]*h[i][j][k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.16851459999999985}
#standard deviation: 0.045918394863496685
#island_id: 2
#version_generated: 3
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_sum_neighbor = sum(J[d,i,j,k]*h[site_nbr][j][k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_sum_neighbor)) * (total_spin_sum_neighbor < 0.5) + total_spin_sum_neighbor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum_neighbor
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_sum_neighbor)) * (total_spin_sum_neighbor > 0.5) + total_spin_sum_neighbor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_sum_neighbor
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.03752979999999997}
#standard deviation: 0.04251780417613308
#island_id: 2
#version_generated: 3
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.012356999999999993}
#standard deviation: 0.04290347714346705
#island_id: 2
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        site = h[i][j][k]
        if site > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(site)
          priorities[i*N*N+j*N:k+1, 1] -= site
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-site)
          priorities[i*N*N+j*N:k+1, 1] += site
        
  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        site = h[i][j][k]
        if site > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(site)
          priorities[i*N*N+j*N:k+1, 1] -= site
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-site)
          priorities[i*N*N+j*N:k+1, 1] += site
  
  return(priorities)




#score: {'data3D.txt': -0.36883900000000003}
#standard deviation: 0.041256022578527854
#island_id: 1
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Check if the current site has same spin as one of its neighbors
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.38865700000000003}
#standard deviation: 0.04088192352372868
#island_id: 1
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
          
          # Check if any of the neighboring sites have same spin as current site
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            if any(val == h[i][j][k] for val in site_neighbors):
              priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
          
        # Check if the current site has same spin as one of its neighbors
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
  
  return priorities




#score: {'data3D.txt': -0.36748300000000006}
#standard deviation: 0.04130438270934454
#island_id: 1
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        
        # Check if any of the neighboring sites have same spin as current site
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
        
        # Check if the current site has same spin as one of its neighbors
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if any(val == h[i][j][k] for val in site_neighbors):
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.4810074}
#standard deviation: 0.04333521599392347
#island_id: 1
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.5236882}
#standard deviation: 0.04163072351953543
#island_id: 1
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = total_spin * (hamming_distance > 0.5) - 2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_moment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(np.sum(J[:,i,j,k])))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        total_spin = h[i][j][k]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]] if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
          
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin - 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': 0.03411340000000003}
#standard deviation: 0.04965009788953089
#island_id: 2
#version_generated: 3
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(np.sum(J[:,i,j,k])))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j]*np.ones((N,1))) + J[:,i,j,k].sum()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + np.sum(J[d,i,j,k])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.sum(J[d,i,j,k] if J[d,i,j,k] < 0 else -J[d,i,j,k])
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
 
  return(priorities)




#score: {'data3D.txt': -0.071361}
#standard deviation: 0.04731386391957435
#island_id: 0
#version_generated: 3
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.31231380000000003}
#standard deviation: 0.04824623228356801
#island_id: 0
#version_generated: 3
#generate time14:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.20903019999999997}
#standard deviation: 0.12012011891419355
#island_id: 0
#version_generated: 3
#generate time14:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
  for i in range(N):
    if h[i].sum() > 0:
      priorities[i*N*N+N*(N-1):, :].T[0] += 1
      priorities[i*N*N+N*(N-1):, :].T[1] -= 1
    else:
      priorities[i*N*N+N*(N-1):, :].T[0] -= 1
      priorities[i*N*N+N*(N-1):, :].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0659606}
#standard deviation: 0.04995941080156971
#island_id: 0
#version_generated: 3
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
      for i in range(N):
        if h[i].sum() > 0:
          priorities[i*N*N:N*(N+1),:].T[0] += 1
          priorities[i*N*N:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N:N*(N+1),:].T[0] -= 1
          priorities[i*N*N:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3868806000000002}
#standard deviation: 0.04972902435841669
#island_id: 3
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.2365346}
#standard deviation: 0.04472037122878118
#island_id: 0
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else 
                   J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N:k+1, 1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N:k+1, 1] -= max(1, priority_minus)
        
        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N:j*N+1:k+1, 1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.22264260000000002}
#standard deviation: 0.04419795453683349
#island_id: 0
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          
          priorities[i*N*N+j*N+k][0] += min(1, np.tanh(priority_plus))
          priorities[i*N*N+j*N+k][1] -= max(1, np.tanh(priority_minus))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          
          priorities[i*N*N+j*N+k][0] -= min(1, np.tanh(priority_minus))
          priorities[i*N*N+j*N:k+1, 1] = max(1, np.tanh(priority_plus))
          
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          
          priorities[i*N*N+j*N+k][0] += min(1, np.tanh(priority_plus))
          priorities[i*N*N+j*N:k+1, 1] -= max(1, np.tanh(priority_minus))
          
        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            
            priorities[i*N*N+j*N+k][0] += min(1, np.tanh(priority_plus))
            priorities[i*N*N:j*N+k+1, 1] -= max(1, np.tanh(priority_minus))

  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.1280514}
#standard deviation: 0.04500394869386463
#island_id: 0
#version_generated: 3
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
  
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k]]
      neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
      priorities[i*N*N+j*N:k+1, 0] += neighbor_magnetism_coeff
      priorities[i*N*N+j*N:k+1, 1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.02034259999999998}
#standard deviation: 0.04504944511578361
#island_id: 2
#version_generated: 3
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin_sum_neighbor = sum(J[d,i,j,k]*h[site_nbr][j][k] for d in range(6))
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3)) + total_spin_sum_neighbor
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.019848999999999974}
#standard deviation: 0.04664881433648663
#island_id: 2
#version_generated: 3
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_sum_neighbor = sum(J[d,i,j,k]*h[(i+(k-1)%2)%N][j][k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin_sum_neighbor)) * (total_spin_sum_neighbor < 0.5) + total_spin_sum_neighbor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum_neighbor
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin_sum_neighbor)) * (total_spin_sum_neighbor > 0.5) + total_spin_sum_neighbor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_sum_neighbor
        
  return(priorities)




#score: {'data3D.txt': -0.15251859999999998}
#standard deviation: 0.046936607185010706
#island_id: 2
#version_generated: 3
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2-1)%2 - 1)) % N
      interacting_spins = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
      total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
      
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
      
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.09044139999999996}
#standard deviation: 0.04710912104932548
#island_id: 2
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
        # Add a new term to account for the interactions with nearest neighbors
        if i > 0 or j > 0 or k > 0:
          neighboring_spins = [J[0,(i-1)%N,j,k], J[1,i,(j-1)%N,k]]
          total_neighbor_spin = sum(val for val in neighboring_spins)
          if total_spin + total_neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-total_spin - total_neighbor_spin)
            priorities[i*N*N+j*N+k][1] -= total_spin + total_neighbor_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin - total_neighbor_spin)
            priorities[i*N*N+j*N+k][1] = total_spin + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.08638900000000001}
#standard deviation: 0.0464640247826208
#island_id: 2
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
        # Add a term to account for the interaction with neighboring sites
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add a term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.10388220000000006}
#standard deviation: 0.04845436289086877
#island_id: 2
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.04390940000000001}
#standard deviation: 0.04420698487388616
#island_id: 0
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
  for i in range(N):
    for j in range(N):
      if h[i].sum() > 0:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] += 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] -= 1
      else:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] -= 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.06397620000000001}
#standard deviation: 0.08202043765769602
#island_id: 0
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
        site_nbr_spins = [J[d, site_nbr, j, k] for d in range(6)]
        total_site_nbr_spin = sum(J[d, site_nbr, j, k] for d in range(6))
        if h[site_nbr].sum() > 0:
          priorities[i*N*N+j*N+k][0] += -2 * (hamming_distance > 0.5) + total_site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 2 + total_site_nbr_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * (hamming_distance > 0.5) - total_site_nbr_spin
          priorities[i*N*N+j*N+k][1] = 2 - total_site_nbr_spin
  
  return(priorities)




#score: {'data3D.txt': -0.010762599999999999}
#standard deviation: 0.04721635650111093
#island_id: 0
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
        # Add the contribution from the site's own magnetization
        if h[i].sum() > 0:
          priorities[i*N*N+j*N:k*N*(N+1),:].T[0] += 1
          priorities[i*N*N+j*N:k*N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j*N:k*N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j*N:k*N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.04390940000000001}
#standard deviation: 0.04420698487388616
#island_id: 0
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
  
  for i in range(N):
    for j in range(N):
      if h[i].sum() > 0:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] += 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] -= 1
      else:
        priorities[i*N*N+j*N:N*(N+1),:].T[0] -= 1
        priorities[i*N*N+j*N:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.05990379999999999}
#standard deviation: 0.04469431625564933
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10388220000000006}
#standard deviation: 0.04845436289086877
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the total spin at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        # Calculate the priority to assign a spin of 1
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11234979999999999}
#standard deviation: 0.0497656990301553
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14832060000000016}
#standard deviation: 0.048712791499153495
#island_id: 2
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 * np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.30961940000000004}
#standard deviation: 0.050535349050342966
#island_id: 0
#version_generated: 3
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
        if h.sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.1733642}
#standard deviation: 0.0479197533211514
#island_id: 0
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        if h[i].sum() > 0:
          priorities[i*N:N*(N+1),:].T[0] += 1
          priorities[i*N:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N:N*(N+1),:].T[0] -= 1
          priorities[i*N:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.31231380000000003}
#standard deviation: 0.04824623228356801
#island_id: 0
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.31231380000000003}
#standard deviation: 0.04824623228356801
#island_id: 0
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.1483338000000001}
#standard deviation: 0.045835386084988966
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          
          total_neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= h[i][j][k] - max(1, priority_minus)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] = h[i][j][k] - max(1, priority_plus)
  
  return(priorities)




#score: {'data3D.txt': -0.3877977999999998}
#standard deviation: 0.04726550914948447
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09954660000000005}
#standard deviation: 0.04676470622638402
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.31112260000000025}
#standard deviation: 0.04487695944736007
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            
            priority_plus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            priority_minus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
          else:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1)
            
            priority_plus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            priority_minus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            
            priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
            priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
  return(priorities)




#score: {'data3D.txt': -0.128175}
#standard deviation: 0.04489239284110394
#island_id: 0
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spins = np.zeros((N, N, N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k] if i == 0 else J[0, i, (j+1)%N, k] if j == 0 else J[0, i, j, (k+1)%N] if k == 0 else 0,
                   J[1, i, (j+1)%N, k] if j == N-1 else J[1, i, j, (k+1)%N] if k == N-1 else 0,
                   J[2, i, j, (k+1)%N] if k == N-1 else 0,
                   J[3, (i+1)%N, j, k],
                   J[4, i, (j+1)%N, k],
                   J[5, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
        
  return(priorities)




#score: {'data3D.txt': 0.1419746}
#standard deviation: 0.044226773280898524
#island_id: 0
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in J[3:, i, j, k] if val < 0]) / max(len(J[3:, i, j, k]), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in J[3:, i, j, k] if val > 0]) / max(len(J[3:, i, j, k]), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 - total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.1891026000000002}
#standard deviation: 0.04850842641479932
#island_id: 0
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin

          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin

          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]

          total_neighbor_spin = sum(site_neighbors)

          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i:N*(N+1),:].T[0] -= h.sum()
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i:N*(N+1),:].T[0] += h.sum()

  return(priorities)




#score: {'data3D.txt': -0.1483338000000001}
#standard deviation: 0.045835386084988966
#island_id: 0
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          
          total_neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= h[i][j][k] - max(1, priority_minus)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] = h[i][j][k] - max(1, priority_plus)
  
  return(priorities)




#score: {'data3D.txt': -0.1483338000000001}
#standard deviation: 0.045835386084988966
#island_id: 0
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          
          total_neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= h[i][j][k] - max(1, priority_minus)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) + magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] = h[i][j][k] - max(1, priority_plus)
  
  return(priorities)




#score: {'data3D.txt': -0.16440659999999985}
#standard deviation: 0.04868418302118254
#island_id: 2
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += -2*np.exp(-abs(total_spin)) * (total_spin > 1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin > 1.5) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -2*np.exp(-abs(total_spin)) * (total_spin < -1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(-abs(total_spin)) * (total_spin < -1.5) + total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.04902539999999999}
#standard deviation: 0.06805234128845238
#island_id: 2
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = h.sum() + sum(sum(J[d].sum(axis=(0, 1))) for d in range(6))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6)) - total_spin_sum/N**3
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.027142200000000002}
#standard deviation: 0.05095732468605471
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += -2*np.exp(-abs(total_spin)) * (total_spin > 1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin > 1.5) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -2*np.exp(-abs(total_spin)) * (total_spin < -1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(-abs(total_spin)) * (total_spin < -1.5) + total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < -0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(-abs(total_spin)) * (total_spin < -0.5) - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0032633999999999988}
#standard deviation: 0.047450999783355464
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += -2*np.exp(-abs(total_spin)) * (total_spin > 1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin > 1.5) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -2*np.exp(-abs(total_spin)) * (total_spin < -1.5) - 2*total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(-abs(total_spin)) * (total_spin < -1.5) + total_spin
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%N - N//2)) % N
      if h[i][site_nbr][k] > 0:
        priorities[i*N*N+j*N+k][0] += 1
        priorities[i*N*N+j*N+k][1] -= 1
      else:
        priorities[i*N*N+j*N+k][0] -= 1
        priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)




#score: {'data3D.txt': -0.041558200000000003}
#standard deviation: 0.05051996014210621
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = total_spin
        
  # Normalize the priorities
  priorities /= np.sum(priorities, axis=0)[None,:]
  
  return(priorities)




#score: {'data3D.txt': -0.11962019999999998}
#standard deviation: 0.05018374589406415
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = total_spin
        
        # Calculate priority for the next nearest neighbor
        if i % N != 0 and j % N != 0 and k % N != 0:
          next_interacting_spins = [J[3,i-1,j,k], J[4,(i+1)%N,j,k], J[5,i,j-1,k]]
          total_spin_next = h[i][j][k] + sum(J[d,i-1,j,k]*next_interacting_spins[d] for d in range(3))
          
          if total_spin_next > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-total_spin_next) * (len([val for val in next_interacting_spins if val < 0]) > len([val for val in next_interacting_spins if val > 0]))
            priorities[i*N*N+j*N+k][1] -= total_spin_next
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin_next) * (len([val for val in next_interacting_spins if val < 0]) > len([val for val in next_interacting_spins if val > 0]))
            priorities[i*N*N+j*N+k][1] = total_spin_next
        
  return(priorities)




#score: {'data3D.txt': -0.1125498}
#standard deviation: 0.049840427766623355
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(3))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = total_spin
        
        # Add a new term based on the magnetism at this site
        priorities[i*N*N+j*N+k][0] += np.abs(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= np.abs(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.12951220000000008}
#standard deviation: 0.04605297917789902
#island_id: 0
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, np.exp(magnetism_coeff * (hamming_distance > 0.5)) * priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, np.exp(-magnetism_coeff * (hamming_distance > 0.5)) * priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, np.exp(-magnetism_coeff * (hamming_distance > 0.5)) * priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, np.exp(magnetism_coeff * (hamming_distance > 0.5)) * priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, np.exp(neighbor_magnetism_coeff) * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -np.exp(-neighbor_magnetism_coeff) * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09954660000000005}
#standard deviation: 0.04676470622638402
#island_id: 0
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09954660000000005}
#standard deviation: 0.04676470622638402
#island_id: 0
#version_generated: 3
#generate time14:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3460186}
#standard deviation: 0.038154736718263436
#island_id: 2
#version_generated: 3
#generate time14:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        
        # Add a new term to account for the magnetism of neighboring sites
        site_neighbors = [np.roll(h, -1, axis=d)[i,(j+1)%N,k] for d in range(3)] + [np.roll(h, 1, axis=d)[i,j,k] for d in range(3)]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff + total_spin_sum[i,j,k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum[i,j,k]
  
  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.068123}
#standard deviation: 0.0456968956385442
#island_id: 0
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  # additional improvement
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k, 1] -= np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k, 1] += np.exp(-h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': 0.048495800000000006}
#standard deviation: 0.04351106229868446
#island_id: 0
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.4920546000000002}
#standard deviation: 0.04192433778654113
#island_id: 1
#version_generated: 2
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,(j+1)%N,k] for d in [0,1,2]] + \
                   [J[d,(i+1)%N,j,k] for d in [0,1,2]] + \
                   [J[0,i,j,(k+1)%N], J[1,i,j,(k-1)%N%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3868806000000002}
#standard deviation: 0.04972902435841669
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3868806000000002}
#standard deviation: 0.04972902435841669
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3868806000000002}
#standard deviation: 0.04972902435841669
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3868806000000002}
#standard deviation: 0.04972902435841669
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0640514}
#standard deviation: 0.058346950203416806
#island_id: 2
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d].sum() for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2*np.exp(-abs(total_spin)) * (total_spin < -0.5) - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = 2*np.exp(-abs(total_spin)) * (total_spin < -0.5) - 2*total_spin
        
        site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        for d in range(6):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (J[d,i,j,k]*interacting_spins[d].sum() > 0.5) + J[d,i,j,k]*total_spin
          priorities[i*N*N+j*N+k][1] -= -2*np.exp(-abs(total_spin)) * (J[d,i,j,k]*interacting_spins[d].sum() < -0.5) - 2*J[d,i,j,k]*total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.004594599999999981}
#standard deviation: 0.3370093959681833
#island_id: 2
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2]) + total_spin_sum
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * (total_spin > 2) - 3*total_spin
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (total_spin > 2) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -np.exp(-abs(total_spin)) * (total_spin < -2) - 3*total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(-abs(total_spin)) * (total_spin < -2) + total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0086758}
#standard deviation: 0.04767302354959249
#island_id: 2
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr][j][k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.020383000000000075}
#standard deviation: 0.044247474854504414
#island_id: 2
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 1.5) + total_spin - 2
          priorities[i*N*N+j*N+k][1] -= 3 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < -1.5) + total_spin + 2
          priorities[i*N*N+j*N+k][1] = 3 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.051538200000000006}
#standard deviation: 0.04970197079352085
#island_id: 0
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_mag = -h[i][j][k]
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          total_spin_mag = h[i][j][k]
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1284558}
#standard deviation: 0.04510633887116089
#island_id: 0
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.12894260000000002}
#standard deviation: 0.0449647571464586
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 0] += magnetism_coeff
          priorities[i*N*N+j*N:k+1, 1] -= magnetism_coeff
        else:
          magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 0] -= magnetism_coeff
          priorities[i*N*N+j*N:k+1, 1] += magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.066745}
#standard deviation: 0.045900127832066005
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          for d in range(3):
            site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N:k+1, 0] -= 2 * np.exp(-abs(total_spin))
            priorities[i*N*N+j*N:k+1, 1] = -2 * h[i][j][k]
        else:
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
            priorities[i*N*N+j*N:k+1, 0] -= 2 * np.exp(abs(total_spin))
            priorities[i*N*N:j*N+k, 1] = 2 * h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.2934222000000003}
#standard deviation: 0.04712752600296349
#island_id: 2
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr][j][k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (total_spin > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (total_spin < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*h[site_nbr][j][k] for d in [0,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = 1 - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0038394}
#standard deviation: 0.04800669877881628
#island_id: 2
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin_sum = sum(sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6)) for i in range(N) for j in range(N) for k in range(N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d][site_nbr,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time15:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = min(3, magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag)
          priority_minus = max(-3, -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag)
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = max(-3, -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag)
          priority_minus = min(3, magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag)
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = min(3, magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag)
          priority_minus = max(-3, -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag)
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = min(3, magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag)
            priority_minus = max(-3, -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag)
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.07181739999999999}
#standard deviation: 0.04744979217277985
#island_id: 0
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        if i < N-2:
          for d in range(3):
            site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
            total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
            magnetism_coeff = np.exp(-abs(total_spin_mag))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
            priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.1280514}
#standard deviation: 0.04500394869386463
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
        
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k]]
      neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
      priorities[i*N*N+j*N:k+1, 0] += neighbor_magnetism_coeff
      priorities[i*N*N+j*N:k+1, 1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.1281682}
#standard deviation: 0.044885823026430065
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
        
  for i in range(N):
    site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
    priorities[i*N*N+j*N:k+1, 0] += neighbor_magnetism_coeff
    priorities[i*N*N+j*N:k+1, 1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.0208354}
#standard deviation: 0.0474243885236278
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        total_spin_mag = -total_spin
        
        site_magnetism = np.exp(h[i][j][k])
        
        priorities[i*N*N+j*N+k, 0] += site_nbr_coeff * (hamming_distance > 0.5) + site_magnetism
        priorities[i*N*N+j*N+k, 1] -= 2 + total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k, 0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k, 1] -= neighbor_magnetism_coeff
        
        for d in range(3):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k, 0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k, 1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1280514}
#standard deviation: 0.04500394869386463
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism
        
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k]]
      neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
      priorities[i*N*N+j*N:k+1, 0] += neighbor_magnetism_coeff
      priorities[i*N*N+j*N:k+1, 1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.128175}
#standard deviation: 0.04489239284110394
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] if d == 2 else 0 for d in range(3)] + [J[d, (i+1)%N, j, k] if d == 3 else J[d, i, (j+1)%N, k] if d == 4 else J[d, i, j, (k+1)%N] if d == 5 else 0 for d in range(3)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.128175}
#standard deviation: 0.04489239284110394
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spins = np.zeros((N, N, N))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k] if i == 0 else J[0, i, (j+1)%N, k] if j == 0 else J[0, i, j, (k+1)%N] if k == 0 else 0,
                   J[1, i, (j+1)%N, k] if j == N-1 else J[1, i, j, (k+1)%N] if k == N-1 else 0,
                   J[2, i, j, (k+1)%N] if k == N-1 else 0,
                   J[3, (i+1)%N, j, k],
                   J[4, i, (j+1)%N, k],
                   J[5, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.04120939999999999}
#standard deviation: 0.04746709546243587
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k] if i == 0 else J[0, i, (j+1)%N, k] if j == 0 else J[0, i, j, (k+1)%N] if k == 0 else 0,
                   J[1, i, (j+1)%N, k] if j == N-1 else J[1, i, j, (k+1)%N] if k == N-1 else 0,
                   J[2, i, j, (k+1)%N] if k == N-1 else 0,
                   J[3, (i+1)%N, j, k],
                   J[4, i, (j+1)%N, k],
                   J[5, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(6):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += magnetism
          priorities[i*N*N+j*N:k+1, 1] -= magnetism
        else:
          priorities[i*N*N+j*N:k+1, 0] -= magnetism
          priorities[i*N*N+j*N:k+1, 1] += magnetism

  return(priorities)




#score: {'data3D.txt': -0.012356999999999993}
#standard deviation: 0.04290347714346705
#island_id: 2
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0013378000000000003}
#standard deviation: 0.044701914177806744
#island_id: 2
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin sum for each site
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_sum = sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -abs(total_spin_sum) + total_spin_sum**2
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_sum) - total_spin_sum**2
          priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin_sum
  
  return(priorities)




#score: {'data3D.txt': -0.031931799999999996}
#standard deviation: 0.042420711318411436
#island_id: 2
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d-1] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    if sum(priorities[i]) > 0:
      priorities[i][1] -= sum(priorities[i])
    elif sum(priorities[i]) < 0:
      priorities[i][0] -= sum(priorities[i])
  
  return priorities




#score: {'data3D.txt': -0.36216139999999997}
#standard deviation: 0.039069746736317607
#island_id: 2
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        
        # Add a new term to account for the magnetism of neighboring sites
        site_neighbors = [np.roll(h, -1, axis=d)[i,(j+1)%N,k] for d in range(3)] + [np.roll(h, 1, axis=d)[i,j,k] for d in range(3)]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
        
        # Add a new term to account for the interaction with neighboring sites
        neighbor_interaction_coeff = np.exp(-np.sum(J[:,i,j,k]))
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff * neighbor_interaction_coeff + total_spin_sum[i,j,k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum[i,j,k]
  
  return(priorities)




#score: {'data3D.txt': -0.36216139999999997}
#standard deviation: 0.039069746736317607
#island_id: 2
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  total_spin_sum = np.sum(J, axis=0)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))

        site_neighbors = [np.roll(h, -1, axis=d)[i,(j+1)%N,k] for d in range(3)] + [np.roll(h, 1, axis=d)[i,j,k] for d in range(3)]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin_sum[i,j,k]) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))

        # Add a new term to account for the interactions with neighboring sites
        interaction_coeff = np.exp(-np.sum(np.abs(J[:,i,j,k] - total_spin_sum[i,(j+1)%N,k])))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff * interaction_coeff + total_spin_sum[i,j,k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_sum[i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism_coeff = np.exp(-abs(np.sum(J[:,i,j,k])))
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-site_magnetism_coeff * (hamming_distance > 0.5))
        
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        total_spin = h[i][j][k]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in J[:,i,j,k] if val < 0])))
        
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin - 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': 0.42861060000000034}
#standard deviation: 0.04361722329126419
#island_id: 2
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        
        if sum(J[d,i,j,k] for d in range(6)) > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0785346}
#standard deviation: 0.050402542027560476
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,(i-1+N)%N,j,k], J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = h[i][j][k] + sum(J[d,i,j,k]*interacting_spins[d] for d in range(6))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1133322}
#standard deviation: 0.046007160346624304
#island_id: 0
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1159246}
#standard deviation: 0.046206008644331095
#island_id: 0
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N:N*(N+1),:].T[0] += 1
          priorities[i*N:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N:N*(N+1),:].T[0] -= 1
          priorities[i*N:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.16228820000000002}
#standard deviation: 0.043280156431787536
#island_id: 0
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-total_spin * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.010762599999999999}
#standard deviation: 0.04721635650111093
#island_id: 0
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
        # Add the contribution from the site's own magnetization
        if h[i].sum() > 0:
          priorities[i*N*N+j*N:k*N*(N+1),:].T[0] += 1
          priorities[i*N*N+j*N:k*N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j*N:k*N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j*N:k*N*(N+1),:].T[1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.00046220000000000126}
#standard deviation: 0.04911281799245488
#island_id: 0
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
        # Add the contribution from the site's own magnetization
        if h[i].sum() > 0:
          priorities[i*N*N+j*N:k*N*(N+1),:].T[0] += 1
          priorities[i*N*N+j*N:k*N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j*N:k*N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j*N:k*N*(N+1),:].T[1] += 1
        
        # Add the contribution from neighboring sites' magnetization
        for d in range(6):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': 0.004977399999999999}
#standard deviation: 0.0480277420793441
#island_id: 0
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = -2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] -= 2 - priority_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_mag = 2 * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_mag
          priorities[i*N*N+j*N+k][1] = -2 - priority_mag
        
        # Add the contribution from the site's own magnetization
        if h[i].sum() > 0:
          for d in range(6):
            priorities[i*N*N+j*N:k*N*(N+1),:].T[0] += J[d, i, j, k]
            priorities[i*N*N+j*N:k*N*(N+1),:].T[1] -= J[d, i, j, k]
        else:
          for d in range(6):
            priorities[i*N*N+j*N:k*N*(N+1),:].T[0] -= J[d, i, j, k]
            priorities[i*N*N+j*N:k*N*(N+1),:].T[1] += J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.34933660000000033}
#standard deviation: 0.048767545154949105
#island_id: 0
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i].sum() > 0:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            
            priority_plus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            priority_minus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            
            priorities[i*N*N+j:N*(N+1),:].T[0] += min(1, priority_plus)
            priorities[i*N*N+j:N*(N+1),:].T[1] -= max(1, priority_minus)
          else:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1)
            
            priority_plus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            priority_minus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            
            priorities[i*N*N+j:N*(N+1),:].T[0] -= min(1, priority_minus)
            priorities[i*N*N+j:N*(N+1),:].T[1] = max(1, priority_plus)
        
  return(priorities)




#score: {'data3D.txt': -0.31112260000000025}
#standard deviation: 0.04487695944736007
#island_id: 0
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin

          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin

          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]

          if h[i][j][k] > 0:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)

            priority_plus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            priority_minus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)

            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
          else:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1)

            priority_plus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            priority_minus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)

            priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
            priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

  return(priorities)




#score: {'data3D.txt': -0.31112260000000025}
#standard deviation: 0.04487695944736007
#island_id: 0
#version_generated: 3
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
            
            priority_plus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            priority_minus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            
            priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
            priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
          else:
            neighbor_coeff = np.exp(-abs(sum(site_neighbors)))
            hamming_distance = len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1)
            
            priority_plus = -neighbor_coeff * (hamming_distance > 0.5) - sum(site_neighbors)
            priority_minus = neighbor_coeff * (hamming_distance > 0.5) + sum(site_neighbors)
            
            priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
            priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1133322}
#standard deviation: 0.046007160346624304
#island_id: 0
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.11316580000000002}
#standard deviation: 0.04609107234985968
#island_id: 0
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 2
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 2

  return(priorities)




#score: {'data3D.txt': -0.12886860000000003}
#standard deviation: 0.045210171134823195
#island_id: 0
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.11708500000000001}
#standard deviation: 0.04743100773755498
#island_id: 0
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.071361}
#standard deviation: 0.04731386391957435
#island_id: 0
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(priority_plus)
          priorities[i*N*N+j*N+k][1] -= np.tanh(priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= np.tanh(priority_minus)
          priorities[i*N*N+j*N+k][1] = np.tanh(priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

  return(priorities)




#score: {'data3D.txt': -0.071361}
#standard deviation: 0.04731386391957435
#island_id: 0
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)

  return(priorities)




#score: {'data3D.txt': -0.33304380000000006}
#standard deviation: 0.04245752373325604
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of interacting spins
        num_interacting_spins = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
        priorities[i*N*N+j*N+k][0] += (num_interacting_spins / max(len(interacting_spins), 1))
        priorities[i*N*N+j*N+k][1] -= num_interacting_spins
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1810418}
#standard deviation: 0.059145042503662135
#island_id: 0
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d, i, j, k]))
            priorities[i*N*N+j*N+k][1] -= 2
          elif J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[d, i, j, k]))
            priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.3117162}
#standard deviation: 0.044881371386801455
#island_id: 0
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] += priority_plus
          priorities[i*N*N+j*N+k][1] -= 2 - priority_plus
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_minus = -magnetism_coeff * (hamming_distance < 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= priority_minus
          priorities[i*N*N+j*N+k][1] = -2 - priority_minus

        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag

        if h.sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.30712900000000004}
#standard deviation: 0.052261939104859094
#island_id: 0
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
        site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
        site_nbr_total_spin_mag = -site_nbr_total_spin
        priorities[i*N*N+j*N+k][0] += site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
        priorities[i*N*N+j*N+k][1] -= 2 + site_nbr_total_spin_mag
        
  for i in range(N):
    if h.sum() > 0:
      priorities[i:N*(N+1),:].T[0] += 1
      priorities[i:N*(N+1),:].T[1] -= 1
    else:
      priorities[i:N*(N+1),:].T[0] -= 1
      priorities[i:N*(N+1),:].T[1] += 1
  
  return priorities




#score: {'data3D.txt': 0.047063}
#standard deviation: 0.042239070905975194
#island_id: 0
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
          site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
          site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
          site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
          site_nbr_total_spin_mag = -site_nbr_total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag + site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) + site_nbr_total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag - 2 * site_nbr_total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          site_nbr_neighbors = [J[d, i, (j+1)%N, k] if d == 0 else J[d, (i+1)%N, j, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
          site_nbr_total_spin = sum(J[d, i, j, k] for d in range(6))
          site_nbr_magnetism_coeff = np.exp(-abs(site_nbr_total_spin))
          site_nbr_hamming_distance = len([val for val in site_nbr_neighbors if val > 0]) / max(len(site_nbr_neighbors), 1)
          site_nbr_total_spin_mag = -site_nbr_total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag - site_nbr_magnetism_coeff * (site_nbr_hamming_distance > 0.5) - site_nbr_total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag + 2 * site_nbr_total_spin_mag
        
        if h.sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.48859660000000005}
#standard deviation: 0.04169498996810049
#island_id: 2
#version_generated: 3
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_up_priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          spin_down_priority = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] = spin_up_priority
          priorities[i*N*N+j*N+k][1] = spin_down_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_up_priority = -2 + 2*total_spin
          spin_down_priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] = spin_down_priority
          priorities[i*N*N+j*N+k][1] = spin_up_priority

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.42313300000000004}
#standard deviation: 0.040914315722006156
#island_id: 1
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = total_spin + sum(val for val in interacting_spins) - h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = total_spin + sum(val for val in interacting_spins) + h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + sum(val for val in interacting_spins if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0724606}
#standard deviation: 0.04464528785482293
#island_id: 3
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate priority based on the number of neighbors with same spin as current site
        neighbor_magnetism_coeff = 0.5 + 0.5 * sum(val for val in interacting_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (total_spin > 0) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*neighbor_magnetism_coeff * (total_spin > 0) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4731098000000002}
#standard deviation: 0.04143813103845298
#island_id: 3
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = -2 + 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = 2 - 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + priority_up
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] + priority_down
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) + priority_up
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + priority_down
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5101714}
#standard deviation: 0.04031464079016456
#island_id: 3
#version_generated: 3
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term to account for the spin configuration of neighboring sites
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.36002860000000003}
#standard deviation: 0.0473131332934102
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) - total_spin
        
        # Calculate priority based on the number of neighbors with same spin as current site
        neighbor_magnetism_coeff = 0.5 + 0.5 * sum(val for val in interacting_spins if val > 0)
        priority_plus += neighbor_magnetism_coeff * (total_spin > 0) + total_spin
        priority_minus -= 2 - 2*neighbor_magnetism_coeff * (total_spin > 0) + total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += priority_plus
        priorities[i*N*N+j*N+k][1] -= priority_minus
  
  return(priorities)




#score: {'data3D.txt': -0.09606780000000001}
#standard deviation: 0.04760699111643163
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = 0.5 + 0.5 * sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*neighbor_magnetism_coeff * (total_spin > 0) - 2*magnetism_coeff * (hamming_distance > 0.5) - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = 0.5 + 0.5 * sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff * (total_spin < 0) - 2*magnetism_coeff * (hamming_distance > 0.5) - 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_diff = sum(1 if val < 0 else -1 for val in interacting_spins) / (2 * N ** 2)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_diff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_diff = sum(1 if val > 0 else -1 for val in interacting_spins) / (2 * N ** 2)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_diff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.197047}
#standard deviation: 0.043548427193183456
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.47883540000000013}
#standard deviation: 0.04158926576461768
#island_id: 3
#version_generated: 3
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.058790999999999996}
#standard deviation: 0.04902691545467652
#island_id: 0
#version_generated: 3
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i].sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.008827400000000001}
#standard deviation: 0.04738717304545608
#island_id: 0
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        for d in range(3,6):
          site_neighbors = [J[d, (i+1)%N, j, k], J[d, i, (j+1)%N, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1133322}
#standard deviation: 0.046007160346624304
#island_id: 0
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1133322}
#standard deviation: 0.046007160346624304
#island_id: 0
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i*N*N+j:N*(N+1),:].T[0] += 1
          priorities[i*N*N+j:N*(N+1),:].T[1] -= 1
        else:
          priorities[i*N*N+j:N*(N+1),:].T[0] -= 1
          priorities[i*N*N+j:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.15874420000000003}
#standard deviation: 0.0434981421023933
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.015069}
#standard deviation: 0.04807696578404257
#island_id: 0
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0024170000000000007}
#standard deviation: 0.047066608025223146
#island_id: 0
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        for d in range(3):
          for x, y in [[i-1, j], [i, j-1], [i+1, j]]:
            if 0 <= x < N and 0 <= y < N:
              site_neighbors = [J[d, x, y, k]]
              neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
              
              priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0026830000000000005}
#standard deviation: 0.04705807848818309
#island_id: 0
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
        for d in range(6):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N:k+1, 0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N:k+1, 0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N:k+1, 1] += h[i][j][k]
        
  for d in range(3):
    site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
    
    priorities[i*N*N+j*N:k+1, 0] += neighbor_magnetism_coeff
    priorities[i*N*N+j*N:k+1, 1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.14309780000000002}
#standard deviation: 0.04332269330454883
#island_id: 2
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
  return(priorities)




#score: {'data3D.txt': -0.0867526}
#standard deviation: 0.042567609672613756
#island_id: 2
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.15874420000000003}
#standard deviation: 0.0434981421023933
#island_id: 2
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.15874420000000003}
#standard deviation: 0.0434981421023933
#island_id: 2
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(total_magnetism)
        priorities[i*N*N+j*N+k][1] -= total_magnetism
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.14309780000000002}
#standard deviation: 0.04332269330454883
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
  return(priorities)




#score: {'data3D.txt': -0.14294860000000004}
#standard deviation: 0.043290887240157144
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
  # Add new term: magnetic field from below
  if k > 0:
    priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
    priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
  
  return(priorities)




#score: {'data3D.txt': 0.21995419999999996}
#standard deviation: 0.04637693502550595
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: total magnetic field
        priorities[i*N*N+j*N+k][0] += sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i*N*N+j*N+k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.024058600000000017}
#standard deviation: 0.04457282272910255
#island_id: 2
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.13200780000000004}
#standard deviation: 0.044153333499974835
#island_id: 2
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.024058600000000017}
#standard deviation: 0.04457282272910255
#island_id: 2
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.13200780000000004}
#standard deviation: 0.044153333499974835
#island_id: 2
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
  return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
  
  return(priorities)




#score: {'data3D.txt': -0.14294860000000004}
#standard deviation: 0.043290887240157144
#island_id: 2
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
  # Add new term: magnetic field from below
  if k > 0:
    priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
    priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
  
  return(priorities)




#score: {'data3D.txt': -0.024058600000000017}
#standard deviation: 0.04457282272910255
#island_id: 2
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
  
  return(priorities)




#score: {'data3D.txt': -0.13894300000000007}
#standard deviation: 0.04373411106904999
#island_id: 2
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.25780380000000014}
#standard deviation: 0.050870966430371665
#island_id: 2
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_up_priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          spin_down_priority = -2 + 2*total_spin + np.sum(np.abs(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][0] = spin_up_priority
          priorities[i*N*N+j*N+k][1] = spin_down_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_up_priority = -2 + 2*total_spin + np.sum(np.abs(J[:,i,j,k]))
          spin_down_priority = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] = spin_up_priority
          priorities[i*N*N+j*N+k][1] = spin_down_priority
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.13894300000000007}
#standard deviation: 0.04373411106904999
#island_id: 2
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

  # New term: site's magnetic field
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.15874420000000003}
#standard deviation: 0.0434981421023933
#island_id: 2
#version_generated: 3
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.061864199999999994}
#standard deviation: 0.04789762664642163
#island_id: 0
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.11708500000000001}
#standard deviation: 0.04743100773755498
#island_id: 0
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.11708500000000001}
#standard deviation: 0.04743100773755498
#island_id: 0
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        if h[i].sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1

  return(priorities)




#score: {'data3D.txt': -0.11708500000000001}
#standard deviation: 0.04743100773755498
#island_id: 0
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i].sum() > 0:
          priorities[i:N*(N+1),:].T[0] += 1
          priorities[i:N*(N+1),:].T[1] -= 1
        else:
          priorities[i:N*(N+1),:].T[0] -= 1
          priorities[i:N*(N+1),:].T[1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0952114}
#standard deviation: 0.04479374230894311
#island_id: 2
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field with weighted sum
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k] * (1 + np.exp(-np.abs(J[0, i-1, j, k])))
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k] * (1 + np.exp(np.abs(J[0, i-1, j, k])))
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k] * (1 + np.exp(-np.abs(J[1, i, j-1, k])))
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k] * (1 + np.exp(np.abs(J[1, i, j-1, k])))
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1] * (1 + np.exp(-np.abs(J[2, i, j, k-1])))
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1] * (1 + np.exp(np.abs(J[2, i, j, k-1])))

  return(priorities)




#score: {'data3D.txt': -0.0867526}
#standard deviation: 0.042567609672613756
#island_id: 2
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.0867526}
#standard deviation: 0.042567609672613756
#island_id: 2
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        # Calculate the priority to assign a spin
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Apply the priority
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Apply the priority
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.30368220000000007}
#standard deviation: 0.0456730879529729
#island_id: 0
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin_mag

          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

          if k > 0:
            top_neighbor = J[2, i, j, (k-1)%N]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (top_neighbor < 0))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][1] = -2 - total_spin_mag

          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1)))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += neighbor_magnetism_coeff

          if k > 0:
            top_neighbor = J[2, i, j, (k-1)%N]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (top_neighbor > 0))
            priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 3
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 3
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 3
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4720594}
#standard deviation: 0.042928535400593396
#island_id: 3
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3273686}
#standard deviation: 0.04185997054514014
#island_id: 3
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum([J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum([J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4615142}
#standard deviation: 0.04089259441952785
#island_id: 3
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.45276740000000015}
#standard deviation: 0.04432051824200615
#island_id: 3
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - site_magnetism - sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - site_magnetism - sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
 
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
  
  return(priorities)




#score: {'data3D.txt': 0.064385}
#standard deviation: 0.043653543899665234
#island_id: 2
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.12140140000000002}
#standard deviation: 0.04547900480485474
#island_id: 2
#version_generated: 3
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.12140140000000002}
#standard deviation: 0.04547900480485474
#island_id: 2
#version_generated: 3
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.13200780000000004}
#standard deviation: 0.044153333499974835
#island_id: 2
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.12140140000000002}
#standard deviation: 0.04547900480485474
#island_id: 2
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
  return(priorities)




#score: {'data3D.txt': -0.0025246}
#standard deviation: 0.046914128733676806
#island_id: 2
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
          # New term: neighbor's magnetic field
          if i > 0:
            priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
            priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
          if j > 0:
            priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
            priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
          if k > 0:
            priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
            priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
          
        return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': 0.024626999999999996}
#standard deviation: 0.04420689121618936
#island_id: 2
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
        # New term: magnetic field from front
        if i > 0 and j > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j-1, k]
        
        # New term: magnetic field from back
        if i < N-1 and j > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j-1, k]
 
  return(priorities)




#score: {'data3D.txt': -0.09954660000000005}
#standard deviation: 0.04676470622638402
#island_id: 0
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09954660000000005}
#standard deviation: 0.04676470622638402
#island_id: 0
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.057044199999999996}
#standard deviation: 0.04656118218387501
#island_id: 3
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += sum(h[site_nbr][j][0] for site_nbr in site_nbrs) / len(set(site_nbrs))
        priorities[i*N*N+j*N+0][1] -= 2 - 2*sum(J[d,i,j,0] for d in range(6)) + sum(h[site_nbr][j][0] for site_nbr in site_nbrs)
      else:
        priorities[i*N*N+j*N+0][0] -= sum(h[site_nbr][j][0] for site_nbr in site_nbrs) / len(set(site_nbrs))
        priorities[i*N*N+j*N+0][1] = -2 + 2*sum(J[d,i,j,0] for d in range(6)) - sum(h[site_nbr][j][0] for site_nbr in site_nbrs)

      # Add new term to account for the magnetism of the site itself
      priorities[i*N*N+j*N+0][0] += np.exp(h[i][j][0])
      priorities[i*N*N+j*N+0][1] -= h[i][j][0]

  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 3
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - site_magnetism - sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - site_magnetism - sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term that takes into account the sum of all interactions from this site
        total_magnetism = 0
        for d in range(6):
          for n in range(N):
            if i == n or j == n or k == n:
              continue
            total_magnetism += np.exp(J[d,i,j,k])
        priorities[i*N*N+j*N+k][0] -= 2 * total_magnetism
        priorities[i*N*N+j*N+k][1] += 2 * total_magnetism

  return(priorities)




#score: {'data3D.txt': -0.45276740000000015}
#standard deviation: 0.04432051824200615
#island_id: 3
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - site_magnetism - sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - site_magnetism - sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.45276740000000015}
#standard deviation: 0.04432051824200615
#island_id: 3
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - site_magnetism - sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - site_magnetism - sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09954660000000005}
#standard deviation: 0.04676470622638402
#island_id: 0
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          priority_minus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] += min(1, np.exp(h[i][j][k]) * priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, -np.exp(-h[i][j][k]) * priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = (-magnetism_coeff * (hamming_distance > 0.5) - total_spin) ** 2
          priority_minus = (magnetism_coeff * (hamming_distance > 0.5) + total_spin) ** 2
          
          priorities[i*N*N+j*N+k][0] -= min(1, np.exp(h[i][j][k]) * priority_minus)
          priorities[i*N*N+j*N+k][1] = max(1, -np.exp(-h[i][j][k]) * priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          
          priorities[i*N*N+j*N+k][0] += min(1, neighbor_magnetism_coeff * (sum(site_neighbors) > 0))
          priorities[i*N*N+j*N+k][1] -= max(1, -neighbor_magnetism_coeff * (sum(site_neighbors) < 0))
        
  return(priorities)




#score: {'data3D.txt': -0.0023634000000000003}
#standard deviation: 0.04709973312493394
#island_id: 0
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          priority_plus = magnetism_coeff * (np.sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]) < 0) + total_spin
          priority_minus = -magnetism_coeff * (np.sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]) > 0) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          priority_plus = magnetism_coeff * (np.sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]) > 0) + total_spin
          priority_minus = -magnetism_coeff * (np.sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]) < 0) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (np.sum([val < 0 for val in site_neighbors]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        return(priorities)




#score: {'data3D.txt': -0.3798934000000003}
#standard deviation: 0.048812781486409884
#island_id: 0
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                   J[1, (i+1)%N, (j+1)%N, k], J[1, i, (j+2)%N, k], J[1, i, j, (k+1)%N],
                   J[2, (i+2)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
  return(priorities)




#score: {'data3D.txt': -0.0024170000000000007}
#standard deviation: 0.047066608025223146
#island_id: 0
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        for d in range(3):
          for x, y in [[i-1, j], [i, j-1], [i+1, j]]:
            if 0 <= x < N and 0 <= y < N:
              site_neighbors = [J[d, x, y, k]]
              neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
              
              priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.3260574000000003}
#standard deviation: 0.05718320754592208
#island_id: 0
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] += min(1, priority_plus)
          priorities[i*N*N+j*N+k][1] -= max(1, priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          
          priorities[i*N*N+j*N+k][0] -= max(1, priority_minus)
          priorities[i*N*N+j*N+k][1] += min(1, priority_plus)
        
  for i in range(N):
    if h.sum() > 0:
      priorities[i:N*(N+1),:].T[0] += 1
      priorities[i:N*(N+1),:].T[1] -= 1
    else:
      priorities[i:N*(N+1),:].T[0] -= 1
      priorities[i:N*(N+1),:].T[1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(priority_plus)
          priorities[i*N*N+j*N+k][1] -= np.tanh(priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= np.tanh(priority_minus)
          priorities[i*N*N+j*N+k][1] = np.tanh(priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

  return(priorities)




#score: {'data3D.txt': -0.03432220000000032}
#standard deviation: 0.05130081156434078
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Calculate priority plus
          site_neighbors_plus = [J[d, i, (j+2)%N, k] for d in range(3)]
          site_neighbors_minus = [J[d, i, j, (k+2)%N] for d in range(3)]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(6))
          magnetism_coeff_plus = np.exp(-abs(total_spin_mag))
          hamming_distance_plus = len([val for val in site_neighbors_plus if val < 0]) / max(len(site_neighbors_plus), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          
          # Calculate priority minus
          site_neighbors_minus = [J[d, i, (j+2)%N, k] for d in range(3)]
          site_neighbors_plus = [J[d, i, j, (k+2)%N] for d in range(3)]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(6))
          magnetism_coeff_minus = np.exp(-abs(total_spin_mag))
          hamming_distance_minus = len([val for val in site_neighbors_minus if val < 0]) / max(len(site_neighbors_minus), 1)
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Calculate priority plus
          site_neighbors_plus = [J[d, i, (j+2)%N, k] for d in range(3)]
          site_neighbors_minus = [J[d, i, j, (k+2)%N] for d in range(3)]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(6))
          magnetism_coeff_plus = np.exp(-abs(total_spin_mag))
          hamming_distance_plus = len([val for val in site_neighbors_plus if val > 0]) / max(len(site_neighbors_plus), 1)
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          
          # Calculate priority minus
          site_neighbors_minus = [J[d, i, (j+2)%N, k] for d in range(3)]
          site_neighbors_plus = [J[d, i, j, (k+2)%N] for d in range(3)]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(6))
          magnetism_coeff_minus = np.exp(-abs(total_spin_mag))
          hamming_distance_minus = len([val for val in site_neighbors_minus if val > 0]) / max(len(site_neighbors_minus), 1)
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          
          priorities[i*N*N+j*N+k][0] -= np.tanh(max(1, priority_plus))
          priorities[i*N*N+j*N+k][1] = np.tanh(min(1, priority_minus))

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(priority_plus)
          priorities[i*N*N+j*N+k][1] -= np.tanh(priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= np.tanh(priority_minus)
          priorities[i*N*N+j*N+k][1] = np.tanh(priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else J[d, i, (j+1)%N, k] if d == 1 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(priority_plus)
          priorities[i*N*N+j*N+k][1] -= np.tanh(priority_minus)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_mag = -total_spin
          priority_plus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priority_minus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priorities[i*N*N+j*N+k][0] -= np.tanh(priority_minus)
          priorities[i*N*N+j*N+k][1] = np.tanh(priority_plus)

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

        for d in range(3):
          site_neighbors = [J[d, (i+2)%N, j, k], J[d, i, (j+1)%N, k]]
          total_spin_mag = -sum(J[d, i, j, k] for d in range(2))
          magnetism_coeff = np.exp(-abs(total_spin_mag))
          hamming_distance = len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)
          priority_plus = magnetism_coeff * (hamming_distance > 0.5) + total_spin_mag
          priority_minus = -magnetism_coeff * (hamming_distance > 0.5) - total_spin_mag
          priorities[i*N*N+j*N+k][0] += np.tanh(min(1, priority_plus))
          priorities[i*N*N+j*N+k][1] -= np.tanh(max(1, priority_minus))

  return(priorities)




#score: {'data3D.txt': -0.4615142}
#standard deviation: 0.04089259441952785
#island_id: 3
#version_generated: 3
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          neighbor_magnetism_coeff = max(neighbor_magnetism_coeff, 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          neighbor_magnetism_coeff = max(neighbor_magnetism_coeff, 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4615142}
#standard deviation: 0.04089259441952785
#island_id: 3
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4716118000000001}
#standard deviation: 0.04285820319098784
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        # Calculate site magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Calculate neighbor magnetism coefficient
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        # Calculate priority based on site magnetism, hamming distance, and neighbor magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.031370199999999994}
#standard deviation: 0.04487818124612449
#island_id: 2
#version_generated: 3
#generate time19:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3891854000000002}
#standard deviation: 0.04875077749985122
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.024058600000000017}
#standard deviation: 0.04457282272910255
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
  
  return(priorities)




#score: {'data3D.txt': 0.0347482}
#standard deviation: 0.04511053620563604
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from left
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.110293}
#standard deviation: 0.04490894288446345
#island_id: 2
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from below
        if k > 0:
          priorities[i*N*N+j*N+k-1][0] += J[2, i, j, k]
          priorities[i*N*N+j*N+k-1][1] -= J[2, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.12140140000000002}
#standard deviation: 0.04547900480485474
#island_id: 2
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
        # New term: magnetic field from front
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.13703220000000005}
#standard deviation: 0.04461453712816037
#island_id: 2
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin >= 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.12140140000000002}
#standard deviation: 0.04547900480485474
#island_id: 2
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': -0.12140140000000002}
#standard deviation: 0.04547900480485474
#island_id: 2
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Prioritize the spin aligned with the local magnetic field
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        
        # New term: magnetic field from left
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
        
        # New term: magnetic field from right
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += J[1, i, j+1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j+1, k]
        
  return(priorities)




#score: {'data3D.txt': 0.0316558}
#standard deviation: 0.044863751585885014
#island_id: 2
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if k > 0:
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
        
        if k < N-1:
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
        
        if k > 0:
          priorities[i*N*N+j*N+k-1][1] -= J[2, i, j, k]
          priorities[i*N*N+j*N+k-1][0] += J[2, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4940858000000001}
#standard deviation: 0.04065283997902237
#island_id: 3
#version_generated: 3
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4243518}
#standard deviation: 0.04157261450474339
#island_id: 3
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term to account for the interaction with the site above
        if k > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(J[3,i,j,k-1])
          priorities[i*N*N+j*N+k][1] -= J[3,i,j,k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.4611426}
#standard deviation: 0.03954470717099825
#island_id: 3
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  def neighbor_magnetism(site_nbr, interacting_spins):
    site_neighbors = [J[0,site_nbr,(j+1)%N,k], J[1,(i+1)%N,j,k]]
    return np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
  
  total_energy = [0, 0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = neighbor_magnetism(site_nbr, interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = neighbor_magnetism(site_nbr, interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4872030000000001}
#standard deviation: 0.04049410958398764
#island_id: 3
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 1 + sum(val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0867526}
#standard deviation: 0.042567609672613756
#island_id: 2
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.044300599999999996}
#standard deviation: 0.042601603721456306
#island_id: 2
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= -h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] += h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.32617740000000006}
#standard deviation: 0.04775933510048062
#island_id: 2
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          site_energy = -sum(J[d, i, j, k] * (d == 0) + J[2, i, j, k-1] * (k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          site_energy = -sum(J[d, i, j, k] * (d == 0) + J[2, i, j, k-1] * (k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.13975300000000004}
#standard deviation: 0.04479866862977069
#island_id: 2
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate Hamming distance and site's magnetism
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_magnetism = h[i][j][k]
        
        # Update priorities based on total spin, Hamming distance, and site's magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        
        # Add neighbor's magnetic field and site's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]
        
        # Add site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add magnetic field from above and left
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.13335020000000006}
#standard deviation: 0.044589339981210764
#island_id: 2
#version_generated: 3
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k < N-1) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.13894300000000007}
#standard deviation: 0.04373411106904999
#island_id: 2
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.13894300000000007}
#standard deviation: 0.04373411106904999
#island_id: 2
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.13335020000000006}
#standard deviation: 0.044589339981210764
#island_id: 2
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k < N-1) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.13335020000000006}
#standard deviation: 0.044589339981210764
#island_id: 2
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k < N-1) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.13335020000000006}
#standard deviation: 0.044589339981210764
#island_id: 2
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k < N-1) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.13335020000000006}
#standard deviation: 0.044589339981210764
#island_id: 2
#version_generated: 3
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k > 0) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          total_energy = sum(J[d, i, j, k] * (d == 2 and k < N-1) for d in [0, 1, 2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism + total_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 0
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    
    return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

        # New term: magnetic field from above
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.12532260000000006}
#standard deviation: 0.043275269256701346
#island_id: 2
#version_generated: 3
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        # New term: site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # New term: neighbor's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0, i-1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i-1, j, k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1, i, j-1, k]
          priorities[i*N*N+j*N+k][1] -= J[1, i, j-1, k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k-1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k-1]

  # New term: magnetic field from above
  for k in range(N):
    for i in range(N):
      for j in range(N):
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]

  return(priorities)




#score: {'data3D.txt': -0.2003266}
#standard deviation: 0.045059679675292855
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_magnetism = h[i][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]

        for d in range(3):
          if i+d > N-1:
            break
          priorities[i*N*N+j*N+k][0] += J[d, (i+d)%N, j, k]
          priorities[i*N*N+j*N+k][1] -= J[d, (i+d)%N, j, k]

        for d in range(3):
          if j+d > N-1:
            break
          priorities[i*N*N+j*N+k][0] += J[2-d, i, (j+d)%N, k]
          priorities[i*N*N+j*N+k][1] -= J[2-d, i, (j+d)%N, k]

  return(priorities)




#score: {'data3D.txt': -0.16669220000000007}
#standard deviation: 0.0434633806687883
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate Hamming distance and site's magnetism
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_magnetism = h[i][j][k]
        
        # Update priorities based on total spin, Hamming distance, and site's magnetism
        if site_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + site_magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - site_magnetism
        
        # Add neighbor's magnetic field and site's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0,i-1,j,k]
          priorities[i*N*N+j*N+k][1] -= J[0,i-1,j,k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1,i,j-1,k]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j-1,k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2,i,j,k-1]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,k-1]
        
        # Add site's magnetic field
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1601362000000001}
#standard deviation: 0.04621503618477433
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate Hamming distance and site's magnetism
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_magnetism = h[i][j][k]
        
        # Update priorities based on total spin, Hamming distance, and site's magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        
        # Add neighbor's magnetic field and site's magnetic field
        for d in [0, 1, 2]:
          if i > 0:
            priorities[i*N*N+j*N+k][0] += J[d, i-1, j, k]
            priorities[i*N*N+j*N+k][1] -= J[d, i-1, j, k]
          if j > 0:
            priorities[i*N*N+j*N+k][0] += J[d, i, j-1, k]
            priorities[i*N*N+j*N+k][1] -= J[d, i, j-1, k]
          if k > 0:
            priorities[i*N*N+j*N+k][0] += J[d, i, j, k-1]
            priorities[i*N*N+j*N+k][1] -= J[d, i, j, k-1]
          
          # Add site's magnetic field
          priorities[i*N*N+j*N+k][0] += h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add magnetic field from above and left
        if k < N-1:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k+1]
          priorities[i*N*N+j*N+k][1] -= J[2, i, j, k+1]
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += J[0, i+1, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i+1, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.14795700000000003}
#standard deviation: 0.04340470977900902
#island_id: 2
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0) / max(len(interacting_spins), 1) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0) / max(len(interacting_spins), 1) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor's magnetic field and site's magnetic field
        if i > 0:
          priorities[i*N*N+j*N+k][0] += J[0,i-1,j,k]
          priorities[i*N*N+j*N+k][1] -= J[0,i-1,j,k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += J[1,i,j-1,k]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j-1,k]
        if k > 0:
          priorities[i*N*N+j*N+k][0] += J[2,i,j,k-1]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,k-1]
        
        # Add site's magnetic field
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.31221260000000006}
#standard deviation: 0.0486667381405411
#island_id: 3
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47554620000000003}
#standard deviation: 0.04228866450433261
#island_id: 3
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[5,i,(j+1)%N,k], J[5,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interaction with the site above
        if k > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(J[3,i,j,k-1])
          priorities[i*N*N+j*N+k][1] -= J[3,i,j,k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.5056094000000001}
#standard deviation: 0.042878880951349466
#island_id: 3
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[3,i,j,k-1], J[4,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5044377999999999}
#standard deviation: 0.04285928943834697
#island_id: 3
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with the site above
        if k > 0:
          priorities[i*N*N+j*N+k-1][1] += J[3,i,j,k]
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    
  return(priorities)




#score: {'data3D.txt': -0.5301078}
#standard deviation: 0.04167859905467074
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.49481060000000016}
#standard deviation: 0.041296295325852175
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
    # Add new term to account for the magnetism of the site itself
    priorities[i][0] += np.exp(h[i//N//N][i//N%N][i%N])
    priorities[i][1] -= h[i//N//N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0031282000000000003}
#standard deviation: 0.047014145156112325
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
      for d in range(3):
        site_neighbors = [J[d,i//N//N,(i//N)%N,i%N], J[d,(i//N)//N,i//N//N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,(i//N)%N,i%N] for d in [0,1,2])) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i][0] += neighbor_magnetism_coeff
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
    return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N//N%N,i%N], J[2,i//N//N%N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N - 1) // N)) % N
    total_spin = sum(J[d,i//N//N%N,i//N%N,i%N] for d in [0,1,2])
    if h[i//N//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.5301078}
#standard deviation: 0.04167859905467074
#island_id: 0
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.037105000000000006}
#standard deviation: 0.04667280551884577
#island_id: 0
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N - 1) % N)) % N
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.4760214000000002}
#standard deviation: 0.04375340514794249
#island_id: 2
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_product
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_product
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N//N][i//N%N][i%N] > 0:
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 0
#version_generated: 3
#generate time22:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 2
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49664620000000015}
#standard deviation: 0.04182210690005945
#island_id: 2
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum(val for val in interacting_spins) / (len(interacting_spins) + 1e-6)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum(val for val in interacting_spins) / (len(interacting_spins) + 1e-6)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.47086020000000006}
#standard deviation: 0.044544776752836024
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_product
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_product
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate the total energy of the system
        total_energy = sum(J[d,i,j,k] for d in range(3)) + np.sum(h[i][j])
        
        # Add a term to the priority based on the total energy
        priorities[i*N*N+j*N+k][0] += -total_energy
        
  return(priorities)




#score: {'data3D.txt': -0.4760214000000002}
#standard deviation: 0.04375340514794249
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_product
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_product
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.47249460000000015}
#standard deviation: 0.04370218633935836
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(-h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4764046000000001}
#standard deviation: 0.04411033188313142
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          # New term: weighted average of neighboring spins
          neighbor_magnetism_coeff = sum(val * (i != site_nbr) for i, val in enumerate(interacting_spins)) / max(len(interacting_spins), 1e-6)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_product
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin+1 for spin in interacting_spins])
          
          neighbor_magnetism_coeff = sum(val * (i != site_nbr) for i, val in enumerate(interacting_spins)) / max(len(interacting_spins), 1e-6)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_product
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4500742000000002}
#standard deviation: 0.04356402064043217
#island_id: 3
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1765538}
#standard deviation: 0.04472083882889497
#island_id: 3
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 2
#generate time22:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5156242}
#standard deviation: 0.04193875360999657
#island_id: 2
#version_generated: 3
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum(val for val in interacting_spins) / (len(interacting_spins) + 1e-6)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum(val for val in interacting_spins) / (len(interacting_spins) + 1e-6)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.0009241999999999688}
#standard deviation: 0.29553961016141306
#island_id: 2
#version_generated: 3
#generate time22:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum(val for val in interacting_spins) / (len(interacting_spins) + 1e-6)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = sum(val for val in interacting_spins) / (len(interacting_spins) + 1e-6)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate the sum of all neighboring sites
        total_neighbors = sum(J[0,i,j,k] for i in range(N) for j in range(N) for k in [2,5])
        if total_neighbors > 0:
          priorities[i*N*N+j*N+k][1] += total_neighbors
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.0381454}
#standard deviation: 0.04681564630377328
#island_id: 0
#version_generated: 3
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N - 1) % N)) % N
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
      
      # Add new term to account for the magnetism of the site itself
      priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
      priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Add new term to account for the magnetism of the site itself
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0350346}
#standard deviation: 0.04695322398770929
#island_id: 0
#version_generated: 3
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0114414}
#standard deviation: 0.046507266593942075
#island_id: 0
#version_generated: 3
#generate time22:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    site_nbr = (i // N // N + ((i % N - 1) % N)) % N
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    for d in range(3):
      site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
      
      priorities[i][0] += np.exp(sum(val for val in site_neighbors) / 2)
      priorities[i][1] -= sum(val for val in site_neighbors if val < 0) / 2
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.5301078}
#standard deviation: 0.04167859905467074
#island_id: 0
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 2
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.08071260000000001}
#standard deviation: 0.04723026827406341
#island_id: 2
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] -= J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] -= J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] -= J[4,i,j,k-1]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] += J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] += J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] += J[4,i,j,k-1]
    
  return(priorities)




#score: {'data3D.txt': -0.47249460000000015}
#standard deviation: 0.04370218633935836
#island_id: 2
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(-h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.08071260000000001}
#standard deviation: 0.04723026827406341
#island_id: 2
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] -= J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] -= J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] -= J[4,i,j,k-1]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] += J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] += J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] += J[4,i,j,k-1]

  return(priorities)




#score: {'data3D.txt': -0.08071260000000001}
#standard deviation: 0.04723026827406341
#island_id: 2
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] -= J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] -= J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] -= J[4,i,j,k-1]
          
          # Add new term to account for the site's own magnetism
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] += J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] += J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] += J[4,i,j,k-1]
          
          # Add new term to account for the site's own magnetism
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism)
  
  return(priorities)




#score: {'data3D.txt': -0.08071260000000001}
#standard deviation: 0.04723026827406341
#island_id: 2
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] -= J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] -= J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] -= J[4,i,j,k-1]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] += J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] += J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] += J[4,i,j,k-1]
  
  return(priorities)




#score: {'data3D.txt': -0.08071260000000001}
#standard deviation: 0.04723026827406341
#island_id: 2
#version_generated: 3
#generate time22:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] -= J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] -= J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] -= J[4,i,j,k-1]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          
          # Consider interactions with neighboring sites that are already aligned
          if i>0:
            priorities[i*N*N+j*N+k][0] += J[1,i-1,j,k]
          if j>0:
            priorities[i*N*N+j*N+k][0] += J[2,i,j-1,k]
          if k>0:
            priorities[i*N*N+j*N+k][0] += J[4,i,j,k-1]
    
  return(priorities)




#score: {'data3D.txt': -0.0024218}
#standard deviation: 0.047253978930456214
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N//N//N,i//N%N//N,i%N//N] 
               for d in range(6)]
    
    total_spin = sum(J[d,i//N//N//N,i//N%N//N,i%N//N] 
             for d in range(6))
    
    site_nbr = (i // N // N + ((i % N - 1) % 2 - 1)) % N
    if h[i//N//N//N][i//N%N//N][i%N//N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.5081274000000001}
#standard deviation: 0.04250546940383084
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N//N][i//N%N][i%N] > 0:
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Add new term to account for the magnetism of the site itself
    priorities[i][0] += h[i//N//N][i//N%N][i%N]
    priorities[i][1] -= h[i//N//N][i//N%N][i%N]
    
  return(priorities)




#score: {'data3D.txt': -0.49481060000000016}
#standard deviation: 0.041296295325852175
#island_id: 0
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], 
               J[1,(i//N)%N,i//N//N,i%N], 
               J[2,i//N//N,(i//N)%N,i%N]]
    
    total_spin = sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
      
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Add new term to account for the interaction with the site's own magnetism
    priorities[i][0] += np.exp(h[i//N//N][i//N%N][i%N])
    priorities[i][1] -= h[i//N//N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.47249460000000015}
#standard deviation: 0.04370218633935836
#island_id: 2
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(-h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.47249460000000015}
#standard deviation: 0.04370218633935836
#island_id: 2
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(-h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
    
  return(priorities)




#score: {'data3D.txt': -0.47249460000000015}
#standard deviation: 0.04370218633935836
#island_id: 2
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # New term to account for the site's own magnetism
          site_magnetism = -h[i][j][k]
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # New term to account for the interaction with neighbors that are already aligned
          if np.linalg.norm(np.array(interacting_spins)) < 2:
            interacting_sites = [i, (i+1)%N, i]
            neighbor_magnetism_coeff = sum(-h[site][j,k] for site in interacting_sites) / len(interacting_sites)
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + neighbor_magnetism_coeff
    
  return(priorities)




#score: {'data3D.txt': -0.5063874}
#standard deviation: 0.04259410430141712
#island_id: 2
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      if site_nbr == N-1:
        priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      else:
        priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      if site_nbr == N-1:
        priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      else:
        priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
    
  return(priorities)




#score: {'data3D.txt': -0.0031282000000000003}
#standard deviation: 0.047014145156112325
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
      for d in range(3):
        site_neighbors = [J[d,i//N//N,(i//N)%N,i%N], J[d,(i//N)//N,i//N//N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,(i//N)%N,i%N] for d in [0,1,2])) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i][0] += neighbor_magnetism_coeff
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
    return(priorities)




#score: {'data3D.txt': -0.0031282000000000003}
#standard deviation: 0.047014145156112325
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
      for d in range(3):
        site_neighbors = [J[d,i//N//N,(i//N)%N,i%N], J[d,(i//N)//N,i//N//N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,(i//N)%N,i%N] for d in [0,1,2])) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i][0] += neighbor_magnetism_coeff
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
    return(priorities)




#score: {'data3D.txt': -0.0031282000000000003}
#standard deviation: 0.047014145156112325
#island_id: 0
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N//N,i//N%N,i%N], J[1,(i//N)%N,i//N//N,i%N], J[2,i//N//N,(i//N)%N,i%N]]
    
    site_nbr = (i // N // N + ((i % N // N - 1) % 2 - 1)) % N
    if h[i//N//N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] -= 2 - 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
      for d in range(3):
        site_neighbors = [J[d,i//N//N,(i//N)%N,i%N], J[d,(i//N)//N,i//N//N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,(i//N)%N,i%N] for d in [0,1,2])) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i][0] += neighbor_magnetism_coeff
    else:
      magnetism_coeff = np.exp(-abs(sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      
      priorities[i][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      priorities[i][1] = -2 + 2*sum(J[d,i//N//N,i//N%N,i%N] for d in [0,1,2])
      
    return(priorities)




#score: {'data3D.txt': -0.0314434}
#standard deviation: 0.04701701050088149
#island_id: 0
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    if i % N**2 < N//2:
      priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
      priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
  return(priorities)




#score: {'data3D.txt': -0.0081066}
#standard deviation: 0.04750140836270015
#island_id: 0
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
  return(priorities)




#score: {'data3D.txt': -0.029889799999999998}
#standard deviation: 0.04635762867058668
#island_id: 0
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][0] += np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] = 1 - total_spin - sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][1] -= np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0032145999999999997}
#standard deviation: 0.04697315559806473
#island_id: 1
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5214034000000001}
#standard deviation: 0.039812575255062314
#island_id: 1
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.4376382}
#standard deviation: 0.041611326592167194
#island_id: 1
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0023258000000000007}
#standard deviation: 0.04622900100975577
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and the site itself
    self_alignment = J[0,(i//N-1)%N,i//N%N,i%N] + J[1,(i//N-1)%N,i//N%N,i%N] + J[2,i//N//N,i//N//N,i%N]
    priorities[i][0] += np.exp(self_alignment)
    priorities[i][1] -= self_alignment
  
  return(priorities)




#score: {'data3D.txt': -0.033952600000000006}
#standard deviation: 0.04662244044706369
#island_id: 0
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    if h[i//N%N][i//N%N][i%N] > 0:
      priorities[i][0] += np.exp(neighbor_alignment)
      priorities[i][1] -= neighbor_alignment
    else:
      priorities[i][0] -= np.exp(neighbor_alignment)
      priorities[i][1] += neighbor_alignment
    
  return(priorities)




#score: {'data3D.txt': 0.007436600000000001}
#standard deviation: 0.045055510433686136
#island_id: 0
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and the site itself
    self_alignment = J[0,(i//N-1)%N,i//N%N,i%N] + J[1,(i//N-1)%N,i//N%N,i%N] + J[2,i//N//N,i//N//N,i%N]
    priorities[i][0] += np.exp(self_alignment)
    priorities[i][1] -= self_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and the site itself, considering the strength of the interaction
    neighbor_self_alignment = (J[0,(i//N-1)%N,i//N%N,i%N] + J[1,(i//N-1)%N,i//N%N,i%N] + J[2,i//N//N,i//N//N,i%N]) * np.exp(-abs(total_spin))
    priorities[i][0] += neighbor_self_alignment
    priorities[i][1] -= neighbor_self_alignment
    
  return(priorities)




#score: {'data3D.txt': 0.0021206}
#standard deviation: 0.046374677310359796
#island_id: 0
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and the site itself
    self_alignment = J[0,(i//N-1)%N,i//N%N,i%N] + J[1,(i//N-1)%N,i//N%N,i%N] + J[2,i//N//N,i//N//N,i%N]
    priorities[i][0] += np.exp(self_alignment)
    priorities[i][1] -= self_alignment
    
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 1
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2648334000000001}
#standard deviation: 0.043957664683647604
#island_id: 1
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i + k%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': 0.0023258000000000007}
#standard deviation: 0.04622900100975577
#island_id: 0
#version_generated: 3
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and the site itself
    self_alignment = J[0,(i//N-1)%N,i//N%N,i%N] + J[1,(i//N-1)%N,i//N%N,i%N] + J[2,i//N//N,i//N//N,i%N]
    priorities[i][0] += np.exp(self_alignment)
    priorities[i][1] -= self_alignment
  
  return(priorities)




#score: {'data3D.txt': -0.0347546}
#standard deviation: 0.04687751165367036
#island_id: 0
#version_generated: 3
#generate time23:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
  return(priorities)




#score: {'data3D.txt': -0.030905399999999996}
#standard deviation: 0.046465829712165896
#island_id: 0
#version_generated: 3
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][0] += np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] = 1 - total_spin - sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][1] -= np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    
    # Prioritize sites with higher magnetization
    if h[i//N%N][i//N%N][i%N] > 0:
      priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
      priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    else:
      priorities[i][0] -= np.exp(h[i//N%N][i//N%N][i%N])
      priorities[i][1] += h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.029889799999999998}
#standard deviation: 0.04635762867058668
#island_id: 0
#version_generated: 3
#generate time23:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][0] += np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] = 1 - total_spin - sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][1] -= np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.029889799999999998}
#standard deviation: 0.04635762867058668
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][0] += np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] = 1 - total_spin - sum(val for val in site_neighbors if val < 0)
      
      # Prioritize sites with fewer antiferromagnetic interactions
      antiferromagnetic_interactions = [val for val in interacting_spins if val < 0]
      priorities[i][1] -= np.exp(-len(antiferromagnetic_interactions) / max(len(interacting_spins), 1))
    
    # Prioritize sites with higher magnetization
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.005842600000000001}
#standard deviation: 0.04698640298256507
#island_id: 0
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      # Calculate ferromagnetic interactions
      ferromagnetic_interactions = [val for val in interacting_spins if val > 0]
      
      # Prioritize sites with more ferromagnetic interactions
      priorities[i][0] += np.exp(len(ferromagnetic_interactions) / max(len(interacting_spins), 1))
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
      
      # Calculate ferromagnetic interactions
      ferromagnetic_interactions = [val for val in interacting_spins if val > 0]
      
      # Prioritize sites with more ferromagnetic interactions
      priorities[i][1] -= np.exp(len(ferromagnetic_interactions) / max(len(interacting_spins), 1))
    
    # Calculate site's own magnetization
    magnetization = h[i//N%N][i//N%N][i%N]
    
    # Prioritize sites with same magnetization
    if i % (N**2) < N:
      priorities[i][0] += np.exp(magnetization)
      priorities[i][1] -= magnetization
    
    elif i % (N**2) >= N and i % (N**2) < 2*N:
      priorities[i][0] -= np.exp(magnetization)
      priorities[i][1] += magnetization
    else:
      priorities[i][0] = 0
      priorities[i][1] = 0
  
  return(priorities)




#score: {'data3D.txt': -0.0032145999999999997}
#standard deviation: 0.04697315559806473
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        return(priorities)




#score: {'data3D.txt': -0.0032145999999999997}
#standard deviation: 0.04697315559806473
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time23:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 2
#version_generated: 2
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 2
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 2
#version_generated: 3
#generate time23:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5061746}
#standard deviation: 0.03917750010962926
#island_id: 2
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 2
#version_generated: 3
#generate time23:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.21358900000000028}
#standard deviation: 0.04669823978481415
#island_id: 1
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Additional improvement: 
          # Prioritize assigning spin to sites with same magnetism as the current site
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin + sum(val for val in site_neighbors if val > 0)
          
        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.40825459999999997}
#standard deviation: 0.04242879704681716
#island_id: 1
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  return(priorities)




#score: {'data3D.txt': -0.4376382}
#standard deviation: 0.041611326592167194
#island_id: 1
#version_generated: 3
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4500742000000002}
#standard deviation: 0.04356402064043217
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          hamming_distance_neighbor = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k] + magnetism_coeff * spin_momentum * hamming_distance * (hamming_distance > 0.5) * 2
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          hamming_distance_neighbor = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k] - magnetism_coeff * spin_momentum * hamming_distance * (hamming_distance > 0.5) * -2

  return(priorities)




#score: {'data3D.txt': -0.305025}
#standard deviation: 0.044564711319608014
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][1] -= abs(np.sum(priorities[i*N*N+j*N+k]))
          else:
            priorities[i*N*N+j*N+k][1] += abs(np.sum(priorities[i*N*N+j*N+k]))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][1] += abs(np.sum(priorities[i*N*N+j*N+k]))
          else:
            priorities[i*N*N+j*N+k][1] -= abs(np.sum(priorities[i*N*N+j*N+k]))
  return(priorities)




#score: {'data3D.txt': -0.4500742000000002}
#standard deviation: 0.04356402064043217
#island_id: 3
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.4500742000000002}
#standard deviation: 0.04356402064043217
#island_id: 3
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0626974}
#standard deviation: 0.050300781636471614
#island_id: 3
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add another layer of interaction with the neighbors' spin
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * (len([val for val in site_neighbors if val > 0]) / max(len(site_neighbors), 1))
          
  return(priorities)




#score: {'data3D.txt': 0.1803786}
#standard deviation: 0.0449065694753006
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          neighbor_spin_momentum = sum((val > 0) * 2 - 1 for d, val in enumerate(J[:,i,j,k]) if d in [0,1])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k]) + neighbor_spin_momentum
          priorities[i*N*N+j*N+k][1] -= 2 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          neighbor_spin_momentum = sum((val < 0) * 2 - 1 for d, val in enumerate(J[:,i,j,k]) if d in [0,1])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k]) + neighbor_spin_momentum
          priorities[i*N*N+j*N+k][1] = -2 - h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0549358}
#standard deviation: 0.04673308633463019
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          neighbor_magnetism_coeff = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          neighbor_magnetism_coeff = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.49170820000000004}
#standard deviation: 0.041960672215301795
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0076938}
#standard deviation: 0.046868764455231804
#island_id: 2
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Use a more efficient way to compute the priority for each spin
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.2487098000000001}
#standard deviation: 0.04080967120622268
#island_id: 2
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.305025}
#standard deviation: 0.044564711319608014
#island_id: 3
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][1] -= abs(np.sum(priorities[i*N*N+j*N+k]))
          else:
            priorities[i*N*N+j*N+k][1] += abs(np.sum(priorities[i*N*N+j*N+k]))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][1] += abs(np.sum(priorities[i*N*N+j*N+k]))
          else:
            priorities[i*N*N+j*N+k][1] -= abs(np.sum(priorities[i*N*N+j*N+k]))

  # Add some magic
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i*N*N+j*N+k][0] > 10 or priorities[i*N*N+j*N+k][1] > 10:
          priorities[i*N*N+j*N+k][0] += np.sin(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= np.cos(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.30505979999999994}
#standard deviation: 0.04449248727549404
#island_id: 3
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][1] -= abs(np.sum(priorities[i*N*N+j*N+k]))
          else:
            priorities[i*N*N+j*N+k][1] += abs(np.sum(priorities[i*N*N+j*N+k]))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][1] += abs(np.sum(priorities[i*N*N+j*N+k]))
          else:
            priorities[i*N*N+j*N+k][1] -= abs(np.sum(priorities[i*N*N+j*N+k]))

        # Add a correction term to account for the site's own spin
        if i == j and k == 0: 
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
          else:
            priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.41509060000000003}
#standard deviation: 0.047822411395077105
#island_id: 3
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          site_energy = magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += site_energy + sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= site_energy - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          site_energy = magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= site_energy + sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -site_energy + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.29240740000000004}
#standard deviation: 0.039684603377632494
#island_id: 2
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Use a more efficient way to compute the priority for each spin
        site_neighbors = [(i + ((d-1)%2 - 1)) % N for d in range(3)]
        site_neighbors_values = [J[d,site_nbr,j,k] for d in range(3)]
        priorities[i*N*N+j*N+k][0] += sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(val for val in site_neighbors_values)

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5034318}
#standard deviation: 0.040818940563909785
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.5065818000000001}
#standard deviation: 0.040335947599628795
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.2141422}
#standard deviation: 0.04421215103520751
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > N/2))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > N/2))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0081066}
#standard deviation: 0.04750140836270015
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
  return(priorities)




#score: {'data3D.txt': -0.0081066}
#standard deviation: 0.04750140836270015
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add terms to prioritize sites with higher magnetization and fewer antiferromagnetic interactions
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
  return(priorities)




#score: {'data3D.txt': -0.006120199999999999}
#standard deviation: 0.047146163279316804
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and have the same magnetization
    neighbor_alignment_magnetism = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2]) * (total_spin > 0)
    priorities[i][0] += np.exp(neighbor_alignment_magnetism)
    priorities[i][1] -= neighbor_alignment_magnetism
    
  return(priorities)




#score: {'data3D.txt': -0.009688200000000001}
#standard deviation: 0.04659692372635773
#island_id: 0
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's magnetization
    if h[i//N%N][i//N%N][i%N] > 0:
      priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
      priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    else:
      priorities[i][1] += np.exp(-h[i//N%N][i//N%N][i%N])
      priorities[i][0] -= h[i//N%N][i//N%N][i%N]
  
  return(priorities)




#score: {'data3D.txt': -0.4674154}
#standard deviation: 0.03932124060657293
#island_id: 3
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3327961999999998}
#standard deviation: 0.04548874262452194
#island_id: 3
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3214574}
#standard deviation: 0.044334432050495476
#island_id: 1
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + k%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.3675022}
#standard deviation: 0.047495176967351116
#island_id: 1
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = ((i + k%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.006120199999999999}
#standard deviation: 0.047146163279316804
#island_id: 0
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and have the same magnetization
    neighbor_alignment_magnetism = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2]) * (total_spin > 0)
    priorities[i][0] += np.exp(neighbor_alignment_magnetism)
    priorities[i][1] -= neighbor_alignment_magnetism
    
  return(priorities)




#score: {'data3D.txt': -0.4376382}
#standard deviation: 0.041611326592167194
#island_id: 1
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4376382}
#standard deviation: 0.041611326592167194
#island_id: 1
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5107558000000001}
#standard deviation: 0.04210159814496358
#island_id: 1
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_magnetism = h[site_nbr % N, (j+1)%N, k]
        if site_magnetism == h[i][j][k]:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032145999999999997}
#standard deviation: 0.04697315559806473
#island_id: 1
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        return(priorities)




#score: {'data3D.txt': -0.2660954}
#standard deviation: 0.05121675017843283
#island_id: 2
#version_generated: 3
#generate time23:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
  return(priorities)




#score: {'data3D.txt': -0.45766819999999997}
#standard deviation: 0.042107309920725165
#island_id: 2
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.5034318}
#standard deviation: 0.040818940563909785
#island_id: 2
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5034318}
#standard deviation: 0.040818940563909785
#island_id: 2
#version_generated: 3
#generate time23:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) > N/2) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 2
#version_generated: 3
#generate time23:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4025982}
#standard deviation: 0.04234428647125844
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.46531020000000006}
#standard deviation: 0.04376238540070685
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(sum(J[d, i, j, k] for d in [0,1,2])))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d, i, j, k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d, i, j, k] for d in [0,1,2])

  # Additional improvement:
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.37640419999999997}
#standard deviation: 0.04219260340818045
#island_id: 1
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          if h[i][j][k] > 0:
            priorities[i*N + j][0] += np.exp(h[i][j][0])
            priorities[i*N + j][1] -= h[i][j][0]
          elif h[i][j][k] < 0:
            priorities[i*N + j][0] -= np.exp(h[i][j][0])
            priorities[i*N + j][1] = -h[i][j][0]

  return(priorities)




#score: {'data3D.txt': -0.025269}
#standard deviation: 0.04717097581140335
#island_id: 0
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      priorities[i][0] += -2 + 2*total_spin
      priorities[i][1] = -2 + 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] = -total_spin - sum(val for val in site_neighbors if val < 0) - np.exp(-len([val for val in site_neighbors if val < 0]) / max(len(interacting_spins), 1))
        
        if h[i//N%N][i//N%N][i%N] > 0:
          priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
          priorities[i][1] -= h[i//N%N][i//N%N][i%N]
        else:
          priorities[i][0] -= np.exp(h[i//N%N][i//N%N][i%N])
          priorities[i][1] += h[i//N%N][i//N%N][i%N]
    else:
      priorities[i][0] = -2 + 2*total_spin
      priorities[i][1] = -2 + 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] = -total_spin - sum(val for val in site_neighbors if val < 0) - np.exp(-len([val for val in site_neighbors if val < 0]) / max(len(interacting_spins), 1))
        
        if h[i//N%N][i//N%N][i%N] > 0:
          priorities[i][0] -= np.exp(h[i//N%N][i//N%N][i%N])
          priorities[i][1] += h[i//N%N][i//N%N][i%N]
        else:
          priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
          priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
  return(priorities)




#score: {'data3D.txt': 0.0066174}
#standard deviation: 0.04644285324180675
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add terms to prioritize sites with higher magnetization and fewer antiferromagnetic interactions
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors' neighbors
    neighbor_neighbor_alignment = sum(J[d,(i//N-2)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_neighbor_alignment)
    priorities[i][1] -= neighbor_neighbor_alignment
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add terms to prioritize sites with higher magnetization and fewer antiferromagnetic interactions
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize spins that are aligned with the site's neighbors and have higher magnetization
    neighbor_magnetism = sum(h[j//N%N][j//N%N][j%N] for j in range(N**3) if (abs(j-i) < 2 or abs((j//N)%N - (i//N)%N) < 2) and h[j//N%N][j//N%N][j%N] > 0)
    priorities[i][0] += np.exp(neighbor_magnetism)
    priorities[i][1] -= neighbor_magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.0094822}
#standard deviation: 0.047702045272294144
#island_id: 0
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i%N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add terms to prioritize sites with higher magnetization and fewer antiferromagnetic interactions
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
    # Add a term to prioritize sites with higher magnetization and fewer antiferromagnetic interactions
    site_magnetism = h[i//N%N][i//N%N][i%N]
    priorities[i][0] += np.exp(site_magnetism)
    priorities[i][1] -= site_magnetism
    
  return(priorities)




#score: {'data3D.txt': -0.0029433999999999997}
#standard deviation: 0.04576489698928645
#island_id: 0
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,i//N%N,i%N], J[1,(i//N)%N,i//N%N,i%N], J[2,i//N//N,i//N//N,i%N]]
    
    total_spin = sum(J[d,i//N%N,i//N%N,i%N] for d in [0,1,2])
    
    if h[i//N%N][i//N%N][i%N] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] += magnetism_coeff * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
      
      for d in range(3):
        site_neighbors = [J[d,i//N%N,(i//N)%N,i%N], J[d,(i//N-1)%N,i//N%N,i%N]]
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
    else:
      magnetism_coeff = np.exp(-abs(total_spin))
      
      # Prioritize spins that align with the site's magnetization
      priorities[i][0] -= magnetism_coeff * (total_spin > 0)
      priorities[i][1] = -2 + 2*total_spin
    
    # Add terms to prioritize sites with higher magnetization and fewer antiferromagnetic interactions
    priorities[i][0] += np.exp(h[i//N%N][i//N%N][i%N])
    priorities[i][1] -= h[i//N%N][i//N%N][i%N]
    
    # Add a term to prioritize spins that are aligned with the site's neighbors
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1,2])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
  # Add a term to prioritize spins that are aligned with the site's neighbors
  for i in range(N**3):
    site_neighbors = [J[0,(i//N-1)%N,i//N%N,i%N], J[1,(i//N-2)%N,i//N%N,i%N]]
    
    neighbor_alignment = sum(J[d,(i//N-1)%N,i//N%N,i%N] for d in [0,1])
    priorities[i][0] += np.exp(neighbor_alignment)
    priorities[i][1] -= neighbor_alignment
    
  return(priorities)




#score: {'data3D.txt': -0.0032145999999999997}
#standard deviation: 0.04697315559806473
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        return(priorities)




#score: {'data3D.txt': -0.0032145999999999997}
#standard deviation: 0.04697315559806473
#island_id: 1
#version_generated: 3
#generate time23:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        return(priorities)




#score: {'data3D.txt': -0.49170820000000004}
#standard deviation: 0.041960672215301795
#island_id: 3
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * 2 - total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 1 - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_momentum = (hamming_distance > 0.5) * -2 + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_momentum + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -1 - h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3214574}
#standard deviation: 0.044334432050495476
#island_id: 1
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.2648334000000001}
#standard deviation: 0.043957664683647604
#island_id: 1
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i * N ** 2 + j * N + k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N ** 2 + j * N + k][1] -= 2 - 2 * total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i * N ** 2 + j * N + k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = ((i + k % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N ** 2 + j * N + k][0] += 1
          priorities[i * N ** 2 + j * N + k][1] -= 1
        else:
          priorities[i * N ** 2 + j * N + k][0] -= 1
          priorities[i * N ** 2 + j * N + k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.26663060000000016}
#standard deviation: 0.04710107157634527
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i + k%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.32601739999999996}
#standard deviation: 0.04209001944927087
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i * N * N + j * N + k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i * N * N + j * N + k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i * N * N + j * N + k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = ((i + k % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= 1
          priorities[i * N * N + j * N + k][1] = -1
  
  return(priorities)




#score: {'data3D.txt': -0.2648334000000001}
#standard deviation: 0.043957664683647604
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i + k%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.30191060000000003}
#standard deviation: 0.041863098399903466
#island_id: 1
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i + k%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.5384482}
#standard deviation: 0.03923028672798607
#island_id: 1
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0086126}
#standard deviation: 0.06464166366392499
#island_id: 1
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  # Additional improvement:
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  # New term to account for the priority of assigning spin based on the interaction with neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.33680019999999994}
#standard deviation: 0.04460335906588202
#island_id: 1
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(sum(J[d, i, j, k] for d in [0,1,2])))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_magnetism = h[i][j][k]
        
        if site_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= sum(val for val in site_neighbors)
        
        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if site_magnetism > 0:
          priorities[i*N + j][0] += np.exp(h[i][j][k])
          priorities[i*N + j][1] -= h[i][j][k]
        elif site_magnetism < 0:
          priorities[i*N + j][0] -= np.exp(h[i][j][k])
          priorities[i*N + j][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.17546659999999997}
#standard deviation: 0.044820071446172415
#island_id: 1
#version_generated: 3
#generate time23:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




