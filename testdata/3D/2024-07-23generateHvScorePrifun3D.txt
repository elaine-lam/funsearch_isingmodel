#score: {'data3D.txt': -0.40740259999999995}
#standard deviation: 0.045946901889463675
#island_id: 0
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
  
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 2
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
  
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] *= np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] /= np.exp(neighbor_interactions)
        
  return(priorities)




#score: {'data3D.txt': -0.3451962000000004}
#standard deviation: 0.04847846476075742
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
  
  return(priorities)




#score: {'data3D.txt': -0.4729714000000001}
#standard deviation: 0.0415614747337002
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1
          elif site_neighbors[d] > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4417658}
#standard deviation: 0.0458808316223671
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5047486000000001}
#standard deviation: 0.04196969046871802
#island_id: 2
#version_generated: 2
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4485114000000001}
#standard deviation: 0.04620860212168292
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if sum(site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-sum(site_neighbors))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(sum(site_neighbors))
        
  return(priorities)




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        spin_direction = np.sign(total_spin)
        priorities[i*N*N+j*N+k][0] += np.exp(np.abs(neighbor_interactions))
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions * spin_direction
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0054962}
#standard deviation: 0.0470404088583422
#island_id: 0
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46619700000000014}
#standard deviation: 0.04364534008344992
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Calculate interactions with nearest neighbors
        neighbor_interactions = 0
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            neighbor_interactions -= 1
          elif J[d,i,(j+1)%N,k] > 0:
            neighbor_interactions += 1
          if J[d,(i+1)%N,j,k] < 0:
            neighbor_interactions -= 1
          elif J[d,(i+1)%N,j,k] > 0:
            neighbor_interactions += 1
        
        # Apply a correction factor based on the interactions with nearest neighbors
        correction_factor = np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
        
        # Calculate global interaction term
        global_interaction_term = 0
        for d in range(3):
          for p in range(N):
            if i != p:
              global_interaction_term += J[d,i,p,k]
            if j != p:
              global_interaction_term += J[d,(i+1)%N,p,k]
            if k != p:
              global_interaction_term += J[d,i,(p+1)%N,k]
        
        # Apply the global interaction term
        priorities[i*N*N+j*N+k][0] *= np.exp(global_interaction_term)
        priorities[i*N*N+j*N+k][1] /= np.exp(-global_interaction_term)
  
  return(priorities)




#score: {'data3D.txt': -0.0028385999999999997}
#standard deviation: 0.04802368988363972
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the number of nearest neighbors that are aligned with the site's spin
        aligned_neighbors = len([val for val in interacting_spins if val == h[i][j][k]])
        
        # Calculate the number of nearest neighbors that are anti-aligned with the site's spin
        anti_aligned_neighbors = len([val for val in interacting_spins if val != h[i][j][k]])
        
        # Calculate the priority for aligning with the site's spin
        priorities[i*N*N+j*N+k][0] += (aligned_neighbors - anti_aligned_neighbors) + total_spin
        
        # Calculate the priority for anti-aligning with the site's spin
        priorities[i*N*N+j*N+k][1] -= (aligned_neighbors - anti_aligned_neighbors) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3331246000000001}
#standard deviation: 0.049684819762579394
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          correction_factor = np.exp(-hamming_distance)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * correction_factor + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          correction_factor = np.exp(hamming_distance)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * correction_factor + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          if J[d,i,(j+1)%N,k] < 0:
            correction_factor *= np.exp(-1)
          elif J[d,i,(j+1)%N,k] > 0:
            correction_factor *= np.exp(1)
          if J[d,(i+1)%N,j,k] < 0:
            correction_factor *= np.exp(-1)
          elif J[d,(i+1)%N,j,k] > 0:
            correction_factor *= np.exp(1)
        
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
  
  return(priorities)




#score: {'data3D.txt': 0.06680019999999999}
#standard deviation: 0.04595268653691534
#island_id: 0
#version_generated: 3
#generate time00:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate site magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Update priorities based on total spin and magnetism
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        interacting_spins = [J[d,i,j,k] for d in range(3)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2292738}
#standard deviation: 0.04437445158601964
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Calculate the total interaction and magnetism at this site
        total_interaction = abs(total_spin) + len([val for val in interacting_spins + site_neighbors if val < 0]) / max(len(interacting_spins) + len(site_neighbors), 1)
        priorities[i*N*N+j*N+k][0] += np.exp(-total_interaction)
        priorities[i*N*N+j*N+k][1] /= np.exp(total_interaction)
        
  return(priorities)




#score: {'data3D.txt': -0.38830340000000013}
#standard deviation: 0.04935837343794871
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Add new terms to account for the magnetism of nearest neighbors
        for d in range(3):
          if h[(i+(d-1)%2)%N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3762461999999999}
#standard deviation: 0.046344009165802655
#island_id: 0
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_interactions = sum([1 if val > 0 else -1 for val in site_neighbors])
        correction_factor = np.exp(neighbor_interactions)
        
        # Apply a correction factor based on the interactions with nearest neighbors
        priorities[i*N*N+j*N+k][0] *= correction_factor
        priorities[i*N*N+j*N+k][1] /= correction_factor
        
        # Calculate magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        
        # Apply a correction factor based on the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] *= site_magnetism
        priorities[i*N*N+j*N+k][1] /= site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.0027874000000000006}
#standard deviation: 0.04714104582251013
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,(i+1)%N,j,k] for d in [0,1,2]] + [J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,(i+1)%N,(j+1)%N,k] for d in [0,1,2]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
  return(priorities)




#score: {'data3D.txt': -0.0026250000000000006}
#standard deviation: 0.047152420669569026
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term to account for the magnetism of the neighboring sites
        neighbor_magnetisms = [h[(i+1)%N,j,k], h[i,(j+1)%N,k], h[(i+1)%N,(j+1)%N,k]]
        neighbor_interactions_3 = sum(val for val in neighbor_magnetisms if val > 0) - sum(val for val in neighbor_magnetisms if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_3)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_3
        
  return(priorities)




#score: {'data3D.txt': -0.0024118000000000004}
#standard deviation: 0.0470862882457303
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        site_neighbors_3 = [J[0,(i+1)%N,j,k], J[1,i,(j-1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_3 = sum(val for val in site_neighbors_3 if val > 0) - sum(val for val in site_neighbors_3 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_3)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_3
        
        site_neighbors_4 = [J[0,(i-1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i-1)%N,j,k]]
        neighbor_interactions_4 = sum(val for val in site_neighbors_4 if val > 0) - sum(val for val in site_neighbors_4 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_4)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_4
        
  return(priorities)




#score: {'data3D.txt': -0.0054962}
#standard deviation: 0.0470404088583422
#island_id: 0
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        site_neighbors_2 = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,(i+1)%N,j,k]]
        neighbor_interactions_2 = sum(val for val in site_neighbors_2 if val > 0) - sum(val for val in site_neighbors_2 if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions_2)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions_2
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1279966}
#standard deviation: 0.04731491042409359
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time01:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4726186000000001}
#standard deviation: 0.043792140094313724
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4602142000000001}
#standard deviation: 0.04591407277033916
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4978050000000001}
#standard deviation: 0.041850553341622625
#island_id: 1
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3248442000000003}
#standard deviation: 0.04740781630026845
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0) - sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0) - sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1203474}
#standard deviation: 0.04623292239562626
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a penalty term based on the number of neighbors with opposite spin
        neighbor_spin_count = sum(1 for val in site_neighbors if (val > 0 and total_spin < 0) or (val < 0 and total_spin > 0))
        priorities[i*N*N+j*N+k][0] -= np.exp(-neighbor_spin_count)
        priorities[i*N*N+j*N+k][1] += neighbor_spin_count
  
  return(priorities)




#score: {'data3D.txt': -0.0874326}
#standard deviation: 0.046644302730773024
#island_id: 0
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_interactions = sum(val for val in site_neighbors if val > 0) - sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(neighbor_interactions)
        priorities[i*N*N+j*N+k][1] -= neighbor_interactions
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4141906}
#standard deviation: 0.05038262509675335
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3226678}
#standard deviation: 0.053510233069572775
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          if h[(i+1)%N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

          if h[i][(j+1)%N][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

          if h[i][j][(k+1)%N] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          if h[(i+1)%N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

          if h[i][(j+1)%N][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

          if h[i][j][(k+1)%N] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.44783820000000013}
#standard deviation: 0.04591300666216491
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
        for site_n in site_nbrs:
          if h[site_n[0]][site_n[1]][site_n[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3905534}
#standard deviation: 0.049425536197799616
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.38109659999999995}
#standard deviation: 0.050978749969374494
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.32182499999999997}
#standard deviation: 0.053180989601548406
#island_id: 1
#version_generated: 3
#generate time01:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  # Add a new term to account for the magnetism of the site itself
  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.3048578}
#standard deviation: 0.0457991194146787
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          spin_momentum = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + spin_momentum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          spin_momentum = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + spin_momentum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
 
  return(priorities)




#score: {'data3D.txt': -0.34557060000000034}
#standard deviation: 0.04831780516165856
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          spin_magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism_coeff + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          spin_magnetism_coeff = np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism_coeff + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
  return(priorities)




#score: {'data3D.txt': -0.36841980000000024}
#standard deviation: 0.046227664963309587
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2701854000000002}
#standard deviation: 0.04644936325548498
#island_id: 0
#version_generated: 3
#generate time01:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] > 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] > 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k] - neighbor_interactions
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_interactions = sum(1 if J[d,i,(j+1)%N,k] < 0 else -1 for d in range(3)) + sum(1 if J[d,(i+1)%N,j,k] < 0 else -1 for d in range(3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][k]) + np.exp(neighbor_interactions)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k] - neighbor_interactions

        # additional terms to improve the priority
        if i > 0 and J[0,i-1,j,k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
        if j > 0 and J[1,i,j-1,k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4685342000000001}
#standard deviation: 0.04236474230253266
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4193362000000001}
#standard deviation: 0.04832699090115171
#island_id: 1
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbrs = [(i + 1) % N, (i + N // 2) % N, i - 1]
        neighbor_spins = []
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            neighbor_spins.append(1)
          else:
            neighbor_spins.append(-1)

        priority_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += priority_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          for spin in neighbor_spins:
            priorities[i * N * N + j * N + k][0] += priority_coeff * (spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= priority_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          for spin in neighbor_spins:
            priorities[i * N * N + j * N + k][0] -= priority_coeff * (spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.17992019999999997}
#standard deviation: 0.05503476421281371
#island_id: 1
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        # Calculate the total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Adjust the priority based on the current spin configuration
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Calculate the priority for the site's nearest neighbors
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Calculate the priority for the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 2
        else:
          priorities[i*N*N+j*N+k][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          interaction_energy = sum(val for val in interacting_spins)

          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - interaction_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          interaction_energy = sum(val for val in interacting_spins)

          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - interaction_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.48485700000000004}
#standard deviation: 0.04081433168630843
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2867942}
#standard deviation: 0.05354074566496063
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1, (j+1)%N, j-1, (k+1)%N, k-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1, (j+1)%N, j-1, (k+1)%N, k-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.1142546}
#standard deviation: 0.059417206420699385
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.26736180000000004}
#standard deviation: 0.05206144850808514
#island_id: 1
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.34742700000000004}
#standard deviation: 0.1568399253729739
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  # Calculate the energy of the system
  energy = np.sum([J[0,i,j,k]*h[i][j][k] for i in range(N) for j in range(N) for k in range(N)])

  # Adjust priorities based on energy
  if energy > 0:
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  else:
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.37213419999999997}
#standard deviation: 0.047611363668351274
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.4498594000000001}
#standard deviation: 0.041413986425361184
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_diff = np.sum(np.abs(J[:, i, j, k] - h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - spin_diff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          spin_diff = np.sum(np.abs(J[:, i, j, k] - h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff + spin_diff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 2
#generate time01:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the interaction with nearest neighbors
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3271978}
#standard deviation: 0.05222550598280499
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  # Add a new term to account for the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k]]
      
      if sum(site_neighbors) > 0:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(site_neighbors)))
      else:
        priorities[i*N*N+j*N+k][0] += np.exp(abs(sum(site_neighbors)))
  
  # Add a new term to account for the magnetism of the site itself
  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.13806300000000002}
#standard deviation: 0.05851635934505837
#island_id: 1
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        total_magnetism = 0
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_magnetism += 1
          else:
            total_magnetism -= 1
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the total magnetism of the site's neighbors
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_magnetism))
        priorities[i*N*N+j*N+k][1] -= total_magnetism
  
  return priorities




#score: {'data3D.txt': -0.2519342}
#standard deviation: 0.05623690843529719
#island_id: 1
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.291071}
#standard deviation: 0.05519913295514704
#island_id: 1
#version_generated: 3
#generate time01:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = 2 * total_spin

          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4614326000000001}
#standard deviation: 0.045103714450585995
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45927260000000014}
#standard deviation: 0.045598797892488344
#island_id: 1
#version_generated: 3
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (np.sum(interacting_spins) > 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (np.sum(interacting_spins) < 0)
          
  return(priorities)




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 2
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032206}
#standard deviation: 0.046944338270338844
#island_id: 0
#version_generated: 2
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*neighbor_magnetism_coeff
        
        return(priorities)




#score: {'data3D.txt': -0.3320593999999998}
#standard deviation: 0.0471302462505767
#island_id: 3
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.369719}
#standard deviation: 0.044226698260213824
#island_id: 3
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.4735522000000001}
#standard deviation: 0.04310466233668928
#island_id: 3
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4600786000000001}
#standard deviation: 0.042392909100933386
#island_id: 3
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the priority based on the magnetism and interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k] - 2*total_spin + 2*len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k]) - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 2*h[i][j][k] + 2*total_spin - 2*len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.11762059999999988}
#standard deviation: 0.04652693516276351
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priority_down = magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4735522000000001}
#standard deviation: 0.04310466233668928
#island_id: 3
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.202993}
#standard deviation: 0.04394274810477834
#island_id: 3
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
        # Add new term to account for the interactions between neighboring sites
        if i > 0 and j < N-1:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if i < N-1 and j < N-1:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i+1,j,k], J[1,(i+2)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': 0.44966380000000017}
#standard deviation: 0.04216105180803724
#island_id: 3
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42001459999999996}
#standard deviation: 0.04032370700766486
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_one_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0 and val != J[2,i,j,k]]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff + spin_one_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          spin_one_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0 and val != J[2,i,j,k]]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - spin_one_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

  return(priorities)




#score: {'data3D.txt': -0.4603306}
#standard deviation: 0.04146706962928536
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance
        
        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

        # Add the site's own energy
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= h[i][j][k]
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.016854199999999986}
#standard deviation: 0.04643350409305763
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field and its interaction with neighboring sites
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49628780000000006}
#standard deviation: 0.0421918552704192
#island_id: 2
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance

        # Add the site's own magnetic field
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0420902}
#standard deviation: 0.04888815627490978
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          spin_momentum = np.sum(np.sign(J[:, i, j, k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor + spin_momentum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor + 2 * spin_momentum
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          spin_momentum = -np.sum(np.sign(J[:, i, j, k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor - spin_momentum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor - 2 * spin_momentum

  return(priorities)




#score: {'data3D.txt': -0.2915442}
#standard deviation: 0.04593693640590325
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          total_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][0] += total_magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          total_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) - neighbor_magnetism_coeff - hamming_distance_neighbor
          priorities[i*N*N+j*N+k][0] -= total_magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.41112620000000005}
#standard deviation: 0.04537325152069224
#island_id: 2
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          interaction_coeff = np.exp(-abs(sum(J[d,i-1,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor + interaction_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          interaction_coeff = np.exp(-abs(sum(J[d,i-1,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor + interaction_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.4574122}
#standard deviation: 0.04037831956830299
#island_id: 2
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          neighbor_magnetism_coeff_neighbor = np.exp(-abs(total_spin) * (len([val for val in [J[0,(i+2)%N,(j+1)%N,k], J[1,(i+3)%N,j,k]] if val < 0]) > len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - hamming_distance_neighbor + neighbor_magnetism_coeff_neighbor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + total_spin * hamming_distance - 2 * hamming_distance_neighbor + 2 * hamming_distance_neighbor
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance_neighbor = len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) / max(len([J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]), 1)
          neighbor_magnetism_coeff_neighbor = np.exp(-abs(total_spin) * (len([val for val in [J[0,(i+2)%N,(j+1)%N,k], J[1,(i+3)%N,j,k]] if val > 0]) > len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff - hamming_distance_neighbor - neighbor_magnetism_coeff_neighbor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - total_spin * hamming_distance + 2 * hamming_distance_neighbor - 2 * hamming_distance_neighbor

  return(priorities)




#score: {'data3D.txt': -0.1124721999999998}
#standard deviation: 0.04857199879724944
#island_id: 3
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          spin_interaction = sum(val * (val > 0) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + spin_interaction
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism - 2*spin_interaction
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          spin_interaction = sum(val * (val < 0) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism + spin_interaction
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism + 2*spin_interaction
 
  return(priorities)




#score: {'data3D.txt': -0.3952034}
#standard deviation: 0.039632099470504965
#island_id: 3
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism
        
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.11302140000000031}
#standard deviation: 0.05066004877652607
#island_id: 3
#version_generated: 3
#generate time02:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = np.exp(h[i][j][k])
          spin_flip_energy = total_spin - (2 * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - 1
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*site_magnetism + spin_flip_energy
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = -np.exp(h[i][j][k])
          spin_flip_energy = total_spin + (2 * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - 1
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*site_magnetism + spin_flip_energy
  
  return(priorities)




#score: {'data3D.txt': -0.3801018}
#standard deviation: 0.04297974588989562
#island_id: 2
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4131354}
#standard deviation: 0.042284133511755924
#island_id: 2
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Add new term to account for the interaction energy
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - sum(val for val in interacting_spins) - 2*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) - h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.45693060000000013}
#standard deviation: 0.044703267259116525
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4978050000000001}
#standard deviation: 0.041850553341622625
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbrs = [(i+((k-1)%2 - 1)) % N]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4685342000000001}
#standard deviation: 0.04236474230253266
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4685342000000001}
#standard deviation: 0.04236474230253266
#island_id: 1
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.522069}
#standard deviation: 0.04021413680535739
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.5165330000000001}
#standard deviation: 0.041863485175030524
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)

  return(priorities)




#score: {'data3D.txt': -0.26515819999999996}
#standard deviation: 0.05373697249343324
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        # Calculate the total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Adjust the priority based on the current spin configuration
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (interacting_spins[d] > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (interacting_spins[d] < 0)

        # Calculate the priority for the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 2
        else:
          priorities[i*N*N+j*N+k][0] += 2

  return(priorities)




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 3
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = 2 * (total_spin > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - spin_magnetism
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = 2 * (total_spin < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - spin_magnetism

  return(priorities)




#score: {'data3D.txt': -0.09202940000000003}
#standard deviation: 0.047167006006741626
#island_id: 0
#version_generated: 3
#generate time02:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d,i,j,k] for d in [0,1,2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47611100000000023}
#standard deviation: 0.04507564795984635
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4887886000000001}
#standard deviation: 0.04195160437980889
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      priorities[i*N*N+j*N+site_nbr][0] += np.sum(h[i][j])
      priorities[i*N*N+j*N+site_nbr][1] -= np.sum(h[i][j])

  return(priorities)




#score: {'data3D.txt': -0.49035540000000016}
#standard deviation: 0.0423780137670467
#island_id: 0
#version_generated: 3
#generate time02:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])

  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 2
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.1665762}
#standard deviation: 0.04490993245998039
#island_id: 2
#version_generated: 2
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3327646000000001}
#standard deviation: 0.05184213408840342
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
        for site_n in site_nbrs:
          if h[site_n[0]][site_n[1]][site_n[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': 0.0359422}
#standard deviation: 0.04608822299850581
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] < 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4303966}
#standard deviation: 0.04767132752965875
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i, j, k), ((i+1)%N, j, k), (i, (j+1)%N, k), (i, j, (k+1)%N)]
          for site_n in site_nbrs:
            if h[site_n[0]][site_n[1]][site_n[2]] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.26736180000000004}
#standard deviation: 0.05206144850808514
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.3814374}
#standard deviation: 0.04635285278426777
#island_id: 0
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])

        # Add new term based on the interactions with neighboring sites
        x = (i+1)%N
        y = (j+1)%N
        z = (k+1)%N
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in [J[0, i, j, k], J[1, x, j, k], J[2, i, y, k]]])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in [J[0, i, j, k], J[1, x, j, k], J[2, i, y, k]]])

  return(priorities)




#score: {'data3D.txt': 0.1633721999999999}
#standard deviation: 0.04829963878912554
#island_id: 0
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the Hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the priority based on the total spin and interaction with nearest neighbors
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
        
        # Calculate the priority based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.295939}
#standard deviation: 0.04635413680568326
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': -0.4754686}
#standard deviation: 0.042276684520430416
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': -0.14262819999999998}
#standard deviation: 0.0494331617920602
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3807346}
#standard deviation: 0.05089820903371749
#island_id: 1
#version_generated: 3
#generate time02:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new terms to account for interactions with more distant neighbors
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 2
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4928182000000001}
#standard deviation: 0.04188012355234879
#island_id: 0
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*N+j*N+site_nbr][0] += h[i][j][k]
        priorities[i*N*N+j*N+site_nbr][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47943380000000013}
#standard deviation: 0.042432067326021256
#island_id: 0
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[i][j])
      if total_spin > 0:
        priorities[i*N*N+j*N+(N-1)%N][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+(N-1)%N][0] -= np.exp(abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4633830000000001}
#standard deviation: 0.04219841028996235
#island_id: 0
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][site_nbr][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N*N+j*N+site_nbr][0] += np.exp(h[i][j][0]) * (total_spin > 0) + total_spin
      priorities[i*N*N+j*N+site_nbr][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.14262819999999998}
#standard deviation: 0.0494331617920602
#island_id: 0
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.40609340000000005}
#standard deviation: 0.044437328862567786
#island_id: 0
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3566366000000001}
#standard deviation: 0.04640450646693702
#island_id: 0
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': 0.00021579999999999877}
#standard deviation: 0.049124103557825864
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))

  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k]]
      if sum(site_neighbors) > 0:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(site_neighbors)))
      else:
        priorities[i*N*N+j*N+k][0] += np.exp(abs(sum(site_neighbors)))

  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2

  return priorities




#score: {'data3D.txt': -0.4010994}
#standard deviation: 0.050085273680394324
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  # Add new term to account for the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,j,k], J[4,i,j,k]]
      
      if sum(site_neighbors) < 0:
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3216474}
#standard deviation: 0.05305951783836713
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        
  # Add a new term to account for the interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_neighbors = [J[3,i,(j+1)%N,k], J[4,i,j,(k+1)%N]]
      if sum(site_neighbors) < 0:
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        
  # Add a new term to account for the magnetism of the site itself
  for i in range(N**3):
    if h[(i//N)%N][i%N][i//N%N] > 0:
      priorities[i][0] -= 2
    else:
      priorities[i][0] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = ((i+N//2)%N, j, k)
        if h[site_nbr[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.4041646}
#standard deviation: 0.04979714757734624
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          site_nbr = ((i+N//2)%N, j, k)
          if h[site_nbr[0]][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.08440340000000003}
#standard deviation: 0.0479370498512372
#island_id: 1
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += total_spin
          for d in range(6):
            if J[d, i, j, k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][1] -= total_spin
          for d in range(6):
            if J[d, i, j, k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.13852699999999998}
#standard deviation: 0.0471857943771216
#island_id: 2
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          for d in [0,1,2]:
            total_spin += J[d,i,j,k]
          
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          product_nn_spins = np.prod([1 if val > 0 else -1 for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += total_spin + hamming_distance * (product_nn_spins > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          product_nn_spins = np.prod([1 if val < 0 else -1 for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= total_spin - hamming_distance * (product_nn_spins > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4698538}
#standard deviation: 0.043346520339699705
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': -0.4754686}
#standard deviation: 0.042276684520430416
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
  return(priorities)




#score: {'data3D.txt': 0.005487400000000038}
#standard deviation: 0.04593803741171362
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.012072199999999998}
#standard deviation: 0.046347625906404316
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.26736180000000004}
#standard deviation: 0.05206144850808514
#island_id: 1
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.4948926000000001}
#standard deviation: 0.041534394725817304
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44190340000000006}
#standard deviation: 0.042192223791120566
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i * N * N + j * N + k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i * N * N + j * N + k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add new term to account for the interaction with nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i * N * N + j * N + k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.3299309999999999}
#standard deviation: 0.05167073290558206
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.24798780000000012}
#standard deviation: 0.04196199388923268
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.5062838000000001}
#standard deviation: 0.03923239755049391
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3299309999999999}
#standard deviation: 0.05167073290558206
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.40406460000000005}
#standard deviation: 0.04037921577792219
#island_id: 2
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2 * h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(2 * abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2 * h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.49326660000000017}
#standard deviation: 0.042151469777933014
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5158454}
#standard deviation: 0.040918444482164765
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47943380000000013}
#standard deviation: 0.042432067326021256
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[i][j])
      if total_spin > 0:
        priorities[i*N*N+j*N+(N-1)%N][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+(N-1)%N][0] -= np.exp(abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4762682000000001}
#standard deviation: 0.04253938256204479
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interaction energies
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0, 1, 2]]
        total_spin = sum(J[d,i,j,k] for d in [0, 1, 2])
        
        # Calculate magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  # Calculate sum of magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[i][j])
      if total_spin > 0:
        priorities[i*N*N+j*N+(N-1)%N][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+(N-1)%N][0] -= np.exp(abs(total_spin))
        priorities[i*N*N+j*N+(N-1)%N][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0666858}
#standard deviation: 0.04554373412841771
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]

        if h[i][j][k] > 0:
          total_spin += sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin += sum(val for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.045197799999999996}
#standard deviation: 0.04634179059078317
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          total_spin = sum([spin for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin = sum([-spin for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1665762}
#standard deviation: 0.04490993245998039
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(3):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum([h[i][j][k] for _ in range(3)])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': 0.020803}
#standard deviation: 0.04722892790441045
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Adjust the priority based on the current spin configuration
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.3243522}
#standard deviation: 0.052841384493217056
#island_id: 1
#version_generated: 3
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add new term to account for the interaction with nearest neighbors and the site itself
          site_nbrs = [(i+1)%N, (i+N//2)%N, i-1]
          for site_nbr in site_nbrs:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.5092390000000001}
#standard deviation: 0.04229245652595744
#island_id: 0
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time03:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time03:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 2
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2968166}
#standard deviation: 0.05064356231980527
#island_id: 0
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins]) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.26278660000000026}
#standard deviation: 0.048691633166695086
#island_id: 0
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.29275419999999985}
#standard deviation: 0.04583936585905174
#island_id: 0
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.197047}
#standard deviation: 0.043548427193183456
#island_id: 2
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New term: total spin as priority
        priorities[i*N*N+j*N+k][0] += abs(total_spin)
        priorities[i*N*N+j*N+k][1] -= abs(total_spin)
  return(priorities)




#score: {'data3D.txt': -0.10297900000000001}
#standard deviation: 0.04602823740922523
#island_id: 0
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0419438}
#standard deviation: 0.04699386514812332
#island_id: 0
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the interactions between sites with opposite spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val < 0]) > len([val for val in interacting_sites if val > 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.04459620000000008}
#standard deviation: 0.0460634400100557
#island_id: 0
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the interactions between sites with same spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val > 0]) > len([val for val in interacting_sites if val < 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the interactions between sites with opposite spin
        interacting_sites = [J[d, i, j, k] for d in [0, 1, 2]]
        if len([val for val in interacting_sites if val < 0]) > len([val for val in interacting_sites if val > 0]):
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4963170000000001}
#standard deviation: 0.04316967397375153
#island_id: 2
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time03:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time03:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44362739999999995}
#standard deviation: 0.03977777280391651
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        neighbor_magnetism = np.sum([np.exp(J[d,i,j,k]) for d in range(6)])
        priorities[i*N*N+j*N+k][0] += (site_magnetism + neighbor_magnetism) / 2
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0399698}
#standard deviation: 0.04229016159770497
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_priority = total_spin + magnetism_coeff * (hamming_distance > 0.5) - np.sum(np.abs(np.array(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += spin_priority
          priorities[i*N*N+j*N+k][1] -= spin_priority
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_priority = total_spin - magnetism_coeff * (hamming_distance > 0.5) + np.sum(np.abs(np.array(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= spin_priority
          priorities[i*N*N+j*N+k][1] += spin_priority

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3488982000000003}
#standard deviation: 0.04956468497589791
#island_id: 3
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 2
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 2
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -magnetism_coeff * (hamming_distance > 0.5) + total_spin
        
        # Add new term to account for the magnetism of the site itself
        priority += h[i][j][k]
        
        priorities[i*N*N+j*N+k][0] = max(priority, -priority)
        priorities[i*N*N+j*N+k][1] = min(-priority, priority)
  
  return(priorities)




#score: {'data3D.txt': -0.49638780000000005}
#standard deviation: 0.04327271994178319
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
    
  return(priorities)




#score: {'data3D.txt': -0.48983620000000005}
#standard deviation: 0.04385528211698108
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4459802000000001}
#standard deviation: 0.046929387466277464
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself and its interactions with neighboring sites
        if h[i][j][k] > 0:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4980958000000001}
#standard deviation: 0.041922611349485384
#island_id: 2
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47006340000000013}
#standard deviation: 0.041506850765144786
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.369719}
#standard deviation: 0.044226698260213824
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_magnetism = total_spin + np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_magnetism
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_magnetism = total_spin - np.exp(h[i][j][k])
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_magnetism
          
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3681498}
#standard deviation: 0.04157801245802883
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself and its neighbors
        for d in [0, 1, 2]:
          site_nbr = (i + ((d-1)%3 - 1)) % N
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4516142000000001}
#standard deviation: 0.04241684097572567
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      total_spin = sum(h[site_nbr][i][j] for _ in range(3))
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+0][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+0][0] -= np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+0][1] = -2 + 2*total_spin

      site_nbr = (i + ((1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][i][j] for _ in range(3))
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+1][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+1][1] -= 2 - 2*total_spin
      else:
        priorities[i*N*N+j*N+1][0] -= np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+1][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5026058000000001}
#standard deviation: 0.04182517144447827
#island_id: 1
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff * (hamming_distance > 0.5) + total_spin) * np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.39928179999999996}
#standard deviation: 0.04025387619546719
#island_id: 1
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add a new term based on the number of interacting spins with the same sign as the site's magnetism
        same_sign_spins = sum(1 for val in interacting_spins if np.sign(val) == np.sign(h[i][j][k]))
        priorities[i*N*N+j*N+k][0] += 2 * same_sign_spins
        
  return(priorities)




#score: {'data3D.txt': -0.49402660000000015}
#standard deviation: 0.04117793064786039
#island_id: 1
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i+1)%N if k == 0 else i, (i+N-1)%N if k == 2 else i]
        for x, y, z in itertools.product(site_nbrs, [j], [k]):
          interacting_spins.append(J[0,x,y,z])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4980958000000001}
#standard deviation: 0.041922611349485384
#island_id: 2
#version_generated: 3
#generate time04:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,(j+1)%N,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  # Add new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.38553980000000027}
#standard deviation: 0.04990493218069733
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.09690340000000004}
#standard deviation: 0.10488410131397426
#island_id: 1
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  h_flipped = np.sign(h) * 2 - 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h_flipped[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h_flipped[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h_flipped[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h_flipped[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h_flipped[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.002457}
#standard deviation: 0.050273260397551305
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the sum of interactions for each site
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))

  # Initialize a variable to store the priority values
  priority_total = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_total[i*N*N+j*N+k][0] += total_spin_sum[i]*h[i][j][k]
          priority_total[i*N*N+j*N+k][1] -= total_spin_sum[i]*h[i][j][k]
        else:
          priority_total[i*N*N+j*N+k][0] -= total_spin_sum[i]*h[i][j][k]
          priority_total[i*N*N+j*N+k][1] += total_spin_sum[i]*h[i][j][k]

  return priority_total




#score: {'data3D.txt': -0.26090140000000006}
#standard deviation: 0.09190871600691639
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.026562199999999998}
#standard deviation: 0.046786962833250886
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.026562199999999998}
#standard deviation: 0.046786962833250886
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0005418000000000004}
#standard deviation: 0.04608222751517118
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        if J[0][i//N][(j+k)%N][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = total_spin * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_product + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = total_spin * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_product + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.48695220000000006}
#standard deviation: 0.04384030833787555
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
          for d in [0,1,2]:
            if J[d,i,j,k] == J[0,i,j,k]:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
          for d in [0,1,2]:
            if J[d,i,j,k] == J[0,i,j,k]:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
  return(priorities)




#score: {'data3D.txt': -0.44698940000000004}
#standard deviation: 0.04191031099431261
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
  
  # Add a bias term to the priority based on the sign of h[i][j][k]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -2
  
  return(priorities)




#score: {'data3D.txt': -0.4648546}
#standard deviation: 0.044091238345503526
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff

  for i in range(N):
    for j in range(N):
      if h[0][j][k] > 0:
        priorities[j*N*N+i*N+k][0] += total_spin
        priorities[j*N*N+i*N+k][1] -= -total_spin
      else:
        priorities[j*N*N+i*N+k][0] -= total_spin
        priorities[j*N*N+i*N+k][1] = -total_spin

  for j in range(N):
    if h[i][0][k] > 0:
      priorities[i*N*N+j*N+k][0] += total_spin
      priorities[i*N*N+j*N+k][1] -= -total_spin
    else:
      priorities[i*N*N+j*N+k][0] -= total_spin
      priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.49638780000000005}
#standard deviation: 0.04327271994178319
#island_id: 2
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        neighbor_magnetism_coeff = magnetism_coeff if h[i][j][k] > 0 else -magnetism_coeff
        hamming_distance = len([val for val in interacting_spins if val != J[0,i,j,k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - neighbor_magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.26713460000000006}
#standard deviation: 0.09102023161275742
#island_id: 1
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2039366}
#standard deviation: 0.09123520603604732
#island_id: 1
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin sum
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  
  # Calculate average magnetism of each site
  avg_magnetism = np.mean(h)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate priority based on magnetism and interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * avg_magnetism
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.23444220000000002}
#standard deviation: 0.09366173828816121
#island_id: 1
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_sum = np.sum(J[0], axis=(1, 2)) + np.sum(J[1], axis=(0, 2)) + np.sum(J[2], axis=(0, 1))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - total_spin_sum[i]*h[i][j][k]
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + total_spin_sum[i]*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.09476940000000006}
#standard deviation: 0.047344527705321986
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.09476940000000006}
#standard deviation: 0.047344527705321986
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = -magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priority_up = -magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priority_down = magnetism_coeff * (hamming_distance > 0.5) - spin_difference
          priorities[i*N*N+j*N+k][0] = max(0, min(1, priority_up))
          priorities[i*N*N+j*N+k][1] = max(0, min(1, priority_down))

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5158454}
#standard deviation: 0.040918444482164765
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_difference
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_difference + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_difference = abs(sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_difference - site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2627838000000003}
#standard deviation: 0.04761396620278551
#island_id: 0
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0, 1, 2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        nn_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
        # Calculate the product of all neighboring spins
        nn_spin_product = 1
        for d in [0, 1]:
          if i > 0:
            nn_spin_product *= J[d, (i-1)%N, j, k]
          if j > 0:
            nn_spin_product *= J[d, i, (j-1)%N, k]
          if k > 0:
            nn_spin_product *= J[d, i, j, (k-1)%N]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in interacting_spins]) * nn_spin_product
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in interacting_spins]) * nn_spin_product
  
  return(priorities)




#score: {'data3D.txt': 0.3989234000000001}
#standard deviation: 0.04194681313806808
#island_id: 3
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2,3,4,5]])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * 2 - sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * 2 - sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.1709601999999998}
#standard deviation: 0.045954931573880066
#island_id: 3
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - 2*hamming_distance
          priorities[i*N*N+j*N+k][1] = 2
  return(priorities)




#score: {'data3D.txt': 0.056285800000000004}
#standard deviation: 0.04642650663532634
#island_id: 3
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i//N,(j+k)%N,k] for d in [0,1,2,3,4,5]) + h[i][j][k]
        if J[0][i//N][(j+k)%N][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 + 2*total_spin
          priorities[i*N*N+j*N+k][1] = total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time04:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          spin_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5120933999999999}
#standard deviation: 0.0406236881196181
#island_id: 0
#version_generated: 3
#generate time04:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(total_spin) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.4840410000000001}
#standard deviation: 0.04265389875497902
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        
  return(priorities)




#score: {'data3D.txt': -0.4838794000000001}
#standard deviation: 0.043369078104566625
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add a new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])

  return(priorities)




#score: {'data3D.txt': -0.4572906}
#standard deviation: 0.04088797270151701
#island_id: 0
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        # Add new term based on the product of nearest neighbor spins
        nn_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.prod([1 if val > 0 else -1 for val in nn_spins])
        priorities[i*N*N+j*N+k][1] -= np.prod([1 if val < 0 else -1 for val in nn_spins])
        # Add new term based on the site's magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.4876802000000001}
#standard deviation: 0.04231517278660221
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      priorities[i*N*N+j*N+site_nbr][0] += np.sum(h[i][j])
      priorities[i*N*N+j*N+site_nbr][1] -= np.sum(h[i][j])

  return(priorities)




#score: {'data3D.txt': -0.5092390000000001}
#standard deviation: 0.04229245652595744
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
          
  return(priorities)




#score: {'data3D.txt': -0.4876802000000001}
#standard deviation: 0.04231517278660221
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Calculate the sum of the magnetism at each site and add it to the priority
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((N-1)%2 - 1)) % N
      priorities[i*N*N+j*N+site_nbr][0] += np.sum(h[i][j])
      priorities[i*N*N+j*N+site_nbr][1] -= np.sum(h[i][j])

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin + np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) + total_spin + np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.011223400000000001}
#standard deviation: 0.04679289574753843
#island_id: 3
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0][i//N][(j+k)%N][k], J[1][(i+1)%N][j][k], J[2][i][(j+1)%N][k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.020061799999999998}
#standard deviation: 0.046886582950349455
#island_id: 3
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k]) * (np.sum(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k]) * (np.sum(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0272446}
#standard deviation: 0.04690179752248307
#island_id: 3
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4466738}
#standard deviation: 0.045470982764396026
#island_id: 3
#version_generated: 3
#generate time05:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time05:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.38553980000000027}
#standard deviation: 0.04990493218069733
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43446740000000034}
#standard deviation: 0.045317513361171964
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]

        # Add new term to account for the priority of the site itself based on its magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.18049100000000023}
#standard deviation: 0.05111071589207101
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.38553980000000027}
#standard deviation: 0.04990493218069733
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.421783}
#standard deviation: 0.03910453159161992
#island_id: 3
#version_generated: 3
#generate time05:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][1] -= 2
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.45087380000000016}
#standard deviation: 0.0471720268120843
#island_id: 3
#version_generated: 3
#generate time05:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.1217046}
#standard deviation: 0.048340353937885064
#island_id: 3
#version_generated: 3
#generate time05:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.45805420000000013}
#standard deviation: 0.04425182914140385
#island_id: 3
#version_generated: 3
#generate time05:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          spin_coeff = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N**3):
    if np.isclose(priorities[i,0], priorities[i,1]):
      if h[i//N%N][i//N//N]%N > 0:
        priorities[i] += [1, -1]
      else:
        priorities[i] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 3
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Apply priority to sites with the same energy level
        if np.isclose(priorities[i*N*N+j*N+k,0], priorities[i*N*N+j*N+k,1]):
          if h[i//N%N][i//N//N]%N > 0:
            priorities[i*N*N+j*N+k] += [1, -1]
          else:
            priorities[i*N*N+j*N+k] -= [1, -1]

  return(priorities)




#score: {'data3D.txt': -0.45805420000000013}
#standard deviation: 0.04425182914140385
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          spin_coeff = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff

  return(priorities)




#score: {'data3D.txt': -0.44080020000000003}
#standard deviation: 0.046289995030891935
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44362739999999995}
#standard deviation: 0.03977777280391651
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        neighbor_magnetism = np.sum([np.exp(J[d,i,j,k]) for d in range(6)])
        priorities[i*N*N+j*N+k][0] += (site_magnetism + neighbor_magnetism) / 2
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.044450199999999995}
#standard deviation: 0.04793494758482583
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i][j][k])
        neighbor_magnetism = np.sum([np.exp(J[d,i,j,k]) for d in range(6)])
        priorities[i*N*N+j*N+k][0] += (site_magnetism + neighbor_magnetism) / 2
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Add term to account for the site's neighbors' magnetization in the z direction
        for d in range(3):
          if i > 0:
            top_neighbor_magnetism = np.exp(J[d,i-1,j,k])
          else:
            top_neighbor_magnetism = 0
          if j > 0:
            left_neighbor_magnetism = np.exp(J[d,i,(j-1)%N,k])
          else:
            left_neighbor_magnetism = 0
          if i < N - 1:
            bottom_neighbor_magnetism = np.exp(J[d,i+1,j,k])
          else:
            bottom_neighbor_magnetism = 0
          if j < N - 1:
            right_neighbor_magnetism = np.exp(J[d,i,(j+1)%N,k])
          else:
            right_neighbor_magnetism = 0
          priorities[i*N*N+j*N+k][0] += (top_neighbor_magnetism + left_neighbor_magnetism + bottom_neighbor_magnetism + right_neighbor_magnetism) / 4
          priorities[i*N*N+j*N+k][1] -= top_neighbor_magnetism + left_neighbor_magnetism + bottom_neighbor_magnetism + right_neighbor_magnetism

  return(priorities)




#score: {'data3D.txt': -0.4527722}
#standard deviation: 0.04534467098965435
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          spin_coeff = -np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff

  return(priorities)




#score: {'data3D.txt': -0.4669942000000001}
#standard deviation: 0.043125626793821786
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        spin_magnetism = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_magnetism * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= spin_magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= spin_magnetism * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] -= spin_magnetism

  return(priorities)




#score: {'data3D.txt': -0.45809180000000016}
#standard deviation: 0.04445652092505665
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = -np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.1707821999999998}
#standard deviation: 0.04587473512904461
#island_id: 3
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] -= np.sum(np.array(interacting_spins) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] += np.sum(np.array(interacting_spins) < 0)
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 - 2*len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - 2*len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = 2
  return(priorities)




#score: {'data3D.txt': -0.1709601999999998}
#standard deviation: 0.045954931573880066
#island_id: 3
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-hamming_distance) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 4 - 4*np.exp(-hamming_distance)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-hamming_distance) + 2 - 2*total_spin
          priorities[i*N*N+j*N+k][1] += 4 - 4*np.exp(-hamming_distance)
  return(priorities)




#score: {'data3D.txt': -0.011442999999999998}
#standard deviation: 0.2519205416614532
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add a global term to account for the overall magnetization
  total_magnetism = sum(sum(h[i][j]) for i in range(N) for j in range(N))
  for i in range(N**3):
    priorities[i][0] += np.exp(total_magnetism)
    priorities[i][1] -= total_magnetism

  return(priorities)




#score: {'data3D.txt': -0.4414262}
#standard deviation: 0.04593869995504879
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.39738379999999995}
#standard deviation: 0.04691103684166446
#island_id: 3
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': 0.007215799999999936}
#standard deviation: 0.05003858381649106
#island_id: 3
#version_generated: 3
#generate time05:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.02121740000000012}
#standard deviation: 0.05068091531572808
#island_id: 3
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.16024260000000026}
#standard deviation: 0.047142476655771925
#island_id: 3
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
          site_neighbors.remove((i, j, k))
          for neighbor in site_neighbors:
            if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + h[neighbor[0]][neighbor[1]][neighbor[2]]
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[neighbor[0]][neighbor[1]][neighbor[2]]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
          site_neighbors.remove((i, j, k))
          for neighbor in site_neighbors:
            if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[neighbor[0]][neighbor[1]][neighbor[2]]
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
              priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin - h[neighbor[0]][neighbor[1]][neighbor[2]]
  return(priorities)




#score: {'data3D.txt': 0.04817259999999998}
#standard deviation: 0.04851957717499196
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_nbr_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == site_nbr and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-site_nbr)+abs(k1-k) <= 1) or (k1 == k and abs(i1-site_nbr)+abs(j1-j) <= 1))]
        site_nbr_neighbors.remove((site_nbr, j, k))
        for neighbor in site_nbr_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.44080020000000003}
#standard deviation: 0.046289995030891935
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4309682}
#standard deviation: 0.043428047950143926
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_magnetism_coeff = np.exp(h[i][j].sum())
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
      else:
        site_magnetism_coeff = -np.exp(-h[i][j].sum())
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.44080020000000003}
#standard deviation: 0.046289995030891935
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          spin_coeff = -np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4410802}
#standard deviation: 0.04618616424818152
#island_id: 3
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        spin_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_coeff * (h[i][j][k] > 0) + total_spin / len(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][1] += h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.45809180000000016}
#standard deviation: 0.04445652092505665
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = -np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.40385420000000005}
#standard deviation: 0.05048455112566616
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_magnetism = h[site_nbr][i%N][k]
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.45809180000000016}
#standard deviation: 0.04445652092505665
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself and its neighbors
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbor_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbor_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbor_magnetism > 0)
        else:
          spin_coeff = -np.exp(h[i][j][k])
          neighbor_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbor_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbor_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.4563094000000001}
#standard deviation: 0.04596117395846194
#island_id: 3
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          neighbors_magnetism = sum(J[d, site_nbr, j, k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.039879799999999986}
#standard deviation: 0.04906431933656066
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_nbr_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == site_nbr and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-site_nbr)+abs(k1-k) <= 1) or (k1 == k and abs(i1-site_nbr)+abs(j1-j) <= 1))]
        for neighbor in site_nbr_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.144731}
#standard deviation: 0.051863457646015076
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_magnetism = h[site_nbr][i%N][k]
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism
        
  for i in range(N**3):
    total_spin = np.sum([J[d, i // N % N, i % N, k] for d in range(6)])
    if h[i//N % N][i%N][k] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.039879799999999986}
#standard deviation: 0.04906431933656066
#island_id: 3
#version_generated: 3
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_nbr_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == site_nbr and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-site_nbr)+abs(k1-k) <= 1) or (k1 == k and abs(i1-site_nbr)+abs(j1-j) <= 1))]
        for neighbor in site_nbr_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]

  return priorities




#score: {'data3D.txt': -0.08496139999999999}
#standard deviation: 0.055915664978966315
#island_id: 3
#version_generated: 3
#generate time06:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_magnetism = h[site_nbr][i%N][k]
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism

  for i in range(N**3):
    total_spin = sum([J[d, i//N%N, i%N//N, k] for d in range(6) for k in [i%N]])
    if np.sum(h[i//N%N][i%N//N][k]) > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 2
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.415951}
#standard deviation: 0.04029504335523167
#island_id: 2
#version_generated: 2
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][k]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism_coeff = np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.0026625999999999998}
#standard deviation: 0.04762088576706653
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        interacting_spins = [J[d, i//N, (j+k)%N, k] for d in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': -0.1826422}
#standard deviation: 0.05867549555956047
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += 2 - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - total_spin

  return(priorities)




#score: {'data3D.txt': -0.22946300000000003}
#standard deviation: 0.04633766233853408
#island_id: 1
#version_generated: 3
#generate time07:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            if sum(val for val in site_neighbors) > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] += 1
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add new term to account for the interaction with nearest neighbors
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
            if sum(val for val in site_neighbors) > 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': -0.5101714}
#standard deviation: 0.04031464079016456
#island_id: 1
#version_generated: 3
#generate time07:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # Add new term to account for the interaction between the current site and its neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.507355}
#standard deviation: 0.04026938806339128
#island_id: 1
#version_generated: 3
#generate time07:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interactions with neighboring sites
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 2
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2109014}
#standard deviation: 0.04852962392230131
#island_id: 1
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the influence of neighboring sites
        for d in [0,1,2]:
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.507355}
#standard deviation: 0.04026938806339128
#island_id: 1
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add new term to account for the magnetism of the site itself
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        # Add new term to account for the interactions with neighboring sites
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0175486}
#standard deviation: 0.04848962649928333
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = h[i//N][j].sum()
      if site_magnetism_coeff > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.014714600000000001}
#standard deviation: 0.047303870738450146
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return priorities




#score: {'data3D.txt': -0.0256474}
#standard deviation: 0.046746264377381
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = np.exp(h[i//N][j].sum())
      for k in range(N):
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= site_magnetism_coeff + total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        neighboring_spins = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in neighboring_spins if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff + neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance - sum(val for val in neighboring_spins if val < 0)
  return(priorities)




#score: {'data3D.txt': -0.1701173999999998}
#standard deviation: 0.04472834914503328
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff
        if total_spin > 0:
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance
        else:
          priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin - 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][0] += h[i][j][k] * (h[i][j][k] > 0) + magnetism_coeff * interaction_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k] + 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i//N,j,k] for d in range(6)]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        interaction_coeff = 2 - 2*hamming_distance
        magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += total_spin * (total_spin > 0) + magnetism_coeff * interaction_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + 2*hamming_distance
  return(priorities)




#score: {'data3D.txt': -0.3516486}
#standard deviation: 0.04052374511369847
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = np.exp(-h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism < 0)

        # Add new term to account for the interaction with neighboring sites
        if i > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i-1,j,k])
          priorities[i*N*N+j*N+k][1] -= h[i-1,j,k]
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i+1,j,k])
          priorities[i*N*N+j*N+k][1] -= h[i+1,j,k]
        if j > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i,j-1,k])
          priorities[i*N*N+j*N+k][1] -= h[i,j-1,k]
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i,j+1,k])
          priorities[i*N*N+j*N+k][1] -= h[i,j+1,k]

  return(priorities)




#score: {'data3D.txt': -0.42013700000000015}
#standard deviation: 0.04663108910372992
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff + (neighbors_magnetism > 0)
          priorities[i*N*N+j*N+k][1] -= spin_coeff - (neighbors_magnetism > 0)
        else:
          spin_coeff = np.exp(-h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff + (neighbors_magnetism < 0)
          priorities[i*N*N+j*N+k][1] -= -spin_coeff - (neighbors_magnetism < 0)

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

        # Normalize the priority values
        priorities[i*N*N+j*N+k][0] /= (abs(total_spin) + 1)
        priorities[i*N*N+j*N+k][1] /= (abs(total_spin) + 1)

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.11971620000000012}
#standard deviation: 0.04929151384934328
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_magnetism = h[i][j][k]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (hamming_distance > 0.5) + site_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (hamming_distance > 0.5) - site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*abs(total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4466738}
#standard deviation: 0.045470982764396026
#island_id: 3
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = np.tanh(-h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + site_energy
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.018287400000000002}
#standard deviation: 0.04800993815076208
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.030703400000000002}
#standard deviation: 0.04673837040847701
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.030703400000000002}
#standard deviation: 0.04673837040847701
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  # Apply some magic here
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.015051000000000002}
#standard deviation: 0.04813860653363369
#island_id: 3
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          spin_coeff = np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] += spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          spin_coeff = -np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][0] -= spin_coeff * total_spin / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] += h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5350501999999999}
#standard deviation: 0.03956204342497996
#island_id: 0
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over each site in the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.411985}
#standard deviation: 0.039166755992805946
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.411985}
#standard deviation: 0.039166755992805946
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] += spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i][j][k]
        else:
          spin_coeff = np.exp(h[i][j][k])
          neighbors_magnetism = sum(J[d,site_nbr,j,k] for d in range(6))
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3563918000000003}
#standard deviation: 0.04876254682397136
#island_id: 3
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the priority of the site itself based on its magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  # Apply a learning rate to the priorities
  learning_rate = 0.5
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] *= (1 - learning_rate)
          priorities[i*N*N+j*N+k][1] *= (1 - learning_rate)
        else:
          priorities[i*N*N+j*N+k][0] /= (1 + learning_rate)
          priorities[i*N*N+j*N+k][1] /= (1 + learning_rate)

  return priorities




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 2
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.08905860000000004}
#standard deviation: 0.046902233273480705
#island_id: 2
#version_generated: 2
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate magnetism coefficients for each site
  magnetisms = np.exp(-np.abs(h).reshape(-1, 1, 1))
  
  # Iterate over all sites in the lattice
  for i in range(N):
    for j in range(N):
      for k in range(N):
        # Initialize total spin and interacting spins
        total_spin = J[0,i,j,k] + J[1,(i+1)%N,j,k] + J[2,i,(j+1)%N,k]
        
        # Check if site is interacting with at least one neighbor
        has_neighbor_interaction = any(val < 0 for val in J[:,i,j,k])
        
        # Calculate hamming distance and magnetism coefficient for this site
        hamming_distance = len([val for val in J[:,i,j,k] if val < 0]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + 1
        
        # Assign priorities
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 2
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over each site in the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Calculate magnetism coefficient based on site's own magnetism and neighboring spins
        magnetism_coeff = np.exp(-abs(total_spin)) * (np.sum(np.sign(h[i][j][k] + total_spin)) > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4725082}
#standard deviation: 0.03946942630391275
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        magnetism_coeff = np.exp(-abs(total_spin) * (h[i][j][k] > 0))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site's neighbors
        for d in range(3):
          neighbor_spins = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(neighbor_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in neighbor_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Iterate over each site in the grid
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        magnetism_coeff = np.exp(-abs(total_spin) * (h[i][j][k] > 0))
        
        for d in range(3):
          if d == i % N or d == j % N or d == k % N:
            neighbor_spins = [J[d,i,j,k], J[(d+1)%6,i,j,k]]
            magnetism_coeff += np.exp(-abs(total_spin) * (sum(neighbor_spins) > 0))
        
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48520100000000005}
#standard deviation: 0.040631307621094355
#island_id: 0
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site's neighbors
        for d in range(3):
          neighbor_spins = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(neighbor_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in neighbor_spins if val < 0)
        
        # Add a new term to account for the interactions with the sites diagonally
        for d in range(3):
          diagonal_spins = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(diagonal_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in diagonal_spins if val < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        # Calculate total spin and hamming distance
        total_spin = sum(interacting_spins)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Determine magnetism coefficient based on site's own magnetism
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Calculate priority for assigning spin -1 or 1
        priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.005399000000000001}
#standard deviation: 0.04731031387551767
#island_id: 3
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d][i//N][(j+k)%N][k] for d in [0, 1, 2, 3, 4, 5]) + h[i//N][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)




#score: {'data3D.txt': -0.0027634000000000005}
#standard deviation: 0.047561519534598556
#island_id: 3
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i//N][j][k]
        interacting_spins = [J[d, i//N, (j+k)%N, k] for d in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.47360860000000016}
#standard deviation: 0.04370715508975618
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  # Add a new term to account for the magnetism of the site itself
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0175486}
#standard deviation: 0.04848962649928333
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  # Add new term to account for the magnetism of neighboring sites
  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = h[i//N][j].sum()
      if site_magnetism_coeff > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.006602600000000001}
#standard deviation: 0.047501848734970306
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  # Calculate the magnetism of each site
  site_magnetisms = [np.sum(h[i//N], axis=0) for i in range(N)]
  
  for i in range(N):
    for j in range(N):
      if np.sum(site_magnetisms[i]) > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(np.sum(h[i//N], axis=0).max())
          priorities[i*N*N+j*N+k][1] -= np.sum(h[i//N], axis=0).max()
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.sum(h[i//N], axis=0).min())
          priorities[i*N*N+j*N+k][1] = -np.sum(h[i//N], axis=0).min()

  return(priorities)




#score: {'data3D.txt': -0.0009021999999999992}
#standard deviation: 0.047756838203130654
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i//N][(j+k)%N][k] for k in range(N)]
          site_magnetism_coeff = sum(site_neighbors)
          if site_magnetism_coeff > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
            priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
            priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0175486}
#standard deviation: 0.04848962649928333
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add new term to account for the magnetism of the site itself
        if h[i//N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i//N][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i//N][j][k]

  for i in range(N):
    for j in range(N):
      site_magnetism_coeff = h[i//N][j].sum()
      if site_magnetism_coeff > 0:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] += np.exp(site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff
      else:
        for k in range(N):
          priorities[i*N*N+j*N+k][0] -= np.exp(-site_magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = -site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.014877000000000001}
#standard deviation: 0.047233880541407994
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i//N][(j+k)%N][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]

  return priorities




#score: {'data3D.txt': -0.011223400000000001}
#standard deviation: 0.04679289574753843
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0][i//N][(j+k)%N][k], J[1][(i+1)%N][j][k], J[2][i][(j+1)%N][k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i//N][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0087062}
#standard deviation: 0.04615158460508155
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0][i//N][(j+k)%N][k], J[1][(i+1)%N][j][k], J[2][i][(j+1)%N][k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i//N][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3][i//N][(j+1)%N][k], J[4][(i+1)%N][j][k], J[5][i][j][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        site_magnetism = np.exp(h[i//N][j][k])
        priorities[i*N*N+j*N+k][0] += site_magnetism * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= site_magnetism

  return(priorities)




#score: {'data3D.txt': -0.2656334000000001}
#standard deviation: 0.044836857655727834
#island_id: 3
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_alignment = int(np.sign(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_alignment
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4273738}
#standard deviation: 0.04690085706636927
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.06144140000000001}
#standard deviation: 0.04871470010212523
#island_id: 3
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        site_neighbors_2 = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((abs(i1-i)+abs(j1-j)+abs(k1-k)) <= 1)]
        for neighbor in site_neighbors_2:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] -= h[neighbor[0]][neighbor[1]][neighbor[2]]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] = -h[neighbor[0]][neighbor[1]][neighbor[2]]

  return(priorities)




#score: {'data3D.txt': -0.05935380000000007}
#standard deviation: 0.050837371937974926
#island_id: 3
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] -= h[neighbor[0]][neighbor[1]][neighbor[2]]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[neighbor[0]][neighbor[1]][neighbor[2]])
            priorities[i*N*N+j*N+k][1] = -h[neighbor[0]][neighbor[1]][neighbor[2]]

        # Add new term to account for the magnetism of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.1217046}
#standard deviation: 0.048340353937885064
#island_id: 3
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i1, j1, k1) for i1 in range(N) for j1 in range(N) for k1 in range(N) if ((i1 == i and abs(j1-j)+abs(k1-k) <= 1) or (j1 == j and abs(i1-i)+abs(k1-k) <= 1) or (k1 == k and abs(i1-i)+abs(j1-j) <= 1))]
        site_neighbors.remove((i, j, k))
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




